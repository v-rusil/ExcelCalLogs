import { Result } from "neverthrow";
import { FxError } from "../error";
import { Func, QTreeNode } from "../qm/question";
import { ProjectSettings, Inputs, Json, Void } from "../types";
import { M365TokenProvider, TokenProvider } from "../utils";
import { Context, DeepReadonly, DeploymentInputs, EnvInfoV2, InputsWithProjectPath, ProvisionInputs } from "./types";
export declare type ResourceTemplate = BicepTemplate | JsonTemplate;
export declare type JsonTemplate = {
    kind: "json";
    template: Json;
};
export declare type BicepTemplate = {
    kind: "bicep";
    template: Record<string, unknown>;
};
export declare type ResourceProvisionOutput = {
    output: Json;
    secrets: Json;
};
/**
 * Interface for ResourcePlugins. a ResourcePlugin can hook into Toolkit's
 * lifecycles by implementing the corresponding API.
 * Implementation of all lifecycles is expected to be idempotent. The return values
 * and observable side effects of each lifecycle are expected to be the same with the same input.
 *
 * All lifecycles follow the same pattern of returning a Promise<Result<T, FxError>>.
 * Please return {@link UserError} or {@link SystemError} when error happens
 * instead of throwing.
 */
export interface ResourcePlugin {
    name: string;
    displayName: string;
    /**
     * A resource plugin can decide whether it needs to be activated when the Toolkit initializes
     * based on project settings.
     *
     * @param projectSettings project settings
     *
     * @returns whether to be activated
     */
    activate(projectSettings: ProjectSettings): boolean;
    /**
     * Called by Toolkit when creating a new project or adding a new resource.
     * A resource plugin is expected to scaffold source code or files on disk, relative to context.projectPath.
     *
     * @example
     * ```
     * scaffoldSourceCode(ctx: Context, inputs: Inputs) {
     *   const fs = require("fs-extra");
     *   let content = "let x = 1;"
     *   let path = path.join(ctx.projectPath, "myFolder");
     *   let sourcePath = "somePathhere";
     *   let result = await fs.copy(sourcePath, content);
     *   return ok(Void);
     * }
     * ```
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Inputs} inputs - User answers to questions defined in {@link getQuestionsForScaffolding} along with some system inputs.
     *
     * @returns Void because side effect is expected.
     */
    scaffoldSourceCode?: (ctx: Context, inputs: Inputs) => Promise<Result<Void, FxError>>;
    /**
     * This method is called when creating a new project or adding a new resource.
     * A resource plugin is expected to return a resource template(e.g. Bicep templates/plain JSON) which will be persisted
     * by the Toolkit and will be used to provision resource when Provision command is called.
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Inputs} inputs - User's answers to questions defined in {@link getQuestionsForScaffolding} along with some system inputs.
     *
     * @return {@link ResourceTemplate} return ARM template for solution to combine.
     */
    generateResourceTemplate?: (ctx: Context, inputs: Inputs & {
        existingResources: string[];
    }) => Promise<Result<ResourceTemplate, FxError>>;
    updateResourceTemplate?: (ctx: Context, inputs: Inputs & {
        existingResources: string[];
    }) => Promise<Result<ResourceTemplate, FxError>>;
    /**
     * provisionResource() runs before ARM/Bicep provision when Provision command is called.
     * There are two reasons why a resource needs to implement this method:
     * 1) to generate input for ARM/Bicep provision to consume.
     * 2) the resource can't be provisioned using resource templates like ARM/Bicep.
     * Two typical resources that need to implement this method are AAD(Azure Active Directory)
     * and AppSudio, which statisfy both above criteria.
     *
     * A plugin can get access tokens to cloud service using TokenProvider.
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {ProvisionInputs} inputs - inputs injected by Toolkit runtime and solution.
     * @param {EnvInfoV2} envInfo - a reference of environment info modeled after (config|state).${env}.json
     * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
     * @returns Void because side effect is expected.
     */
    provisionResource?: (ctx: Context, inputs: ProvisionInputs, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    /**
     * configureResource() is guaranteed to run after Bicep/ARM provision.
     * Plugins are expected to read the provision output of other plugins via envInfo's state,
     * and return a new copy of its own provision output possibly with added and modified fields.
     *
     * Plugins can also sync their settings to the clould using access tokens provided by TokenProvider
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {ProvisionInputs} inputs - inputs injected by Toolkit runtime and solution.
     * @param {EnvInfoV2} envInfo - a reference of environment info modeled after (config|state).${env}.json
     * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
     * @returns Void because side effect is expected.
     */
    configureResource?: (ctx: Context, inputs: ProvisionInputs, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    /**
     * Depends on the provision output values returned by {@link provisionResource}, ARM/Bicep provision
     * and {@link configureResource}.
     * Plugins are expected to deploy code to cloud using access tokens provided by {@link TokenProvider}.
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {DeploymentInputs} inputs - inputs injected by Toolkit runtime and solution.
     * @param {DeepReadonly<EnvInfoV2>} envInfo - a readonly view of environment info modeled after (config|state).${env}.json
     * @param {TokenProvider} tokenProvider - Token provider for Azure, AppStudio and m365
     * @returns Void because side effect is expected.
     */
    deploy?: (ctx: Context, inputs: DeploymentInputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<Void, FxError>>;
    /**
     * Depends on the output of {@link package}. Uploads Teams package to AppStudio
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Inputs} inputs - system inputs.
     * @param {DeepReadonly<EnvInfoV2>} envInfo - a readonly view of environment info modeled after (config|state).${env}.json
     * @param {M365TokenProvider} tokenProvider - Token for M365
     *
     * @returns Void because side effect is expected.
     */
    publishApplication?: (ctx: Context, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: M365TokenProvider) => Promise<Result<Void, FxError>>;
    /**
     * provisionLocalResource is a special lifecycle, called when users press F5 in vscode.
     * It works like provision, but only creates necessary cloud resources for local debugging like AAD and AppStudio App.
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Inputs} inputs - system inputs.
     * @param {Json} localSettings - local debug settings generated by {@link provisionLocalResource}
     * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
     * @param {EnvInfoV2} envInfo - a reference of environment info modeled after (config|state).${env}.json
     *
     * @returns Void because side effect is expected.
     */
    provisionLocalResource?: (ctx: Context, inputs: Inputs, localSettings: Json, tokenProvider: TokenProvider, envInfo?: EnvInfoV2) => Promise<Result<Void, FxError>>;
    /**
     * configureLocalResource works like {@link configureResource} but only for local debugging resources.
     * Plugins are expected to read the local provision output values of other plugins, and modify in-place
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Json} localSettings - local debug settings generated by {@link scaffoldSourceCode}
     * @param {TokenProvider} tokenProvider - Tokens for Azure and AppStudio
     * @param {EnvInfoV2} envInfo - a reference of environment info modeled after (config|state).${env}.json
     *
     * @returns Void because side effect is expected.
     */
    configureLocalResource?: (ctx: Context, inputs: Inputs, localSettings: Json, tokenProvider: TokenProvider, envInfo?: EnvInfoV2) => Promise<Result<Void, FxError>>;
    /**
     * Plugins that need to collect user input are expected to implement this method.
     * Questions are organized as a tree. Please see {@link QTreeNode}.
     *
     * getQuestionsForScaffolding() is guaranteed to be called before scaffoldSourceCode().
     *
     * @param {Context} ctx - plugin's runtime context shared by all lifecycles.
     * @param {Inputs} inputs - system inputs.
     *
     * @returns question tree.
     */
    getQuestionsForScaffolding?: (ctx: Context, inputs: Inputs) => Promise<Result<QTreeNode | undefined, FxError>>;
    executeUserTask?: (ctx: Context, inputs: Inputs, func: Func, localSettings: Json, envInfo: EnvInfoV2, tokenProvider: TokenProvider) => Promise<Result<unknown, FxError>>;
    getQuestions?: (ctx: Context, inputs: Inputs, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForUserTask?: (ctx: Context, inputs: Inputs, func: Func, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider) => Promise<Result<QTreeNode | undefined, FxError>>;
    /**
     * For grant and check permission in remote collaboration
     */
    grantPermission?: (ctx: Context, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
    checkPermission?: (ctx: Context, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
    listCollaborator?: (ctx: Context, inputs: InputsWithProjectPath, envInfo: DeepReadonly<EnvInfoV2>, tokenProvider: TokenProvider, userInfo: Json) => Promise<Result<Json, FxError>>;
}
//# sourceMappingURL=resourcePlugin.d.ts.map