"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidOperationError = exports.InvalidObjectError = exports.InvalidProjectError = exports.InvalidInputError = exports.ConcurrentError = exports.NoProjectOpenedError = exports.ReadFileError = exports.WriteFileError = exports.NotImplementedError = exports.UndefinedError = exports.ObjectNotExistError = exports.ObjectAlreadyExistsError = exports.PathNotExistError = exports.PathAlreadyExistsError = exports.EmptyOptionError = exports.UserCancelError = exports.UnknownError = exports.assembleError = exports.SystemError = exports.UserError = void 0;
/**
 * Users can recover by themselves, e.g., users input invalid app names.
 */
class UserError extends Error {
    constructor(param1, param2, param3, param4) {
        var _a, _b;
        let option;
        let stack;
        if (typeof param1 === "string") {
            option = {
                source: param1,
                name: param2,
                message: param3,
                displayMessage: param4,
            };
        }
        else {
            option = param1;
        }
        // message
        const message = option.message || ((_a = option.error) === null || _a === void 0 ? void 0 : _a.message);
        super(message);
        //name
        this.name = option.name || ((_b = option.error) === null || _b === void 0 ? void 0 : _b.name) || new.target.name;
        //source
        this.source = option.source || "unknown";
        //stack
        if (stack) {
            this.stack = stack;
        }
        else {
            Error.captureStackTrace(this, new.target);
        }
        //prototype
        Object.setPrototypeOf(this, new.target.prototype);
        //innerError
        this.innerError = option.error;
        //other fields
        this.helpLink = option.helpLink;
        this.userData = option.userData;
        this.displayMessage = option.displayMessage;
        this.timestamp = new Date();
    }
}
exports.UserError = UserError;
/**
 * Users cannot handle it by themselves.
 */
class SystemError extends Error {
    constructor(param1, param2, param3, param4) {
        var _a, _b;
        let option;
        let stack;
        if (typeof param1 === "string") {
            option = {
                source: param1,
                name: param2,
                message: param3,
                displayMessage: param4,
            };
        }
        else {
            option = param1;
        }
        // message
        const message = option.message || ((_a = option.error) === null || _a === void 0 ? void 0 : _a.message);
        super(message);
        //name
        this.name = option.name || ((_b = option.error) === null || _b === void 0 ? void 0 : _b.name) || new.target.name;
        //source
        this.source = option.source || "unknown";
        //stack
        if (stack) {
            this.stack = stack;
        }
        else {
            Error.captureStackTrace(this, new.target);
        }
        //prototype
        Object.setPrototypeOf(this, new.target.prototype);
        //innerError
        this.innerError = option.error;
        //other fields
        this.issueLink = option.issueLink;
        this.userData = option.userData;
        this.displayMessage = option.displayMessage;
        this.timestamp = new Date();
    }
}
exports.SystemError = SystemError;
function assembleError(e, source) {
    if (e instanceof UserError || e instanceof SystemError)
        return e;
    if (!source)
        source = "unknown";
    const type = typeof e;
    if (type === "string") {
        return new UnknownError(source, e);
    }
    else if (e instanceof Error) {
        const err = e;
        const fxError = new SystemError({ error: err, source });
        fxError.stack = err.stack;
        return fxError;
    }
    else {
        return new UnknownError(source, JSON.stringify(e));
    }
}
exports.assembleError = assembleError;
class UnknownError extends SystemError {
    constructor(source, message) {
        super({ source: source || "API", message: message });
    }
}
exports.UnknownError = UnknownError;
exports.UserCancelError = new UserError("UI", "UserCancel", "User canceled.");
class EmptyOptionError extends SystemError {
    constructor(source) {
        super({ source: source || "API" });
    }
}
exports.EmptyOptionError = EmptyOptionError;
class PathAlreadyExistsError extends UserError {
    constructor(source, path) {
        super({ source: source, message: `Path ${path} already exists.` });
    }
}
exports.PathAlreadyExistsError = PathAlreadyExistsError;
class PathNotExistError extends UserError {
    constructor(source, path) {
        super({ source: source, message: `Path ${path} does not exist.` });
    }
}
exports.PathNotExistError = PathNotExistError;
class ObjectAlreadyExistsError extends UserError {
    constructor(source, name) {
        super({ source: source, message: `${name} already exists.` });
    }
}
exports.ObjectAlreadyExistsError = ObjectAlreadyExistsError;
class ObjectNotExistError extends UserError {
    constructor(source, name) {
        super({ source: source, message: `${name} does not exist.` });
    }
}
exports.ObjectNotExistError = ObjectNotExistError;
class UndefinedError extends SystemError {
    constructor(source, name) {
        super({ source: source, message: `${name} is undefined, which is not expected` });
    }
}
exports.UndefinedError = UndefinedError;
class NotImplementedError extends SystemError {
    constructor(source, method) {
        super({ source: source, message: `Method not implemented:${method}` });
    }
}
exports.NotImplementedError = NotImplementedError;
class WriteFileError extends SystemError {
    constructor(source, e) {
        super({ source: source, error: e, name: "WriteFileError" });
    }
}
exports.WriteFileError = WriteFileError;
class ReadFileError extends SystemError {
    constructor(source, e) {
        super({ source: source, error: e, name: "ReadFileError" });
    }
}
exports.ReadFileError = ReadFileError;
class NoProjectOpenedError extends UserError {
    constructor(source) {
        super({
            source: source,
            message: "No project opened, you can create a new project or open an existing one.",
        });
    }
}
exports.NoProjectOpenedError = NoProjectOpenedError;
class ConcurrentError extends UserError {
    constructor(source) {
        super({
            source: source,
            message: "Previous task is still running. Please wait util your previous task to finish and try again.",
        });
    }
}
exports.ConcurrentError = ConcurrentError;
class InvalidInputError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `Input '${name}' is invalid: ${reason}` });
    }
}
exports.InvalidInputError = InvalidInputError;
class InvalidProjectError extends UserError {
    constructor(source, msg) {
        super({
            source: source,
            message: `The command only works for project created by Teams Toolkit. ${msg ? ": " + msg : ""}`,
        });
    }
}
exports.InvalidProjectError = InvalidProjectError;
class InvalidObjectError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `${name} is invalid: ${reason}` });
    }
}
exports.InvalidObjectError = InvalidObjectError;
class InvalidOperationError extends UserError {
    constructor(source, name, reason) {
        super({ source: source, message: `Invalid operation: ${name} ${reason}` });
    }
}
exports.InvalidOperationError = InvalidOperationError;
//# sourceMappingURL=error.js.map