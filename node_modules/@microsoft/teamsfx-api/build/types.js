// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = exports.mergeConfigMap = exports.ConfigMap = void 0;
class ConfigMap extends Map {
    getString(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return String(v);
    }
    getBoolean(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return Boolean(v);
    }
    getNumber(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return Number(v);
    }
    getStringArray(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return v;
    }
    getNumberArray(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return v;
    }
    getBooleanArray(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return v;
    }
    getOptionItem(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        if (v instanceof ConfigMap) {
            return v.toJSON();
        }
        else {
            return v;
        }
    }
    getOptionItemArray(k, defaultValue) {
        const v = super.get(k);
        if (!v)
            return defaultValue;
        return v;
    }
    toJSON() {
        const out = {};
        for (const entry of super.entries()) {
            if (entry[1] instanceof ConfigMap) {
                out[entry[0]] = entry[1].toJSON();
            }
            else {
                out[entry[0]] = entry[1];
            }
        }
        return out;
    }
    static fromJSON(obj) {
        if (!obj)
            return undefined;
        const map = new ConfigMap();
        for (const entry of Object.entries(obj)) {
            if (typeof entry[1] !== "object") {
                map.set(entry[0], entry[1]);
            }
            else {
                map.set(entry[0], this.fromJSON(entry[1]));
            }
        }
        return map;
    }
    constructor(entries) {
        super(entries);
        Object.setPrototypeOf(this, ConfigMap.prototype);
    }
}
exports.ConfigMap = ConfigMap;
function mergeConfigMap(lhs, rhs) {
    if (!lhs) {
        return rhs;
    }
    if (!rhs) {
        return lhs;
    }
    return new ConfigMap([...lhs.entries(), ...rhs.entries()]);
}
exports.mergeConfigMap = mergeConfigMap;
exports.Void = {};
//# sourceMappingURL=types.js.map