"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.getValidationFunction = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const jsonschema = tslib_1.__importStar(require("jsonschema"));
/**
 * A function to return a validation function according the validation schema
 * @param validation validation schema
 * @param inputs object to carry all user inputs
 * @returns a validation function
 */
function getValidationFunction(validation, inputs) {
    return function (input) {
        return validate(validation, input, inputs);
    };
}
exports.getValidationFunction = getValidationFunction;
/**
 * Implementation of validation function
 * @param validSchema validation schema
 * @param value value to validate
 * @param inputs user inputs object, which works as the context of the validation
 * @returns A human-readable string which is presented as diagnostic message.
 * Return `undefined` when 'value' is valid.
 */
async function validate(validSchema, value, inputs) {
    {
        //FuncValidation
        const funcValidation = validSchema;
        if (funcValidation.validFunc) {
            const res = await funcValidation.validFunc(value, inputs);
            return res;
        }
    }
    if (!value) {
        if (validSchema.required === true)
            return `input value is required.`;
    }
    {
        // StringValidation
        const stringValidation = validSchema;
        const strToValidate = value;
        if (typeof strToValidate === "string") {
            const schema = {};
            if (stringValidation.equals && typeof stringValidation.equals === "string")
                schema.const = stringValidation.equals;
            if (stringValidation.enum &&
                stringValidation.enum.length > 0 &&
                typeof stringValidation.enum[0] === "string")
                schema.enum = stringValidation.enum;
            if (stringValidation.minLength)
                schema.minLength = stringValidation.minLength;
            if (stringValidation.maxLength)
                schema.maxLength = stringValidation.maxLength;
            if (stringValidation.pattern)
                schema.pattern = stringValidation.pattern;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(strToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    return `'${strToValidate}' ${validateResult.errors[0].message}`;
                }
            }
            if (stringValidation.startsWith) {
                if (!strToValidate.startsWith(stringValidation.startsWith)) {
                    return `'${strToValidate}' does not meet startsWith:'${stringValidation.startsWith}'`;
                }
            }
            if (stringValidation.endsWith) {
                if (!strToValidate.endsWith(stringValidation.endsWith)) {
                    return `'${strToValidate}' does not meet endsWith:'${stringValidation.endsWith}'`;
                }
            }
            if (stringValidation.includes && typeof strToValidate === "string") {
                if (!strToValidate.includes(stringValidation.includes)) {
                    return `'${strToValidate}' does not meet includes:'${stringValidation.includes}'`;
                }
            }
            if (stringValidation.notEquals && typeof strToValidate === "string") {
                if (strToValidate === stringValidation.notEquals) {
                    return `'${strToValidate}' does not meet notEquals:'${stringValidation.notEquals}'`;
                }
            }
        }
    }
    //StringArrayValidation
    {
        const stringArrayValidation = validSchema;
        const arrayToValidate = value;
        if (arrayToValidate instanceof Array) {
            const schema = {};
            if (stringArrayValidation.maxItems)
                schema.maxItems = stringArrayValidation.maxItems;
            if (stringArrayValidation.minItems)
                schema.minItems = stringArrayValidation.minItems;
            if (stringArrayValidation.uniqueItems)
                schema.uniqueItems = stringArrayValidation.uniqueItems;
            if (Object.keys(schema).length > 0) {
                const validateResult = jsonschema.validate(arrayToValidate, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    return `'${arrayToValidate}' ${validateResult.errors[0].message}`;
                }
            }
            if (stringArrayValidation.equals) {
                if (stringArrayValidation.equals instanceof Array) {
                    stringArrayValidation.enum = stringArrayValidation.equals;
                    stringArrayValidation.containsAll = stringArrayValidation.equals;
                }
                else {
                    return `Array '${arrayToValidate}' does not equals to string:'${stringArrayValidation.equals}'`;
                }
            }
            if (stringArrayValidation.enum) {
                for (const item of arrayToValidate) {
                    if (!stringArrayValidation.enum.includes(item)) {
                        return `'${arrayToValidate}' does not meet with enum:'${stringArrayValidation.enum}'`;
                    }
                }
            }
            if (stringArrayValidation.excludes) {
                if (arrayToValidate.includes(stringArrayValidation.excludes)) {
                    return `'${arrayToValidate}' does not meet with excludes:'${stringArrayValidation.excludes}'`;
                }
            }
            if (stringArrayValidation.contains) {
                if (!arrayToValidate.includes(stringArrayValidation.contains)) {
                    return `'${arrayToValidate}' does not meet with contains:'${stringArrayValidation.contains}'`;
                }
            }
            if (stringArrayValidation.containsAll) {
                const containsAll = stringArrayValidation.containsAll;
                if (containsAll.length > 0) {
                    for (const i of containsAll) {
                        if (!arrayToValidate.includes(i)) {
                            return `'${arrayToValidate}' does not meet with containsAll:'${containsAll}'`;
                        }
                    }
                }
            }
            if (stringArrayValidation.containsAny) {
                const containsAny = stringArrayValidation.containsAny;
                if (containsAny.length > 0) {
                    // let array = valueToValidate as string[];
                    let found = false;
                    for (const i of containsAny) {
                        if (arrayToValidate.includes(i)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        return `'${arrayToValidate}' does not meet containsAny:'${containsAny}'`;
                    }
                }
            }
        }
    }
    return undefined;
}
exports.validate = validate;
//# sourceMappingURL=validation.js.map