"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupOfTasks = void 0;
const neverthrow_1 = require("neverthrow");
const error_1 = require("../error");
/**
 * An implementation of task group that will define the progress when all tasks are running
 */
class GroupOfTasks {
    constructor(tasks, config) {
        this.current = 0;
        this.isCanceled = false;
        this.tasks = tasks;
        this.config = config;
        this.total = this.tasks.length;
    }
    async run(...args) {
        if (this.tasks.length === 0)
            return neverthrow_1.ok([]);
        return new Promise(async (resolve) => {
            let results = [];
            const isFastFail = this.config && this.config.fastFail;
            const isSeq = this.config && this.config.sequential;
            if (isSeq) {
                this.current = 0;
                for (let i = 0; i < this.tasks.length; ++i) {
                    if (this.isCanceled === true) {
                        resolve(neverthrow_1.err(error_1.UserCancelError));
                        return;
                    }
                    const task = this.tasks[i];
                    if (task.name) {
                        this.message = task.name;
                    }
                    try {
                        const taskRes = await task.run(args);
                        if (taskRes.isErr() && isFastFail) {
                            this.isCanceled = true;
                            resolve(neverthrow_1.err(taskRes.error));
                            return;
                        }
                        results.push(taskRes);
                    }
                    catch (e) {
                        if (isFastFail) {
                            this.isCanceled = true;
                            resolve(neverthrow_1.err(e));
                            return;
                        }
                        results.push(neverthrow_1.err(e));
                    }
                    finally {
                        this.current = i + 1;
                    }
                }
            }
            else {
                const promiseResults = this.tasks.map((t) => t.run(args));
                promiseResults.forEach((p) => {
                    p.then((v) => {
                        this.current++;
                        if (v.isErr() && isFastFail) {
                            this.isCanceled = true;
                            resolve(neverthrow_1.err(v.error));
                            return;
                        }
                    }).catch((e) => {
                        this.current++;
                        if (isFastFail) {
                            this.isCanceled = true;
                            resolve(neverthrow_1.err(e));
                            return;
                        }
                    });
                });
                results = await Promise.all(promiseResults);
            }
            resolve(neverthrow_1.ok(results));
        });
    }
    cancel() {
        for (const task of this.tasks)
            if (task.cancel)
                task.cancel();
        this.isCanceled = true;
    }
}
exports.GroupOfTasks = GroupOfTasks;
//# sourceMappingURL=ui.js.map