"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.getCallFuncValue = exports.getSingleOption = exports.loadOptions = exports.isAutoSkipSelect = void 0;
const validation_1 = require("./validation");
const error_1 = require("../error");
const types_1 = require("../types");
const neverthrow_1 = require("neverthrow");
const constants_1 = require("../constants");
function isAutoSkipSelect(q) {
    if (q.type === "singleSelect" || q.type === "multiSelect") {
        const select = q;
        if (select.skipSingleOption && select.staticOptions.length === 1) {
            return true;
        }
    }
    return false;
}
exports.isAutoSkipSelect = isAutoSkipSelect;
async function loadOptions(q, inputs) {
    if (q.type === "singleSelect" || q.type === "multiSelect") {
        const selectQuestion = q;
        let option;
        if (selectQuestion.dynamicOptions)
            option = (await getCallFuncValue(inputs, selectQuestion.dynamicOptions));
        else
            option = selectQuestion.staticOptions;
        if (!option || option.length === 0) {
            return neverthrow_1.err(new error_1.EmptyOptionError());
        }
        if (selectQuestion.skipSingleOption && option.length === 1)
            return neverthrow_1.ok({ autoSkip: true, options: option });
        else
            return neverthrow_1.ok({ autoSkip: false, options: option });
    }
    else
        return neverthrow_1.ok({ autoSkip: false });
}
exports.loadOptions = loadOptions;
function getSingleOption(q, option) {
    if (!option)
        option = q.staticOptions;
    const optionIsString = typeof option[0] === "string";
    let returnResult;
    if (optionIsString)
        returnResult = option[0];
    else {
        if (q.returnObject === true)
            returnResult = option[0];
        else
            returnResult = option[0].id;
    }
    if (q.type === "singleSelect")
        return returnResult;
    else
        return [returnResult];
}
exports.getSingleOption = getSingleOption;
async function getCallFuncValue(inputs, raw) {
    if (raw && typeof raw === "function") {
        return await raw(inputs);
    }
    return raw;
}
exports.getCallFuncValue = getCallFuncValue;
/**
 * ask question when visiting the question tree
 * @param question
 * @param core
 * @param inputs
 */
const questionVisitor = async function (question, ui, inputs, step, totalSteps) {
    if (inputs[question.name] !== undefined) {
        return neverthrow_1.ok({ type: "skip", result: inputs[question.name] });
    }
    const title = (await getCallFuncValue(inputs, question.title));
    if (question.type === "func") {
        try {
            let res;
            if (ui.executeFunction) {
                res = await ui.executeFunction({
                    name: question.name,
                    title: title !== null && title !== void 0 ? title : "Executing operation...",
                    func: question.func,
                    inputs: inputs,
                });
            }
            else {
                res = await question.func(inputs);
            }
            if (typeof res === "object" && "isOk" in res) {
                const fxresult = res;
                if (fxresult.isOk()) {
                    return neverthrow_1.ok({ type: "success", result: fxresult.value });
                }
                else {
                    return neverthrow_1.err(fxresult.error);
                }
            }
            return neverthrow_1.ok({ type: "success", result: res });
        }
        catch (e) {
            return neverthrow_1.err(error_1.assembleError(e));
        }
    }
    else {
        const defaultValue = question.forgetLastValue !== true && question.value
            ? question.value
            : await getCallFuncValue(inputs, question.default);
        const placeholder = (await getCallFuncValue(inputs, question.placeholder));
        const prompt = (await getCallFuncValue(inputs, question.prompt));
        if (question.type === "text") {
            const validationFunc = question.validation
                ? validation_1.getValidationFunction(question.validation, inputs)
                : undefined;
            const inputQuestion = question;
            return await ui.inputText({
                name: question.name,
                title: title,
                password: inputQuestion.password,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                validation: validationFunc,
                step: step,
                totalSteps: totalSteps,
            });
        }
        else if (question.type === "singleSelect" || question.type === "multiSelect") {
            const selectQuestion = question;
            const loadRes = await loadOptions(selectQuestion, inputs);
            if (loadRes.isErr()) {
                return neverthrow_1.err(loadRes.error);
            }
            // Skip single/mulitple option select
            const res = loadRes.value;
            if (!res.options || res.options.length === 0) {
                return neverthrow_1.err(new error_1.EmptyOptionError());
            }
            if (res.autoSkip === true) {
                const returnResult = getSingleOption(selectQuestion, res.options);
                return neverthrow_1.ok({ type: "skip", result: returnResult });
            }
            if (question.type === "singleSelect") {
                return await ui.selectOption({
                    name: question.name,
                    title: title,
                    options: res.options,
                    returnObject: selectQuestion.returnObject,
                    default: defaultValue,
                    placeholder: placeholder,
                    prompt: prompt,
                    step: step,
                    totalSteps: totalSteps,
                    buttons: question.buttons,
                });
            }
            else {
                const mq = selectQuestion;
                const validationFunc = question.validation
                    ? validation_1.getValidationFunction(question.validation, inputs)
                    : undefined;
                return await ui.selectOptions({
                    name: question.name,
                    title: title,
                    options: res.options,
                    returnObject: selectQuestion.returnObject,
                    default: defaultValue,
                    placeholder: placeholder,
                    prompt: prompt,
                    onDidChangeSelection: mq.onDidChangeSelection,
                    step: step,
                    totalSteps: totalSteps,
                    validation: validationFunc,
                });
            }
        }
        else if (question.type === "multiFile") {
            const validationFunc = question.validation
                ? validation_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFiles({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
        }
        else if (question.type === "singleFile") {
            const validationFunc = question.validation
                ? validation_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFile({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                default: defaultValue,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
        }
        else if (question.type === "folder") {
            const validationFunc = question.validation
                ? validation_1.getValidationFunction(question.validation, inputs)
                : undefined;
            return await ui.selectFolder({
                name: question.name,
                title: title,
                placeholder: placeholder,
                prompt: prompt,
                default: defaultValue,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
            });
        }
    }
    return neverthrow_1.err(new error_1.UserError("API", "UnsupportedNodeType", `Unsupported question node type:${JSON.stringify(question)}`, `Unsupported question node type:${JSON.stringify(question)}`));
};
async function traverse(root, inputs, ui, telemetryReporter, visitor = questionVisitor) {
    const stack = [];
    const history = [];
    stack.push(root);
    let step = 1; // manual input step
    let totalStep = 1;
    const parentMap = new Map();
    // const valueMap = new Map<QTreeNode, unknown>();
    const autoSkipSet = new Set();
    while (stack.length > 0) {
        const curr = stack.pop();
        if (!curr)
            continue;
        //visit
        if (curr.data.type !== "group") {
            const question = curr.data;
            totalStep = step + stack.length;
            let qvRes;
            try {
                qvRes = await visitor(question, ui, inputs, step, totalStep);
                sendTelemetryEvent(telemetryReporter, qvRes, question, inputs);
            }
            catch (e) {
                return neverthrow_1.err(error_1.assembleError(e));
            }
            if (qvRes.isErr()) {
                // Cancel or Error
                return neverthrow_1.err(qvRes.error);
            }
            const inputResult = qvRes.value;
            if (inputResult.type === "back") {
                //go back
                // if (curr.children) {
                //   while (stack.length > 0) {
                //     const tmp = stack[stack.length - 1];
                //     if (curr.children.includes(tmp)) {
                //       stack.pop();
                //     } else {
                //       break;
                //     }
                //   }
                // }
                stack.push(curr);
                // find the previous input that is neither group nor func nor single option select
                let found = false;
                while (history.length > 0) {
                    const last = history.pop();
                    if (!last)
                        continue;
                    if (last.children) {
                        while (stack.length > 0) {
                            const tmp = stack[stack.length - 1];
                            if (last.children.includes(tmp)) {
                                stack.pop();
                            }
                            else {
                                break;
                            }
                        }
                    }
                    stack.push(last);
                    if (last.data.type !== "group")
                        delete inputs[last.data.name];
                    const lastIsAutoSkip = autoSkipSet.has(last);
                    if (last.data.type !== "group" && last.data.type !== "func" && !lastIsAutoSkip) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return neverthrow_1.err(error_1.UserCancelError);
                }
                --step;
                continue; //ignore the following steps
            }
            else {
                //success or skip
                question.value = inputResult.result;
                inputs[question.name] = question.value;
                if (inputResult.type === "skip" || question.type === "func") {
                    if (inputResult.type === "skip")
                        autoSkipSet.add(curr);
                }
                else {
                    ++step;
                }
            }
        }
        history.push(curr);
        if (curr.children) {
            const matchChildren = [];
            const valueInMap = findValue(curr, parentMap); //curr.data.type !== "group" ? curr.data.value : undefined; //valueMap.get(curr);
            for (const child of curr.children) {
                if (!child)
                    continue;
                if (child.condition) {
                    const validRes = await validation_1.validate(child.condition, valueInMap, inputs);
                    if (validRes !== undefined) {
                        continue;
                    }
                }
                matchChildren.push(child);
            }
            for (let i = matchChildren.length - 1; i >= 0; --i) {
                const child = matchChildren[i];
                parentMap.set(child, curr);
                stack.push(child);
            }
        }
    }
    return neverthrow_1.ok(types_1.Void);
}
exports.traverse = traverse;
function findValue(curr, parentMap) {
    if (curr.data.type !== "group") {
        // need to convert OptionItem value into id for validation
        if (curr.data.type === "singleSelect") {
            const sq = curr.data;
            if (sq.value && typeof sq.value !== "string" && sq.value.id) {
                return sq.value.id;
            }
        }
        else if (curr.data.type === "multiSelect") {
            const mq = curr.data;
            if (mq.value && typeof mq.value[0] !== "string") {
                return mq.value.map((i) => i.id);
            }
        }
        return curr.data.value;
    }
    const parent = parentMap.get(curr);
    if (parent) {
        return findValue(parent, parentMap);
    }
    return undefined;
}
function sendTelemetryEvent(telemetryReporter, qvres, question, inputs) {
    var _a;
    if (qvres.isErr()) {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.TelemetryEvent.askQuestion, {
            [constants_1.TelemetryProperty.answerType]: qvres.error.name,
            [constants_1.TelemetryProperty.question]: question.name,
            [constants_1.TelemetryProperty.platform]: inputs.platform,
            [constants_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
    else {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.TelemetryEvent.askQuestion, {
            [constants_1.TelemetryProperty.answerType]: qvres.value.type,
            [constants_1.TelemetryProperty.question]: question.name,
            [constants_1.TelemetryProperty.answer]: question.type == "singleSelect" || question.type == "multiSelect"
                ? (_a = qvres.value.result) === null || _a === void 0 ? void 0 : _a.toString()
                : "",
            [constants_1.TelemetryProperty.platform]: inputs.platform,
            [constants_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
}
//# sourceMappingURL=visitor.js.map