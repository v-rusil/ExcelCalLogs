"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryReporter = exports.getLifecycleDescription = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const os_1 = require("os");
const constant_1 = require("../configManager/constant");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const indent = "  ";
function getActionName(driverDef) {
    return driverDef.name ? `${driverDef.uses}(${driverDef.name})` : driverDef.uses;
}
function getDriverDescription(log, lifecycle) {
    const n = lifecycle.driverDefs.length;
    return lifecycle.resolveDriverInstances(log).map((instances) => {
        return instances.map((instance, i) => {
            const actionName = getActionName(instance);
            const desc = instance.instance.description ? `: ${instance.instance.description}` : "";
            return `(${i + 1}/${n}) Action ${actionName}${desc}`;
        });
    });
}
function getLifecycleDescription(log, lifecycle) {
    const n = lifecycle.driverDefs.length;
    return getDriverDescription(log, lifecycle).map((descriptions) => {
        const s = `Running lifecycle stage: ${lifecycle.name}(${n} step(s) in total) The following actions will be executed${os_1.EOL}${descriptions.join(os_1.EOL)}`;
        return s;
    });
}
exports.getLifecycleDescription = getLifecycleDescription;
function initLifecycleState(lifecycle) {
    return {
        name: lifecycle.name,
        status: "notExecuted",
        actionStates: initActionStates(lifecycle),
    };
}
function updateLifecycleState(state, execResult) {
    if (execResult.result.isOk()) {
        state.status = "succeeded";
    }
    else {
        state.status = "failed";
    }
    updateActionStates(state.actionStates, execResult);
}
function initActionStates(lifecycle) {
    return lifecycle.driverDefs.map((driverDef) => {
        return {
            name: getActionName(driverDef),
            status: "notExecuted",
            summaries: [],
        };
    });
}
function updateActionStates(actionStates, executionResult) {
    const { result, summaries } = executionResult;
    if (result.isOk()) {
        actionStates.forEach((actionState, i) => {
            actionState.status = "succeeded";
            if (summaries[i]) {
                actionState.summaries = summaries[i];
            }
        });
    }
    else if (result.isErr()) {
        const e = result.error;
        if (e.kind === "Failure") {
            // just ignore Failure, because we can leave action states as "notExecuted"
        }
        else if (e.kind === "PartialSuccess") {
            const executedActionNum = summaries.length;
            actionStates.forEach((actionState, i) => {
                if (i < executedActionNum - 1) {
                    actionState.status = "succeeded";
                }
                else if (i == executedActionNum - 1) {
                    actionState.status = "failed";
                }
                if (summaries[i]) {
                    actionState.summaries = summaries[i];
                }
            });
        }
    }
}
function stringifyLifecycleState(lifecycleState) {
    const result = [];
    if (lifecycleState.status === "notExecuted") {
        result.push(`${constant_1.SummaryConstant.NotExecuted} Lifecycle stage ${lifecycleState.name} not executed.`);
    }
    else if (lifecycleState.status === "succeeded") {
        result.push(`${constant_1.SummaryConstant.Succeeded} Lifecycle stage ${lifecycleState.name} executed successfully`);
    }
    else if (lifecycleState.status === "failed") {
        result.push(`${constant_1.SummaryConstant.Failed} Lifecycle stage ${lifecycleState.name} failed.`);
    }
    for (const actionState of lifecycleState.actionStates) {
        if (actionState.status === "notExecuted") {
            result.push(`${indent}${constant_1.SummaryConstant.NotExecuted} ${actionState.name} not executed.`);
        }
        else if (actionState.status === "failed") {
            result.push(`${indent}${constant_1.SummaryConstant.Failed} ${actionState.name} failed.`);
        }
        else if (actionState.status === "succeeded") {
            result.push(`${indent}${constant_1.SummaryConstant.Succeeded} ${actionState.name} executed successfully.`);
        }
        for (const summary of actionState.summaries) {
            if (actionState.status === "notExecuted") {
                result.push(`${indent}${indent}${constant_1.SummaryConstant.NotExecuted} ${summary}`);
            }
            else {
                result.push(`${indent}${indent}${summary}`);
            }
        }
    }
    return result;
}
class SummaryReporter {
    constructor(lifecycles, log) {
        this.lifecycles = lifecycles;
        this.lifecycleStates = lifecycles.map((lifecycle) => initLifecycleState(lifecycle));
        this.log = log;
    }
    // This method returns a Result, because it could fail due to driver resolution failure.
    getLifecycleDescriptions() {
        return teamsfx_api_1.combine(this.lifecycles.map((lifecycle) => getLifecycleDescription(this.log, lifecycle))).map((descriptions) => descriptions.join(os_1.EOL));
    }
    updateLifecycleState(index, execResult) {
        updateLifecycleState(this.lifecycleStates[index], execResult);
    }
    getLifecycleSummary(createdEnvFile = undefined) {
        const summaries = this.lifecycleStates.map((lifecycleState) => {
            return stringifyLifecycleState(lifecycleState);
        });
        const flattened = lodash_1.default.flatten(summaries);
        return `Summary:${os_1.EOL}${createdEnvFile ? "  Created environment file at " + createdEnvFile + os_1.EOL + os_1.EOL : ""}${flattened.join(os_1.EOL)}`;
    }
}
exports.SummaryReporter = SummaryReporter;
//# sourceMappingURL=summary.js.map