"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const path = tslib_1.__importStar(require("path"));
const azureResource_1 = require("../azureResource");
const constants_1 = require("../../constants");
const messages_1 = require("../../messages");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const constants_2 = require("./constants");
const configs_1 = require("./configs");
const clients_1 = require("./clients");
const deploy_1 = require("../../code/tab/deploy");
const messages_2 = require("./messages");
const telemetry_1 = require("../../../common/telemetry");
let AzureStorageResource = class AzureStorageResource extends azureResource_1.AzureResource {
    constructor() {
        super(...arguments);
        this.name = "azure-storage";
        this.bicepModuleName = "azureStorage";
        this.outputs = constants_1.StorageOutputs;
        this.finalOutputKeys = ["domain", "endpoint", "storageResourceId", "indexPath"];
    }
    async configure(context, inputs, actionContext) {
        var _a, _b;
        const ctx = context;
        if (context.envInfo.envName !== "local") {
            context.logProvider.info(messages_1.LogMessages.enableStaticWebsite);
            await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.enableStaticWebsite));
            const config = await configs_1.StorageConfig.fromEnvInfo(ctx.envInfo, constants_1.ComponentNames.TeamsTab, ctx.tokenProvider.azureAccountProvider);
            const client = new clients_1.AzureStorageClient(config, context.logProvider);
            await client.enableStaticWebsite();
        }
        else {
            await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(""));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(context, inputs, actionContext) {
        const ctx = context;
        const deployDir = path.resolve(inputs.projectPath, inputs.artifactFolder);
        const config = await configs_1.StorageConfig.fromEnvInfo(ctx.envInfo, inputs.componentId, ctx.tokenProvider.azureAccountProvider);
        const client = new clients_1.AzureStorageClient(config, context.logProvider);
        const envName = ctx.envInfo.envName;
        const needDeploy = await deploy_1.FrontendDeployment.needDeploy(path.join(inputs.projectPath, constants_1.PathConstants.tabWorkingDir), envName);
        if (!needDeploy) {
            await this.skipDeploy(context, actionContext);
            return teamsfx_api_1.ok(undefined);
        }
        await this.doDeployment(client, deployDir, actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar);
        await deploy_1.FrontendDeployment.saveDeploymentInfo(path.join(inputs.projectPath, constants_1.PathConstants.tabWorkingDir), envName, { lastDeployTime: new Date().toISOString() });
        return teamsfx_api_1.ok(undefined);
    }
    async doDeployment(client, deployDir, progress) {
        await (progress === null || progress === void 0 ? void 0 : progress.next(messages_1.ProgressMessages.getDeploymentSrcAndDest));
        const container = await client.getContainer(constants_2.StorageConstants.azureStorageWebContainer);
        await (progress === null || progress === void 0 ? void 0 : progress.next(messages_1.ProgressMessages.clearStorageAccount));
        await client.deleteAllBlobs(container);
        await (progress === null || progress === void 0 ? void 0 : progress.next(messages_1.ProgressMessages.uploadTabToStorage));
        await client.uploadFiles(container, deployDir);
    }
    async skipDeploy(context, actionContext) {
        var _a, _b, _c;
        context.logProvider.warning(messages_2.Messages.SkipDeploy);
        context.telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.SkipDeploy, {
            [telemetry_1.TelemetryProperty.Component]: constants_1.ComponentNames.AzureStorage,
        });
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.getDeploymentSrcAndDest));
        await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_1.ProgressMessages.clearStorageAccount));
        await ((_c = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.uploadTabToStorage));
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: constants_2.errorSource,
            errorHelpLink: constants_2.StorageConstants.helpLink,
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.configureStorage,
            progressSteps: 1,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageResource.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: constants_2.errorSource,
            errorHelpLink: constants_2.StorageConstants.helpLink,
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.deploying(constants_1.ComponentNames.AzureStorage, constants_1.Scenarios.Tab),
            progressSteps: messages_2.Progress.length,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageResource.prototype, "deploy", null);
AzureStorageResource = tslib_1.__decorate([
    typedi_1.Service("azure-storage")
], AzureStorageResource);
exports.AzureStorageResource = AzureStorageResource;
//# sourceMappingURL=azureStorage.js.map