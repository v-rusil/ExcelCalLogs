"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageClient = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const storage_blob_1 = require("@azure/storage-blob");
const arm_storage_1 = require("@azure/arm-storage");
const mime = tslib_1.__importStar(require("mime"));
const path = tslib_1.__importStar(require("path"));
const messages_1 = require("./messages");
const constants_1 = require("./constants");
const fileOperation_1 = require("../../utils/fileOperation");
class AzureStorageClient {
    constructor(config, logger) {
        this.resourceGroupName = config.resourceGroupName;
        this.storageName = config.storageName;
        this.storageAccountClient = new arm_storage_1.StorageManagementClient(config.credentials, config.subscriptionId).storageAccounts;
        this.logger = logger;
    }
    async isStorageStaticWebsiteEnabled() {
        var _a, _b;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(messages_1.Messages.StartCheckStaticWebsiteEnabled(this.storageName));
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        const result = (_b = (await blobClient.getProperties()).staticWebsite) === null || _b === void 0 ? void 0 : _b.enabled;
        return result;
    }
    async enableStaticWebsite() {
        var _a, _b;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(messages_1.Messages.StartEnableStaticWebsite(this.storageName));
        if (await this.isStorageStaticWebsiteEnabled()) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(messages_1.Messages.SkipEnableStaticWebsite(this.storageName));
            return;
        }
        const properties = AzureStorageClient.getStaticWebsiteEnableParams();
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        return blobClient.setProperties(properties);
    }
    async getContainer(containerName) {
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        const container = blobClient.getContainerClient(containerName);
        if (!(await container.exists())) {
            await container.create();
        }
        return container;
    }
    async deleteAllBlobs(client) {
        var e_1, _a;
        var _b, _c;
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(messages_1.Messages.StartDeleteAllBlobs(this.storageName, constants_1.StorageConstants.azureStorageWebContainer));
        const deleteJobs = [];
        try {
            for (var _d = tslib_1.__asyncValues(client.listBlobsFlat()), _e; _e = await _d.next(), !_e.done;) {
                const blob = _e.value;
                if (AzureStorageClient.isBlobFile(blob)) {
                    deleteJobs.push(client.deleteBlob(blob.name));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) await _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const responses = await Promise.all(deleteJobs);
        const errorResponse = responses.find((res) => res.errorCode !== undefined);
        if (errorResponse) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error(JSON.stringify(errorResponse));
            throw new Error(messages_1.Messages.FailedOperationWithErrorCode("delete blob", errorResponse.errorCode));
        }
    }
    async uploadFiles(client, sourceFolder) {
        var _a, _b;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(messages_1.Messages.StartSyncLocalToStorage(sourceFolder, this.storageName));
        const filePathsToUpload = await fileOperation_1.listFilePaths(sourceFolder);
        const responses = await Promise.all(filePathsToUpload.map((filePath) => {
            const destFilePath = path.relative(sourceFolder, filePath);
            return AzureStorageClient.uploadLocalFile(client, filePath, destFilePath);
        }));
        const errorResponse = responses.find((res) => res.errorCode !== undefined);
        if (errorResponse) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(JSON.stringify(errorResponse));
            throw new Error(messages_1.Messages.FailedOperationWithErrorCode("upload file", errorResponse.errorCode));
        }
    }
    static isBlobFile(blob) {
        return blob.properties.contentLength !== undefined && blob.properties.contentLength > 0;
    }
    static uploadLocalFile(client, filePath, blobPath) {
        const blockBlobClient = client.getBlockBlobClient(blobPath);
        const options = {
            blobHTTPHeaders: {
                blobContentType: mime.getType(blobPath) || undefined,
            },
        };
        return blockBlobClient.uploadFile(filePath, options);
    }
    static async getBlobServiceClient(blobUri, sasToken) {
        const connectionString = `BlobEndpoint=${blobUri};SharedAccessSignature=${sasToken}`;
        return storage_blob_1.BlobServiceClient.fromConnectionString(connectionString);
    }
    static getBlobUri(storageName) {
        return `https://${storageName}.blob.core.windows.net`;
    }
    static async generateSasToken(client, resourceGroupName, storageName) {
        const accountSasParameters = {
            // A workaround, to ignore type checking for the services/resourceTypes/permissions are enum type.
            services: "bf",
            resourceTypes: "sco",
            permissions: "rwld",
            sharedAccessStartTime: new Date(Date.now() - constants_1.StorageConstants.sasTokenLifetimePadding),
            sharedAccessExpiryTime: new Date(Date.now() + constants_1.StorageConstants.sasTokenLifetime),
        };
        const token = (await client.listAccountSAS(resourceGroupName, storageName, accountSasParameters)).accountSasToken;
        if (!token) {
            throw new Error(messages_1.Messages.GetEmptySasToken);
        }
        return token;
    }
    static getStaticWebsiteEnableParams() {
        return {
            staticWebsite: {
                indexDocument: constants_1.StorageConstants.indexDocument,
                errorDocument404Path: constants_1.StorageConstants.errorDocument,
                enabled: true,
            },
        };
    }
}
exports.AzureStorageClient = AzureStorageClient;
//# sourceMappingURL=clients.js.map