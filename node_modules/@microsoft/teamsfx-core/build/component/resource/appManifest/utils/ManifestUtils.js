"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifestUtils = exports.getManifestTemplatePath = exports.resolveManifestTemplate = exports.ManifestUtils = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const uuid_1 = require("uuid");
require("reflect-metadata");
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const utils_1 = require("../../../../common/utils");
const migrate_1 = require("../../../migrate");
const errors_1 = require("../errors");
const results_1 = require("../results");
const lodash_1 = require("lodash");
const constants_1 = require("../constants");
const constants_2 = require("../../../constants");
const utils_2 = require("./utils");
const telemetry_1 = require("./telemetry");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const localizeUtils_1 = require("../../../../common/localizeUtils");
const constants_3 = require("../../../../common/constants");
const constants_4 = require("../../../constants");
const tools_1 = require("../../../../common/tools");
const projectSettingsHelperV3_1 = require("../../../../common/projectSettingsHelperV3");
const common_1 = require("../../../utils/common");
class ManifestUtils {
    async readAppManifest(projectPath) {
        const filePath = await this.getTeamsAppManifestPath(projectPath);
        return await this._readAppManifest(filePath);
    }
    async _readAppManifest(manifestTemplatePath) {
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(manifestTemplatePath)));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(manifestTemplatePath, { encoding: "utf-8" });
        content = strip_bom_1.default(content);
        const contentV3 = migrate_1.convertManifestTemplateToV3(content);
        const manifest = JSON.parse(contentV3);
        return teamsfx_api_1.ok(manifest);
    }
    async writeAppManifest(appManifest, projectPath) {
        const filePath = await this.getTeamsAppManifestPath(projectPath);
        const content = JSON.stringify(appManifest, undefined, 4);
        const contentV2 = migrate_1.convertManifestTemplateToV2(content);
        await fs_extra_1.default.writeFile(filePath, contentV2);
        return teamsfx_api_1.ok(undefined);
    }
    async getTeamsAppManifestPath(projectPath) {
        const templateFolder = await utils_1.getProjectTemplatesFolderPath(projectPath);
        const filePath = tools_1.isV3Enabled()
            ? path.join(projectPath, "appPackage", "manifest.json")
            : path.join(templateFolder, "appPackage", "manifest.template.json");
        return filePath;
    }
    async addCapabilities(inputs, capabilities, isM365 = false) {
        var _a, _b, _c, _d;
        const appManifestRes = await this.readAppManifest(inputs.projectPath);
        if (appManifestRes.isErr())
            return teamsfx_api_1.err(appManifestRes.error);
        const appManifest = appManifestRes.value;
        for (const capability of capabilities) {
            const exceedLimit = this._capabilityExceedLimit(appManifest, capability.name);
            if (exceedLimit) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.CapabilityExceedLimitError.name, errors_1.AppStudioError.CapabilityExceedLimitError.message(capability.name)));
            }
            let staticTabIndex = (_b = (_a = appManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            switch (capability.name) {
                case "staticTab":
                    appManifest.staticTabs = appManifest.staticTabs || [];
                    if (capability.snippet) {
                        appManifest.staticTabs.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            const template = lodash_1.cloneDeep(constants_1.STATIC_TABS_TPL_EXISTING_APP[0]);
                            template.entityId = "index" + staticTabIndex;
                            appManifest.staticTabs.push(template);
                        }
                        else {
                            const tabManifest = inputs.features === constants_2.DashboardOptionItem().id
                                ? constants_1.STATIC_TABS_TPL_V3[1]
                                : constants_1.STATIC_TABS_TPL_V3[0];
                            const template = lodash_1.cloneDeep(tabManifest);
                            template.entityId = "index" + staticTabIndex;
                            appManifest.staticTabs.push(template);
                        }
                        staticTabIndex++;
                    }
                    break;
                case "configurableTab":
                    appManifest.configurableTabs = appManifest.configurableTabs || [];
                    if (capability.snippet) {
                        appManifest.configurableTabs.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.configurableTabs = appManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_EXISTING_APP);
                        }
                        else {
                            appManifest.configurableTabs =
                                appManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_V3);
                        }
                    }
                    break;
                case "Bot":
                    appManifest.bots = appManifest.bots || [];
                    if (capability.snippet) {
                        appManifest.bots.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_EXISTING_APP);
                        }
                        else {
                            // import CoreQuestionNames introduces dependency cycle and breaks the whole program
                            // inputs[CoreQuestionNames.Features]
                            if (inputs.features) {
                                const feature = inputs.features;
                                if (feature === constants_2.CommandAndResponseOptionItem().id ||
                                    feature == constants_2.WorkflowOptionItem().id) {
                                    // command and response bot or workflow bot
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_FOR_COMMAND_AND_RESPONSE_V3);
                                }
                                else if (feature === constants_2.NotificationOptionItem().id) {
                                    // notification
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_FOR_NOTIFICATION_V3);
                                }
                                else {
                                    // legacy bot
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_V3);
                                }
                            }
                            else if (inputs.scenarios) {
                                const scenariosRaw = inputs.scenarios;
                                const scenarios = Array.isArray(scenariosRaw) ? scenariosRaw : [];
                                if (scenarios.includes(constants_2.BotScenario.CommandAndResponseBot) ||
                                    scenarios.includes(constants_2.BotScenario.WorkflowBot)) {
                                    // command and response bot or workflow bot
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_FOR_COMMAND_AND_RESPONSE_V3);
                                }
                                else if (scenarios.includes(constants_2.BotScenario.NotificationBot)) {
                                    // notification
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_FOR_NOTIFICATION_V3);
                                }
                                else {
                                    // legacy bot
                                    appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_V3);
                                }
                            }
                            else {
                                appManifest.bots = appManifest.bots.concat(constants_1.BOTS_TPL_V3);
                            }
                        }
                    }
                    break;
                case "MessageExtension":
                    appManifest.composeExtensions = appManifest.composeExtensions || [];
                    if (capability.snippet) {
                        appManifest.composeExtensions.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.composeExtensions = appManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                        }
                        else {
                            appManifest.composeExtensions = appManifest.composeExtensions.concat(isM365 ? constants_1.COMPOSE_EXTENSIONS_TPL_M365_V3 : constants_1.COMPOSE_EXTENSIONS_TPL_V3);
                        }
                    }
                    break;
                case "WebApplicationInfo":
                    if (capability.snippet) {
                        appManifest.webApplicationInfo = capability.snippet;
                    }
                    else {
                        appManifest.webApplicationInfo = constants_1.WEB_APPLICATION_INFO_V3;
                    }
                    break;
            }
        }
        if (inputs.validDomain && !((_c = appManifest.validDomains) === null || _c === void 0 ? void 0 : _c.includes(inputs.validDomain))) {
            (_d = appManifest.validDomains) === null || _d === void 0 ? void 0 : _d.push(inputs.validDomain);
        }
        const writeRes = await this.writeAppManifest(appManifest, inputs.projectPath);
        if (writeRes.isErr())
            return teamsfx_api_1.err(writeRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    async updateCapability(projectPath, capability) {
        var _a;
        const appManifestRes = await this.readAppManifest(projectPath);
        if (appManifestRes.isErr())
            return teamsfx_api_1.err(appManifestRes.error);
        const manifest = appManifestRes.value;
        switch (capability.name) {
            case "staticTab":
                // find the corresponding static Tab with entity id
                const entityId = capability.snippet.entityId;
                const index = (_a = manifest.staticTabs) === null || _a === void 0 ? void 0 : _a.map((x) => x.entityId).indexOf(entityId);
                if (index !== undefined && index !== -1) {
                    manifest.staticTabs[index] = capability.snippet;
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.StaticTabNotExistError.name, errors_1.AppStudioError.StaticTabNotExistError.message(entityId)));
                }
                break;
            case "configurableTab":
                if (manifest.configurableTabs && manifest.configurableTabs.length) {
                    manifest.configurableTabs[0] = capability.snippet;
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "Bot":
                if (manifest.bots && manifest.bots.length > 0) {
                    manifest.bots[0] = capability.snippet;
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "MessageExtension":
                if (manifest.composeExtensions && manifest.composeExtensions.length > 0) {
                    manifest.composeExtensions[0] = capability.snippet;
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "WebApplicationInfo":
                manifest.webApplicationInfo = capability.snippet;
                break;
        }
        const writeRes = await this.writeAppManifest(manifest, projectPath);
        if (writeRes.isErr())
            return teamsfx_api_1.err(writeRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    async deleteCapability(projectPath, capability) {
        var _a;
        const appManifestRes = await this.readAppManifest(projectPath);
        if (appManifestRes.isErr())
            return teamsfx_api_1.err(appManifestRes.error);
        const manifest = appManifestRes.value;
        switch (capability.name) {
            case "staticTab":
                // find the corresponding static Tab with entity id
                const entityId = capability.snippet.entityId;
                const index = (_a = manifest.staticTabs) === null || _a === void 0 ? void 0 : _a.map((x) => x.entityId).indexOf(entityId);
                if (index !== undefined && index !== -1) {
                    manifest.staticTabs.slice(index, 1);
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.StaticTabNotExistError.name, errors_1.AppStudioError.StaticTabNotExistError.message(entityId)));
                }
                break;
            case "configurableTab":
                if (manifest.configurableTabs && manifest.configurableTabs.length > 0) {
                    manifest.configurableTabs = [];
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "Bot":
                if (manifest.bots && manifest.bots.length > 0) {
                    manifest.bots = [];
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "MessageExtension":
                if (manifest.composeExtensions && manifest.composeExtensions.length > 0) {
                    manifest.composeExtensions = [];
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
                }
                break;
            case "WebApplicationInfo":
                manifest.webApplicationInfo = undefined;
                break;
        }
        const writeRes = await this.writeAppManifest(manifest, projectPath);
        if (writeRes.isErr())
            return teamsfx_api_1.err(writeRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    async capabilityExceedLimit(projectPath, capability) {
        const manifestRes = await this.readAppManifest(projectPath);
        if (manifestRes.isErr())
            return teamsfx_api_1.err(manifestRes.error);
        return teamsfx_api_1.ok(this._capabilityExceedLimit(manifestRes.value, capability));
    }
    _capabilityExceedLimit(manifest, capability) {
        switch (capability) {
            case "staticTab":
                return (manifest.staticTabs !== undefined && manifest.staticTabs.length >= constants_1.STATIC_TABS_MAX_ITEMS);
            case "configurableTab":
                return manifest.configurableTabs !== undefined && manifest.configurableTabs.length >= 1;
            case "Bot":
                return manifest.bots !== undefined && manifest.bots.length >= 1;
            case "MessageExtension":
                return manifest.composeExtensions !== undefined && manifest.composeExtensions.length >= 1;
            case "WebApplicationInfo":
                return false;
            default:
                return false;
        }
    }
    _getCapabilities(template) {
        const capabilities = [];
        if (template.staticTabs && template.staticTabs.length > 0) {
            capabilities.push("staticTab");
        }
        if (template.configurableTabs && template.configurableTabs.length > 0) {
            capabilities.push("configurableTab");
        }
        if (template.bots && template.bots.length > 0) {
            capabilities.push("Bot");
        }
        if (template.composeExtensions) {
            capabilities.push("MessageExtension");
        }
        return teamsfx_api_1.ok(capabilities);
    }
    /**
     * Only works for manifest.template.json
     * @param projectRoot
     * @returns
     */
    async getCapabilities(projectRoot) {
        const manifestRes = await this.readAppManifest(projectRoot);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        return this._getCapabilities(manifestRes.value);
    }
    async getManifest(projectPath, envInfo, ignoreEnvStateValueMissing, telemetryProps) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        // Read template
        const manifestTemplateRes = await exports.manifestUtils.readAppManifest(projectPath);
        if (manifestTemplateRes.isErr()) {
            return teamsfx_api_1.err(manifestTemplateRes.error);
        }
        const templateJson = manifestTemplateRes.value;
        //adjust template for samples with unnecessary placeholders
        const capabilities = this._getCapabilities(templateJson);
        if (capabilities.isErr()) {
            return teamsfx_api_1.err(capabilities.error);
        }
        const hasFrontend = capabilities.value.includes("staticTab") || capabilities.value.includes("configurableTab");
        const tabEndpoint = (_a = envInfo.state[constants_4.ComponentNames.TeamsTab]) === null || _a === void 0 ? void 0 : _a.endpoint;
        const hasUnresolvedPlaceholders = JSON.stringify(templateJson.developer).match(constants_1.manifestStateDataRegex) !== null;
        if (!tabEndpoint && !hasFrontend && hasUnresolvedPlaceholders) {
            templateJson.developer = constants_1.DEFAULT_DEVELOPER;
        }
        const manifestTemplateString = JSON.stringify(templateJson);
        const customizedKeys = utils_2.getCustomizedKeys("", JSON.parse(manifestTemplateString));
        if (telemetryProps) {
            telemetryProps[telemetry_1.TelemetryPropertyKey.customizedKeys] = JSON.stringify(customizedKeys);
        }
        // Render mustache template with state and config
        const resolvedManifestString = resolveManifestTemplate(envInfo, manifestTemplateString, !ignoreEnvStateValueMissing);
        const isLocalDebug = envInfo.envName === "local";
        const isProvisionSucceeded = envInfo.state.solution.provisionSucceeded === "true" ||
            envInfo.state.solution.provisionSucceeded === true;
        const tokens = [
            ...new Set(mustache_1.default.parse(resolvedManifestString)
                .filter((x) => {
                return x[0] != "text" && x[1] != "state.app-manifest.teamsAppId";
            })
                .map((x) => x[1])),
        ];
        if (tokens.length > 0) {
            if (isLocalDebug) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(","))))));
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(",")), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        const manifest = JSON.parse(resolvedManifestString);
        // dynamically set validDomains for manifest, which can be refactored by static manifest templates
        if (isLocalDebug || ((_b = manifest.validDomains) === null || _b === void 0 ? void 0 : _b.length) === 0) {
            const validDomains = [];
            const tabEndpoint = (_c = envInfo.state[constants_4.ComponentNames.TeamsTab]) === null || _c === void 0 ? void 0 : _c.endpoint;
            const tabDomain = (_d = envInfo.state[constants_4.ComponentNames.TeamsTab]) === null || _d === void 0 ? void 0 : _d.domain;
            if (tabDomain) {
                validDomains.push(tabDomain);
            }
            if (tabEndpoint && isLocalDebug) {
                validDomains.push(tabEndpoint.slice(8));
            }
            const botId = (_e = envInfo.state[constants_4.ComponentNames.TeamsBot]) === null || _e === void 0 ? void 0 : _e.botId;
            const botDomain = ((_f = envInfo.state[constants_4.ComponentNames.TeamsBot]) === null || _f === void 0 ? void 0 : _f.validDomain) ||
                ((_g = envInfo.state[constants_4.ComponentNames.TeamsBot]) === null || _g === void 0 ? void 0 : _g.domain);
            if (botId) {
                if (!botDomain && !ignoreEnvStateValueMissing) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", "validDomain"), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
                else if (botDomain) {
                    validDomains.push(botDomain);
                }
            }
            for (const domain of validDomains) {
                if (((_h = manifest.validDomains) === null || _h === void 0 ? void 0 : _h.indexOf(domain)) == -1) {
                    manifest.validDomains.push(domain);
                }
            }
        }
        return teamsfx_api_1.ok(manifest);
    }
    async getManifestV3(manifestTemplatePath, state, withEmptyCapabilities) {
        var _a, _b;
        const manifestRes = await exports.manifestUtils._readAppManifest(manifestTemplatePath);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        let manifest = manifestRes.value;
        if (withEmptyCapabilities) {
            manifest.bots = [];
            manifest.composeExtensions = [];
            manifest.configurableTabs = [];
            manifest.staticTabs = [];
            manifest.webApplicationInfo = undefined;
            manifest.validDomains = [];
        }
        const manifestTemplateString = JSON.stringify(manifest);
        // Add environment variable keys to telemetry
        const customizedKeys = common_1.getEnvironmentVariables(manifestTemplateString);
        const telemetryProps = {};
        telemetryProps[telemetry_1.TelemetryPropertyKey.customizedKeys] = JSON.stringify(customizedKeys);
        const resolvedManifestString = common_1.expandEnvironmentVariable(manifestTemplateString);
        const isLocalDebug = state.ENV_NAME === "local";
        const tokens = common_1.getEnvironmentVariables(resolvedManifestString).filter((x) => x != "TEAMS_APP_ID");
        if (tokens.length > 0) {
            if (isLocalDebug) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(","))))));
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(",")), false), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        manifest = JSON.parse(resolvedManifestString);
        if (!isUUID_1.default(manifest.id)) {
            manifest.id = uuid_1.v4();
        }
        // dynamically set validDomains for manifest, which can be refactored by static manifest templates
        if (isLocalDebug || ((_a = manifest.validDomains) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            const validDomains = [];
            const tabEndpoint = state.TAB_ENDPOINT;
            const tabDomain = state.TAB_DOMAIN;
            const botDomain = state.BOT_DOMAIN;
            if (tabDomain) {
                validDomains.push(tabDomain);
            }
            if (tabEndpoint && isLocalDebug) {
                validDomains.push(tabEndpoint.slice(8));
            }
            if (botDomain) {
                validDomains.push(botDomain);
            }
            for (const domain of validDomains) {
                if (((_b = manifest.validDomains) === null || _b === void 0 ? void 0 : _b.indexOf(domain)) == -1) {
                    manifest.validDomains.push(domain);
                }
            }
        }
        return teamsfx_api_1.ok(manifest);
    }
    async isExistingTab(inputs, context) {
        const manifestTemplateRes = await this.readAppManifest(inputs.projectPath);
        if (manifestTemplateRes.isErr())
            return teamsfx_api_1.err(manifestTemplateRes.error);
        const manifest = manifestTemplateRes.value;
        const hasTabInProjectSettings = projectSettingsHelperV3_1.hasTab(context.projectSetting);
        const hasExistingTabInManifest = manifest.staticTabs !== undefined &&
            manifest.staticTabs.filter((tab) => tab.contentUrl && !tab.contentUrl.includes("{{state."))
                .length > 0;
        return teamsfx_api_1.ok(hasExistingTabInManifest && !hasTabInProjectSettings);
    }
}
exports.ManifestUtils = ManifestUtils;
function resolveManifestTemplate(envInfo, templateString, keepEnvStatePlaceHoldersIfValuesNotExist = true) {
    var _a;
    const view = {
        config: lodash_1.cloneDeep(envInfo.config),
        state: lodash_1.cloneDeep(envInfo.state),
    };
    if (keepEnvStatePlaceHoldersIfValuesNotExist) {
        const spans = mustache_1.default.parse(templateString);
        for (const span of spans) {
            if (span[0] !== "text") {
                const placeholder = span[1];
                const array = placeholder.split(".");
                if (array.length === 3 && array[0] === "state") {
                    const component = array[1];
                    const configKey = array[2];
                    if (((_a = view.state[component]) === null || _a === void 0 ? void 0 : _a[configKey]) == undefined) {
                        view.state[component] = view.state[component] || {};
                        view.state[component][configKey] = `{{${placeholder}}}`;
                    }
                }
            }
        }
    }
    const result = tools_1.compileHandlebarsTemplateString(templateString, view);
    return result;
}
exports.resolveManifestTemplate = resolveManifestTemplate;
async function getManifestTemplatePath(projectRoot) {
    const appDir = await tools_1.getAppDirectory(projectRoot);
    return `${appDir}/${constants_1.MANIFEST_TEMPLATE_CONSOLIDATE}`;
}
exports.getManifestTemplatePath = getManifestTemplatePath;
exports.manifestUtils = new ManifestUtils();
//# sourceMappingURL=ManifestUtils.js.map