"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAppPackage = exports.updateTeamsAppV3ForPublish = exports.updateManifestV3 = exports.updateManifest = exports.validateManifest = exports.buildTeamsAppPackage = exports.publishTeamsApp = exports.updateTeamsApp = exports.checkIfAppInDifferentAcountSameTenant = exports.createTeamsApp = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const uuid_1 = require("uuid");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const util = tslib_1.__importStar(require("util"));
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const typedi_1 = require("typedi");
const tools_1 = require("../../../common/tools");
const constants_1 = require("../../../common/constants");
const appStudioClient_1 = require("./appStudioClient");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_2 = require("../../constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const environment_1 = require("../../../core/environment");
const constants_3 = require("./constants");
const configure_1 = require("../../driver/teamsApp/configure");
const envUtil_1 = require("../../utils/envUtil");
const path_1 = require("path");
const set_1 = tslib_1.__importDefault(require("lodash/set"));
const question_1 = require("../../../core/question");
const createAppPackage_1 = require("../../driver/teamsApp/createAppPackage");
const configure_2 = require("../../driver/teamsApp/configure");
/**
 * Create Teams app if not exists
 * @param ctx
 * @param inputs
 * @param envInfo
 * @param tokenProvider
 * @returns Teams app id
 */
async function createTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    var _a;
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    let teamsAppId;
    let archivedFile;
    let create = true;
    if (inputs.appPackagePath) {
        if (!(await fs_extra_1.default.pathExists(inputs.appPackagePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
        archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_3.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_3.Constants.MANIFEST_FILE)));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        teamsAppId = manifest.id;
        if (teamsAppId) {
            try {
                await appStudioClient_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
                create = false;
            }
            catch (error) { }
        }
    }
    else {
        // Corner case: users under same tenant cannot import app with same Teams app id
        // Generate a new Teams app id for local debug to avoid conflict
        teamsAppId = (_a = envInfo.state[constants_2.ComponentNames.AppManifest]) === null || _a === void 0 ? void 0 : _a.teamsAppId;
        if (teamsAppId) {
            try {
                await appStudioClient_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
                create = false;
            }
            catch (error) {
                if (envInfo.envName === environment_1.environmentManager.getLocalEnvName() &&
                    error.message &&
                    error.message.includes("404")) {
                    const exists = await appStudioClient_1.AppStudioClient.checkExistsInTenant(teamsAppId, appStudioToken, ctx.logProvider);
                    if (exists) {
                        envInfo.state[constants_2.ComponentNames.AppManifest].teamsAppId = uuid_1.v4();
                    }
                }
            }
        }
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo, true);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    if (create) {
        try {
            const appDefinition = await appStudioClient_1.AppStudioClient.importApp(archivedFile, appStudioTokenRes.value, ctx.logProvider);
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppCreatedNotice", appDefinition.teamsAppId));
            return teamsfx_api_1.ok(appDefinition.teamsAppId);
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                return teamsfx_api_1.err(e);
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
            }
        }
    }
    else {
        return teamsfx_api_1.ok(teamsAppId);
    }
}
exports.createTeamsApp = createTeamsApp;
async function checkIfAppInDifferentAcountSameTenant(teamsAppId, tokenProvider, logger) {
    const appStudioTokenRes = await tokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        await appStudioClient_1.AppStudioClient.getApp(teamsAppId, appStudioToken, logger);
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            const exists = await appStudioClient_1.AppStudioClient.checkExistsInTenant(teamsAppId, appStudioToken, logger);
            return teamsfx_api_1.ok(exists);
        }
    }
    return teamsfx_api_1.ok(false);
}
exports.checkIfAppInDifferentAcountSameTenant = checkIfAppInDifferentAcountSameTenant;
/**
 * Update Teams app
 * @param ctx
 * @param inputs
 * @param envInfo
 * @param tokenProvider
 * @returns
 */
async function updateTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    let archivedFile;
    if (inputs.appPackagePath) {
        if (!(await fs_extra_1.default.pathExists(inputs.appPackagePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
        archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
    }
    else {
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    try {
        const appDefinition = await appStudioClient_1.AppStudioClient.importApp(archivedFile, appStudioToken, ctx.logProvider, true);
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", appDefinition.teamsAppId));
        return teamsfx_api_1.ok(appDefinition.teamsAppId);
    }
    catch (e) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
    }
}
exports.updateTeamsApp = updateTeamsApp;
async function publishTeamsApp(ctx, inputs, envInfo, tokenProvider, telemetryProps) {
    var _a;
    let archivedFile;
    // User provided zip file
    if (inputs.appPackagePath) {
        if (await fs_extra_1.default.pathExists(inputs.appPackagePath)) {
            archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
    }
    else {
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo, false, telemetryProps);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_3.Constants.MANIFEST_FILE);
    if (!manifestFile) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_3.Constants.MANIFEST_FILE)));
    }
    const manifestString = manifestFile.getData().toString();
    const manifest = JSON.parse(manifestString);
    // manifest.id === externalID
    const appStudioTokenRes = await tokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const existApp = await appStudioClient_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioTokenRes.value);
    if (existApp) {
        let executePublishUpdate = false;
        let description = localizeUtils_1.getLocalizedString("plugins.appstudio.pubWarn", existApp.displayName, existApp.publishingState);
        if (existApp.lastModifiedDateTime) {
            description =
                description +
                    localizeUtils_1.getLocalizedString("plugins.appstudio.lastModified", (_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString());
        }
        description = description + localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublihsedAppConfirm");
        const confirm = localizeUtils_1.getLocalizedString("core.option.confirm");
        const res = await ctx.userInteraction.showMessage("warn", description, true, confirm);
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === confirm)
            executePublishUpdate = true;
        if (executePublishUpdate) {
            const appId = await appStudioClient_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioTokenRes.value);
            return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: true });
        }
        else {
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        }
    }
    else {
        const appId = await appStudioClient_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioTokenRes.value);
        return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: false });
    }
}
exports.publishTeamsApp = publishTeamsApp;
/**
 * Build appPackage.{envName}.zip
 * @returns Path for built Teams app package
 */
async function buildTeamsAppPackage(projectSettings, projectPath, envInfo, withEmptyCapabilities = false, telemetryProps) {
    const buildFolderPath = path.join(projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName);
    await fs_extra_1.default.ensureDir(buildFolderPath);
    const manifestRes = await ManifestUtils_1.manifestUtils.getManifest(projectPath, envInfo, withEmptyCapabilities, telemetryProps);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const manifest = manifestRes.value;
    if (!isUUID_1.default(manifest.id)) {
        manifest.id = uuid_1.v4();
    }
    if (withEmptyCapabilities) {
        manifest.bots = [];
        manifest.composeExtensions = [];
        manifest.configurableTabs = [];
        manifest.staticTabs = [];
        manifest.webApplicationInfo = undefined;
    }
    const appDirectory = await tools_1.getAppDirectory(projectPath);
    const colorFile = path.join(appDirectory, manifest.icons.color);
    if (!(await fs_extra_1.default.pathExists(colorFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile)));
    }
    const outlineFile = path.join(appDirectory, manifest.icons.outline);
    if (!(await fs_extra_1.default.pathExists(outlineFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile)));
    }
    const zip = new adm_zip_1.default();
    zip.addFile(constants_3.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
    // outline.png & color.png, relative path
    let dir = path.dirname(manifest.icons.color);
    zip.addLocalFile(colorFile, dir === "." ? "" : dir);
    dir = path.dirname(manifest.icons.outline);
    zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
    // localization file
    if (manifest.localizationInfo &&
        manifest.localizationInfo.additionalLanguages &&
        manifest.localizationInfo.additionalLanguages.length > 0) {
        await Promise.all(manifest.localizationInfo.additionalLanguages.map(async function (language) {
            const file = language.file;
            const fileName = `${appDirectory}/${file}`;
            if (!(await fs_extra_1.default.pathExists(fileName))) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
            }
            const dir = path.dirname(file);
            zip.addLocalFile(fileName, dir === "." ? "" : dir);
        }));
    }
    const zipFileName = path.join(buildFolderPath, `appPackage.${envInfo.envName}.zip`);
    zip.writeZip(zipFileName);
    const manifestFileName = path.join(buildFolderPath, `manifest.${envInfo.envName}.json`);
    if (await fs_extra_1.default.pathExists(manifestFileName)) {
        await fs_extra_1.default.chmod(manifestFileName, 0o777);
    }
    await fs_extra_1.default.writeFile(manifestFileName, JSON.stringify(manifest, null, 4));
    await fs_extra_1.default.chmod(manifestFileName, 0o444);
    if (tools_1.isSPFxProject(projectSettings)) {
        const spfxTeamsPath = `${projectPath}/SPFx/teams`;
        await fs_extra_1.default.copyFile(zipFileName, path.join(spfxTeamsPath, "TeamsSPFxApp.zip"));
        for (const file of await fs_extra_1.default.readdir(`${projectPath}/SPFx/teams/`)) {
            if (file.endsWith("color.png") &&
                manifest.icons.color &&
                !manifest.icons.color.startsWith("https://")) {
                const colorFile = `${appDirectory}/${manifest.icons.color}`;
                const color = await fs_extra_1.default.readFile(colorFile);
                await fs_extra_1.default.writeFile(path.join(spfxTeamsPath, file), color);
            }
            else if (file.endsWith("outline.png") &&
                manifest.icons.outline &&
                !manifest.icons.outline.startsWith("https://")) {
                const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
                const outline = await fs_extra_1.default.readFile(outlineFile);
                await fs_extra_1.default.writeFile(path.join(spfxTeamsPath, file), outline);
            }
        }
    }
    return teamsfx_api_1.ok(zipFileName);
}
exports.buildTeamsAppPackage = buildTeamsAppPackage;
/**
 * Validate manifest
 * @returns an array of validation error strings
 */
async function validateManifest(manifest) {
    // Corner case: SPFx project validate without provision
    if (!isUUID_1.default(manifest.id)) {
        manifest.id = uuid_1.v4();
    }
    if (manifest.$schema) {
        try {
            const result = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
            return teamsfx_api_1.ok(result);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
            ]), constants_1.HelpLinks.WhyNeedProvision));
        }
    }
    else {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
            localizeUtils_1.getLocalizedString("error.appstudio.validateSchemaNotDefined"),
        ]), constants_1.HelpLinks.WhyNeedProvision));
    }
}
exports.validateManifest = validateManifest;
async function updateManifest(ctx, inputs) {
    var _a, _b, _c, _d, _e;
    const teamsAppId = (_a = ctx.envInfo.state[constants_2.ComponentNames.AppManifest]) === null || _a === void 0 ? void 0 : _a.teamsAppId;
    let manifest;
    const manifestResult = await ManifestUtils_1.manifestUtils.getManifest(inputs.projectPath, ctx.envInfo, false);
    if (manifestResult.isErr()) {
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"));
        const isProvisionSucceeded = ctx.envInfo.state["solution"].provisionSucceeded;
        if (manifestResult.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
            !isProvisionSucceeded) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"), isProvisionSucceeded), constants_1.HelpLinks.WhyNeedProvision));
        }
        else {
            return teamsfx_api_1.err(manifestResult.error);
        }
    }
    else {
        manifest = manifestResult.value;
    }
    const manifestFileName = await ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath);
    if (!(await fs_extra_1.default.pathExists(manifestFileName))) {
        const isProvisionSucceeded = ctx.envInfo.state["solution"].provisionSucceeded;
        if (!isProvisionSucceeded) {
            const msgs = errors_1.AppStudioError.FileNotFoundError.message(manifestFileName);
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, [
                msgs[0] + localizeUtils_1.getDefaultString("plugins.appstudio.provisionTip"),
                msgs[1] + localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTip"),
            ], constants_1.HelpLinks.WhyNeedProvision));
        }
        await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
    }
    const existingManifest = await fs_extra_1.default.readJSON(manifestFileName);
    delete manifest.id;
    delete existingManifest.id;
    if (!lodash_1.default.isEqual(manifest, existingManifest)) {
        const previewOnly = localizeUtils_1.getLocalizedString("plugins.appstudio.previewOnly");
        const previewUpdate = localizeUtils_1.getLocalizedString("plugins.appstudio.previewAndUpdate");
        const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateManifestTip"), true, previewOnly, previewUpdate);
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewOnly) {
            return await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
        }
        else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewUpdate) {
            buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
        }
        else {
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        }
    }
    const appStudioTokenRes = await ctx.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        const localUpdateTime = ctx.envInfo.state[constants_2.ComponentNames.AppManifest]
            .teamsAppUpdatedAt;
        if (localUpdateTime) {
            const app = await appStudioClient_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            const devPortalUpdateTime = (_d = (_c = new Date(app.updatedAt)) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : -1;
            if (localUpdateTime < devPortalUpdateTime) {
                const option = localizeUtils_1.getLocalizedString("plugins.appstudio.overwriteAndUpdate");
                const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateOverwriteTip"), true, option);
                if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === option)) {
                    return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
                }
            }
        }
        const result = await updateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", teamsAppId));
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: tools_1.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        ctx.userInteraction
            .showMessage("info", localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedNotice"), false, localizeUtils_1.getLocalizedString("plugins.appstudio.viewDeveloperPortal"))
            .then((res) => {
            if ((res === null || res === void 0 ? void 0 : res.isOk()) &&
                res.value === localizeUtils_1.getLocalizedString("plugins.appstudio.viewDeveloperPortal")) {
                ctx.userInteraction.openUrl(util.format(constants_3.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, result.value, loginHint));
            }
        });
        return teamsfx_api_1.ok(teamsAppId);
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
        }
        else {
            return teamsfx_api_1.err(error);
        }
    }
}
exports.updateManifest = updateManifest;
async function updateManifestV3(ctx, inputs) {
    var _a, _b, _c, _d, _e;
    const state = {
        TAB_ENDPOINT: process.env.TAB_ENDPOINT,
        TAB_DOMAIN: process.env.TAB_DOMAIN,
        BOT_ID: process.env.BOT_ID,
        BOT_DOMAIN: process.env.BOT_DOMAIN,
        ENV_NAME: process.env.TEAMSFX_ENV,
    };
    const teamsAppId = process.env.TEAMS_APP_ID;
    const manifestTemplatePath = (_a = inputs.manifestTemplatePath) !== null && _a !== void 0 ? _a : (await ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath));
    const manifestFileName = path.join(inputs.projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, `manifest.${state.ENV_NAME}.json`);
    // Prepare for driver
    const buildDriver = typedi_1.Container.get(createAppPackage_1.actionName);
    const createAppPackageArgs = generateCreateAppPackageArgs(inputs.projectPath, manifestTemplatePath, state.ENV_NAME);
    const updateTeamsAppArgs = {
        appPackagePath: createAppPackageArgs.outputZipPath,
    };
    const driverContext = generateDriverContext(ctx, inputs);
    await envUtil_1.envUtil.readEnv(inputs.projectPath, state.ENV_NAME);
    // render manifest
    let manifest;
    const manifestResult = await ManifestUtils_1.manifestUtils.getManifestV3(manifestTemplatePath, state, false);
    if (manifestResult.isErr()) {
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"));
        if (manifestResult.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"), false), constants_1.HelpLinks.WhyNeedProvision));
        }
        else {
            return teamsfx_api_1.err(manifestResult.error);
        }
    }
    else {
        manifest = manifestResult.value;
    }
    // read built manifest file
    if (!(await fs_extra_1.default.pathExists(manifestFileName))) {
        const res = await buildDriver.run(createAppPackageArgs, driverContext);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
    }
    const existingManifest = await fs_extra_1.default.readJSON(manifestFileName);
    delete manifest.id;
    delete existingManifest.id;
    if (!lodash_1.default.isEqual(manifest, existingManifest)) {
        const previewOnly = localizeUtils_1.getLocalizedString("plugins.appstudio.previewOnly");
        const previewUpdate = localizeUtils_1.getLocalizedString("plugins.appstudio.previewAndUpdate");
        const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateManifestTip"), true, previewUpdate, previewOnly);
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewOnly) {
            return await buildDriver.run(createAppPackageArgs, driverContext);
        }
        else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewUpdate) {
            await buildDriver.run(createAppPackageArgs, driverContext);
        }
        else {
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        }
    }
    const appStudioTokenRes = await ctx.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        const localUpdateTime = process.env.TEAMS_APP_UPDATE_TIME;
        if (localUpdateTime) {
            const app = await appStudioClient_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            const devPortalUpdateTime = (_d = (_c = new Date(app.updatedAt)) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : -1;
            if (new Date(localUpdateTime).getTime() < devPortalUpdateTime) {
                const option = localizeUtils_1.getLocalizedString("plugins.appstudio.overwriteAndUpdate");
                const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateOverwriteTip"), true, option);
                if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === option)) {
                    return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
                }
            }
        }
        const configureDriver = typedi_1.Container.get(configure_2.actionName);
        const result = await configureDriver.run(updateTeamsAppArgs, driverContext);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", teamsAppId));
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: tools_1.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        const url = util.format(constants_3.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, result.value.get("TEAMS_APP_ID"), loginHint);
        if (inputs.platform === teamsfx_api_1.Platform.CLI) {
            const message = [
                {
                    content: localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedCLINotice"),
                    color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                },
                { content: url, color: teamsfx_api_1.Colors.BRIGHT_CYAN },
            ];
            ctx.userInteraction.showMessage("info", message, false);
        }
        else {
            ctx.userInteraction
                .showMessage("info", localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedNotice"), false, localizeUtils_1.getLocalizedString("plugins.appstudio.viewDeveloperPortal"))
                .then((res) => {
                if ((res === null || res === void 0 ? void 0 : res.isOk()) &&
                    res.value === localizeUtils_1.getLocalizedString("plugins.appstudio.viewDeveloperPortal")) {
                    ctx.userInteraction.openUrl(url);
                }
            });
        }
        return result;
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
        }
        else {
            return teamsfx_api_1.err(error);
        }
    }
}
exports.updateManifestV3 = updateManifestV3;
async function updateTeamsAppV3ForPublish(ctx, inputs) {
    var _a;
    const driverContext = generateDriverContext(ctx, inputs);
    const updateTeamsAppArgs = {
        appPackagePath: inputs[question_1.CoreQuestionNames.AppPackagePath],
    };
    const zipEntries = new adm_zip_1.default(updateTeamsAppArgs.appPackagePath).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_3.Constants.MANIFEST_FILE);
    let validationError;
    if (manifestFile) {
        try {
            const manifestString = manifestFile.getData().toString();
            const manifest = JSON.parse(manifestString);
            if (!manifest.id || !isUUID_1.default(manifest.id)) {
                validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    localizeUtils_1.getLocalizedString("error.appstudio.noManifestId"),
                ]));
            }
            else {
                const validationResult = await validateManifest(manifest);
                if (validationResult.isErr()) {
                    validationError = validationResult.error;
                }
                else {
                    if (validationResult.value.length > 0) {
                        const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
                        validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
                    }
                }
            }
        }
        catch (e) {
            validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([e.message]));
            validationError.stack = e.stack;
        }
    }
    else {
        // missing manifest file
        validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
            localizeUtils_1.getLocalizedString("error.appstudio.noManifestError"),
        ]));
    }
    if (validationError) {
        const suggestionDefaultMessage = localizeUtils_1.getDefaultString("error.appstudio.publishInDevPortalSuggestionForValidationError");
        const suggestionMessage = localizeUtils_1.getLocalizedString("error.appstudio.publishInDevPortalSuggestionForValidationError");
        validationError.message += ` ${suggestionDefaultMessage}`;
        validationError.displayMessage += ` ${suggestionMessage}`;
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("plugins.appstudio.validationFailedNotice"));
        return teamsfx_api_1.err(validationError);
    }
    const configureDriver = typedi_1.Container.get(configure_2.actionName);
    const result = await configureDriver.run(updateTeamsAppArgs, driverContext);
    if (result.isErr()) {
        return teamsfx_api_1.err(result.error);
    }
    return teamsfx_api_1.ok(result.value.get(configure_1.outputNames.TEAMS_APP_ID));
}
exports.updateTeamsAppV3ForPublish = updateTeamsAppV3ForPublish;
async function getAppPackage(teamsAppId, m365TokenProvider, logProvider) {
    const appStudioTokenRes = await m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    try {
        const data = await appStudioClient_1.AppStudioClient.getAppPackage(teamsAppId, appStudioTokenRes.value, logProvider);
        const appPackage = {};
        const buffer = Buffer.from(data, "base64");
        const zip = new adm_zip_1.default(buffer);
        const zipEntries = zip.getEntries(); // an array of ZipEntry records
        zipEntries === null || zipEntries === void 0 ? void 0 : zipEntries.forEach(async function (zipEntry) {
            const data = zipEntry.getData();
            const name = zipEntry.entryName.toLowerCase();
            switch (name) {
                case "manifest.json":
                    appPackage.manifest = data;
                    break;
                case "color.png":
                    appPackage.icons = Object.assign(Object.assign({}, appPackage.icons), { color: data });
                    break;
                case "outline.png":
                    appPackage.icons = Object.assign(Object.assign({}, appPackage.icons), { outline: data });
                    break;
                default:
                    const ext = path_1.extname(name);
                    const base = path_1.basename(name, ext);
                    // Since we don't support scene features, the remaining files are json files for language.
                    if (constants_3.supportedLanguageCodes.findIndex((code) => code === base) > -1) {
                        set_1.default(appPackage, ["languages", base], data);
                    }
                    else {
                        logProvider === null || logProvider === void 0 ? void 0 : logProvider.warning(localizeUtils_1.getLocalizedString("plugins.appstudio.unprocessedFile", name));
                    }
            }
        });
        return teamsfx_api_1.ok(appPackage);
    }
    catch (e) {
        return teamsfx_api_1.err(e);
    }
}
exports.getAppPackage = getAppPackage;
function generateDriverContext(ctx, inputs) {
    return {
        azureAccountProvider: ctx.tokenProvider.azureAccountProvider,
        m365TokenProvider: ctx.tokenProvider.m365TokenProvider,
        ui: ctx.userInteraction,
        logProvider: ctx.logProvider,
        telemetryReporter: ctx.telemetryReporter,
        projectPath: ctx.projectPath,
        platform: inputs.platform,
    };
}
function generateCreateAppPackageArgs(projectPath, manifestTemplatePath, envName) {
    const manifestFileName = path.join(projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, `manifest.${envName}.json`);
    return {
        manifestPath: manifestTemplatePath,
        outputZipPath: path.join(projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, `appPackage.${envName}.zip`),
        outputJsonPath: manifestFileName,
    };
}
//# sourceMappingURL=appStudio.js.map