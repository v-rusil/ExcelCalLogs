"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishQuestion = exports.AppManifest = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const url_1 = require("url");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
const tools_1 = require("../../../common/tools");
const utils_1 = require("../../../common/utils");
const globalVars_1 = require("../../../core/globalVars");
const folder_1 = require("../../../folder");
const appStudioClient_1 = require("./appStudioClient");
const constants_2 = require("./constants");
const errors_1 = require("./errors");
const questions_1 = require("./questions");
const results_1 = require("./results");
const telemetry_1 = require("./utils/telemetry");
const constants_3 = require("../../constants");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const appStudio_1 = require("./appStudio");
const constants_4 = require("./constants");
const ManifestUtils_1 = require("./utils/ManifestUtils");
let AppManifest = class AppManifest {
    constructor() {
        this.name = "app-manifest";
        this.outputs = {
            teamsAppId: {
                key: "teamsAppId",
            },
            tenantId: {
                key: "tenantId",
            },
        };
        this.finalOutputKeys = ["teamsAppId", "tenantId"];
    }
    async init(context, inputs, existingApp = false) {
        let manifest;
        const sourceTemplatesFolder = folder_1.getTemplatesFolder();
        if (inputs.capabilities === "TabSPFx") {
            const templateManifestFolder = path.join(sourceTemplatesFolder, "plugins", "resource", "spfx");
            const manifestFile = path.resolve(templateManifestFolder, "./solution/manifest_multi_env.json");
            const manifestString = (await fs_extra_1.default.readFile(manifestFile)).toString();
            manifest = JSON.parse(manifestString);
        }
        else {
            const manifestString = constants_4.TEAMS_APP_MANIFEST_TEMPLATE;
            manifest = JSON.parse(manifestString);
            if (existingApp || !projectSettingsHelperV3_1.hasTab(context.projectSetting)) {
                manifest.developer = constants_2.DEFAULT_DEVELOPER;
            }
        }
        const targetTemplateFolder = await utils_1.getProjectTemplatesFolderPath(inputs.projectPath);
        await fs_extra_1.default.ensureDir(targetTemplateFolder);
        const appPackageFolder = path.join(targetTemplateFolder, "appPackage");
        await fs_extra_1.default.ensureDir(appPackageFolder);
        const resourcesFolder = path.resolve(appPackageFolder, "resources");
        await fs_extra_1.default.ensureDir(resourcesFolder);
        const targetManifestPath = path.join(appPackageFolder, "manifest.template.json");
        await fs_extra_1.default.writeFile(targetManifestPath, JSON.stringify(manifest, null, 4));
        const defaultColorPath = path.join(sourceTemplatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path.join(sourceTemplatesFolder, constants_2.OUTLINE_TEMPLATE);
        await fs_extra_1.default.copy(defaultColorPath, path.join(resourcesFolder, constants_2.DEFAULT_COLOR_PNG_FILENAME));
        await fs_extra_1.default.copy(defaultOutlinePath, path.join(resourcesFolder, constants_2.DEFAULT_OUTLINE_PNG_FILENAME));
        return teamsfx_api_1.ok(undefined);
    }
    async addCapability(inputs, capabilities, isM365 = false) {
        return ManifestUtils_1.manifestUtils.addCapabilities(inputs, capabilities, isM365);
    }
    async updateCapability(inputs, capability) {
        return ManifestUtils_1.manifestUtils.updateCapability(inputs.projectPath, capability);
    }
    async deleteCapability(inputs, capability) {
        return ManifestUtils_1.manifestUtils.deleteCapability(inputs.projectPath, capability);
    }
    async capabilityExceedLimit(inputs, capability) {
        return ManifestUtils_1.manifestUtils.capabilityExceedLimit(inputs.projectPath, capability);
    }
    async provision(ctx, inputs, actionContext) {
        var _a;
        telemetry_1.TelemetryUtils.init(ctx);
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionProgress", ctx.projectSetting.appName)));
        const res = await appStudio_1.createTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        ctx.envInfo.state[constants_3.ComponentNames.AppManifest].teamsAppId = res.value;
        globalVars_1.globalVars.teamsAppId = res.value;
        return teamsfx_api_1.ok(undefined);
    }
    async provisionForCLI(ctx, inputs, envInfo, tokenProvider, actionContext) {
        var _a;
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionProgress", ctx.projectSetting.appName)));
        const res = await appStudio_1.createTeamsApp(ctx, inputs, envInfo, tokenProvider);
        return res;
    }
    async configure(ctx, inputs, actionContext) {
        var _a;
        telemetry_1.TelemetryUtils.init(ctx);
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(localizeUtils_1.getLocalizedString("plugins.appstudio.postProvisionProgress", ctx.projectSetting.appName)));
        const res = await appStudio_1.updateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
    async publish(ctx, inputs, actionCtx) {
        telemetry_1.TelemetryUtils.init(ctx);
        if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
            inputs[constants_2.Constants.BUILD_OR_PUBLISH_QUESTION] === questions_1.manuallySubmitOption().id) {
            if (actionCtx === null || actionCtx === void 0 ? void 0 : actionCtx.telemetryProps)
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.manual] = String(true);
            try {
                const appPackagePath = await appStudio_1.buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo, false, actionCtx.telemetryProps);
                if (appPackagePath.isErr())
                    return teamsfx_api_1.err(appPackagePath.error);
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.adminApprovalTip", ctx.projectSetting.appName, appPackagePath.value);
                ctx.userInteraction
                    .showMessage("info", msg, false, "OK", localizeUtils_1.getLocalizedString("core.Notification.ReadMore"))
                    .then((value) => {
                    if (value.isOk() && value.value === localizeUtils_1.getLocalizedString("core.Notification.ReadMore")) {
                        ctx.userInteraction.openUrl(constants_2.Constants.PUBLISH_GUIDE);
                    }
                });
                return teamsfx_api_1.ok(undefined);
            }
            catch (error) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsPackageBuildError.name, errors_1.AppStudioError.TeamsPackageBuildError.message(error), error.helpLink));
            }
        }
        try {
            const res = await appStudio_1.publishTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider.m365TokenProvider);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            ctx.logProvider.info(`Publish success!`);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice.cli", res.value.appName, constants_2.Constants.TEAMS_ADMIN_PORTAL, constants_2.Constants.TEAMS_MANAGE_APP_DOC);
                ctx.userInteraction.showMessage("info", msg, false);
            }
            else {
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice", res.value.appName, constants_2.Constants.TEAMS_MANAGE_APP_DOC);
                const adminPortal = localizeUtils_1.getLocalizedString("plugins.appstudio.adminPortal");
                ctx.userInteraction.showMessage("info", msg, false, adminPortal).then((value) => {
                    if (value.isOk() && value.value === adminPortal) {
                        ctx.userInteraction.openUrl(constants_2.Constants.TEAMS_ADMIN_PORTAL);
                    }
                });
            }
            if (actionCtx === null || actionCtx === void 0 ? void 0 : actionCtx.telemetryProps) {
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.updateExistingApp] = String(res.value.update);
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.publishedAppId] = String(res.value.publishedAppId);
            }
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.SystemError || error instanceof teamsfx_api_1.UserError) {
                throw error;
            }
            else {
                const publishFailed = new teamsfx_api_1.SystemError({
                    name: errors_1.AppStudioError.TeamsAppPublishFailedError.name,
                    message: error.message,
                    source: constants_2.Constants.PLUGIN_NAME,
                    error: error,
                });
                return teamsfx_api_1.err(publishFailed);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async validate(context, inputs) {
        var _a;
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifest(inputs.projectPath, context.envInfo, false);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        const validationResult = await appStudio_1.validateManifest(manifest);
        if (validationResult.isErr()) {
            return teamsfx_api_1.err(validationResult.error);
        }
        if (validationResult.value.length > 0) {
            const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("plugins.appstudio.validationFailedNotice"));
            const validationFailed = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
            return teamsfx_api_1.err(validationFailed);
        }
        const validationSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.validationSucceedNotice");
        context.userInteraction.showMessage("info", validationSuccess, false);
        return validationResult;
    }
    async build(context, inputs) {
        var _a;
        const res = await appStudio_1.buildTeamsAppPackage(context.projectSetting, inputs.projectPath, context.envInfo);
        if (res.isOk()) {
            if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                const builtSuccess = [
                    { content: "(√)Done: ", color: teamsfx_api_1.Colors.BRIGHT_GREEN },
                    { content: "Teams Package ", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                    { content: res.value, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                    { content: " built successfully!", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                ];
                if (inputs.platform === teamsfx_api_1.Platform.VS) {
                    (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(builtSuccess);
                }
                else {
                    context.userInteraction.showMessage("info", builtSuccess, false);
                }
            }
            else if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                const isWindows = process.platform === "win32";
                let builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice.fallback", res.value);
                if (isWindows) {
                    const folderLink = url_1.pathToFileURL(path.dirname(res.value));
                    const appPackageLink = `${constants_1.VSCodeExtensionCommand.openFolder}?%5B%22${folderLink}%22%5D`;
                    builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice", appPackageLink);
                }
                context.userInteraction.showMessage("info", builtSuccess, false);
            }
        }
        return res;
    }
    async deploy(context, inputs) {
        telemetry_1.TelemetryUtils.init(context);
        return await appStudio_1.updateManifest(context, inputs);
    }
    async deployV3(context, inputs) {
        telemetry_1.TelemetryUtils.init(context);
        return await appStudio_1.updateManifestV3(context, inputs);
    }
    /**
     * Check if manifest templates already exist.
     */
    async preCheck(projectPath) {
        const existFiles = new Array();
        for (const templates of ["Templates", "templates"]) {
            const appPackageDir = path.join(projectPath, templates, "appPackage");
            const manifestPath = path.resolve(appPackageDir, "manifest.template.json");
            if (await fs_extra_1.default.pathExists(manifestPath)) {
                existFiles.push(manifestPath);
            }
            const resourcesDir = path.resolve(appPackageDir, constants_2.MANIFEST_RESOURCES);
            const defaultColorPath = path.join(resourcesDir, constants_2.DEFAULT_COLOR_PNG_FILENAME);
            if (await fs_extra_1.default.pathExists(defaultColorPath)) {
                existFiles.push(defaultColorPath);
            }
            const defaultOutlinePath = path.join(resourcesDir, constants_2.DEFAULT_OUTLINE_PNG_FILENAME);
            if (await fs_extra_1.default.pathExists(defaultOutlinePath)) {
                existFiles.push(defaultOutlinePath);
            }
        }
        return existFiles;
    }
    async getTeamsAppId(ctx, inputs, envInfo) {
        let teamsAppId = "";
        // User may manually update id in manifest template file, rather than configuration file
        // The id in manifest template file should override configurations
        const manifestResult = await ManifestUtils_1.manifestUtils.getManifest(inputs.projectPath, envInfo, false);
        if (manifestResult.isOk()) {
            teamsAppId = manifestResult.value.id;
        }
        if (!isUUID_1.default(teamsAppId)) {
            teamsAppId = envInfo.state[constants_3.ComponentNames.AppManifest].teamsAppId;
        }
        return teamsAppId;
    }
    async listCollaborator(ctx, inputs, envInfo, m365TokenProvider, teamsAppIdV3) {
        telemetry_1.TelemetryUtils.init(ctx);
        try {
            const teamsAppId = tools_1.isV3Enabled()
                ? teamsAppIdV3
                : await this.getTeamsAppId(ctx, inputs, envInfo);
            if (!teamsAppId) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, "GetConfigError", constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name)));
            }
            const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            let userLists;
            try {
                userLists = await appStudioClient_1.AppStudioClient.getUserList(teamsAppId, appStudioToken);
                if (!userLists) {
                    return teamsfx_api_1.ok([]);
                }
            }
            catch (error) {
                if (error.name === 404) {
                    error.message = constants_2.ErrorMessages.TeamsAppNotFound(teamsAppId);
                }
                throw error;
            }
            const teamsAppAdmin = userLists
                .filter((userList) => {
                return userList.isAdministrator;
            })
                .map((userList) => {
                return {
                    userObjectId: userList.aadId,
                    displayName: userList.displayName,
                    userPrincipalName: userList.userPrincipalName,
                    resourceId: teamsAppId,
                };
            });
            return teamsfx_api_1.ok(teamsAppAdmin);
        }
        catch (error) {
            const fxError = error.name && error.name >= 400 && error.name < 500
                ? results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ListCollaboratorFailedError.name, errors_1.AppStudioError.ListCollaboratorFailedError.message(error))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ListCollaboratorFailedError.name, errors_1.AppStudioError.ListCollaboratorFailedError.message(error));
            return teamsfx_api_1.err(fxError);
        }
    }
    async grantPermission(ctx, inputs, envInfo, m365TokenProvider, userInfo, teamsAppIdV3) {
        telemetry_1.TelemetryUtils.init(ctx);
        try {
            const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const teamsAppId = tools_1.isV3Enabled()
                ? teamsAppIdV3
                : await this.getTeamsAppId(ctx, inputs, envInfo);
            if (!teamsAppId) {
                const msgs = constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name);
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, errors_1.AppStudioError.GrantPermissionFailedError.name, msgs[0], msgs[1]));
            }
            try {
                await appStudioClient_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo);
            }
            catch (error) {
                const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(error === null || error === void 0 ? void 0 : error.message, teamsAppId);
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, errors_1.AppStudioError.GrantPermissionFailedError.name, msgs[0], msgs[1]));
            }
            const result = [
                {
                    name: constants_2.Constants.PERMISSIONS.name,
                    roles: [constants_2.Constants.PERMISSIONS.admin],
                    type: constants_2.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            const fxError = error.name && error.name >= 400 && error.name < 500
                ? results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GrantPermissionFailedError.name, errors_1.AppStudioError.GrantPermissionFailedError.message(error.message))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.GrantPermissionFailedError.name, errors_1.AppStudioError.GrantPermissionFailedError.message(error.message));
            return teamsfx_api_1.err(fxError);
        }
    }
    async checkPermission(ctx, inputs, envInfo, m365TokenProvider, userInfo, teamsAppIdV3) {
        telemetry_1.TelemetryUtils.init(ctx);
        try {
            const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const teamsAppId = tools_1.isV3Enabled()
                ? teamsAppIdV3
                : await this.getTeamsAppId(ctx, inputs, envInfo);
            if (!teamsAppId) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, "GetConfigError", constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name)));
            }
            const teamsAppRoles = await appStudioClient_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId);
            const result = [
                {
                    name: constants_2.Constants.PERMISSIONS.name,
                    roles: [teamsAppRoles],
                    type: constants_2.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return teamsfx_api_1.ok(result);
        }
        catch (error) {
            const fxError = error.name && error.name >= 400 && error.name < 500
                ? results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.CheckPermissionFailedError.name, errors_1.AppStudioError.CheckPermissionFailedError.message(error))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CheckPermissionFailedError.name, errors_1.AppStudioError.CheckPermissionFailedError.message(error));
            return teamsfx_api_1.err(fxError);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.init,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "init", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.addCapability,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Array, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "addCapability", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: "update-capability",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "updateCapability", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: "delete-capability",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "deleteCapability", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"),
            progressSteps: 1,
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.provision, // TODO
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"),
            progressSteps: 1,
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.provisionManifest,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "provisionForCLI", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"),
            progressSteps: 1,
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.localDebug,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.publish,
            question: async (context, inputs) => {
                return await publishQuestion(inputs);
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "publish", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.validateManifest,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "validate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.buildTeamsPackage,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "build", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.deploy,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "deploy", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.deploy,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "deployV3", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.listCollaborator,
            errorSource: "AppStudioPlugin",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "listCollaborator", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.grantPermission,
            errorSource: "AppStudioPlugin",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "grantPermission", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.checkPermission,
            errorSource: "AppStudioPlugin",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "checkPermission", null);
AppManifest = tslib_1.__decorate([
    typedi_1.Service("app-manifest")
], AppManifest);
exports.AppManifest = AppManifest;
async function publishQuestion(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
        const buildOrPublish = new teamsfx_api_1.QTreeNode({
            name: constants_2.Constants.BUILD_OR_PUBLISH_QUESTION,
            type: "singleSelect",
            staticOptions: [questions_1.manuallySubmitOption(), questions_1.autoPublishOption()],
            title: localizeUtils_1.getLocalizedString("plugins.appstudio.publishTip"),
            default: questions_1.autoPublishOption().id,
        });
        return teamsfx_api_1.ok(buildOrPublish);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.publishQuestion = publishQuestion;
//# sourceMappingURL=appManifest.js.map