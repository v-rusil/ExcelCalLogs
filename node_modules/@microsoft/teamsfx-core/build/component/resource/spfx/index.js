"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var SpfxResource_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpfxResource = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const error_1 = require("./error");
const constants_1 = require("./utils/constants");
const progress_helper_1 = require("./utils/progress-helper");
const utils_1 = require("./utils/utils");
const constants_2 = require("../../constants");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const spoClient_1 = require("./spoClient");
const localizeUtils_1 = require("../../../common/localizeUtils");
const axios_1 = tslib_1.__importDefault(require("axios"));
const tools_1 = require("../../../common/tools");
let SpfxResource = SpfxResource_1 = class SpfxResource {
    constructor() {
        this.name = constants_2.ComponentNames.SPFx;
        this.outputs = {};
        this.finalOutputKeys = [];
    }
    async deploy(context, inputs) {
        const buildRes = await this.buildSPPackage(context, inputs);
        if (buildRes.isErr()) {
            return teamsfx_api_1.err(buildRes.error);
        }
        const deployRes = await this._deploy(context, inputs, context.tokenProvider);
        if (deployRes.isErr()) {
            return teamsfx_api_1.err(deployRes.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async buildSPPackage(ctx, inputs) {
        var _a;
        const progressHandler = await progress_helper_1.ProgressHelper.startPreDeployProgressHandler(ctx.userInteraction);
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            ctx.logProvider.outputChannel.show();
        }
        try {
            const workspacePath = `${inputs.projectPath}/SPFx`;
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.NpmInstall));
            await utils_1.Utils.execute(`npm install`, "SPFx", workspacePath, ctx.logProvider, true);
            const gulpCommand = await SpfxResource_1.findGulpCommand(workspacePath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpBundle));
            await utils_1.Utils.execute(`${gulpCommand} bundle --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpPackage));
            await utils_1.Utils.execute(`${gulpCommand} package-solution --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
            const sharepointPackage = await this.getPackage(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(sharepointPackage))) {
                throw error_1.NoSPPackageError(sharepointPackage);
            }
            const dir = path_1.default.normalize(path_1.default.parse(sharepointPackage).dir);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                const guidance = [
                    {
                        content: "Success: SharePoint package successfully built at ",
                        color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                    },
                    { content: dir, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                ctx.userInteraction.showMessage("info", guidance, false);
            }
            else {
                const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.buildNotice", dir);
                (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("info", guidance, false, "OK");
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            await progress_helper_1.ProgressHelper.endPreDeployProgress(false);
            return teamsfx_api_1.err(error_1.BuildSPPackageError(error));
        }
    }
    async _deploy(ctx, inputs, tokenProvider) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const progressHandler = await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx.userInteraction);
        let success = false;
        try {
            const tenant = await this.getTenant(tokenProvider);
            if (tenant.isErr()) {
                return tenant;
            }
            spoClient_1.SPOClient.setBaseUrl(tenant.value);
            const spoToken = await tools_1.getSPFxToken(tokenProvider.m365TokenProvider);
            if (!spoToken) {
                return teamsfx_api_1.err(error_1.GetSPOTokenFailedError());
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            }
            else {
                const res = await ((_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.spfx.createAppCatalogNotice", tenant.value), true, "OK", constants_1.Constants.READ_MORE));
                const confirm = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
                switch (confirm) {
                    case "OK":
                        try {
                            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.CreateSPAppCatalog));
                            await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        }
                        catch (e) {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(e));
                        }
                        let retry = 0;
                        appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                        while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.warning(`No tenant app catalog found, retry: ${retry}`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                            retry += 1;
                        }
                        if (appCatalogSite) {
                            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`Sharepoint tenant app catalog ${appCatalogSite} created, wait for a few minutes to be active.`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
                        }
                        else {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(new Error("Cannot get app catalog site url after creation. You may need wait a few minutes and retry.")));
                        }
                        break;
                    case constants_1.Constants.READ_MORE:
                        (_d = ctx.userInteraction) === null || _d === void 0 ? void 0 : _d.openUrl(constants_1.Constants.CREATE_APP_CATALOG_GUIDE);
                        return teamsfx_api_1.ok(teamsfx_api_1.UserCancelError);
                    default:
                        return teamsfx_api_1.ok(undefined);
                }
            }
            const appPackage = await this.getPackage(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(appPackage))) {
                return teamsfx_api_1.err(error_1.NoSPPackageError(appPackage));
            }
            const fileName = path_1.default.parse(appPackage).base;
            const bytes = await fs_extra_1.default.readFile(appPackage);
            try {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.UploadAndDeploy));
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            }
            catch (e) {
                if (((_e = e.response) === null || _e === void 0 ? void 0 : _e.status) === 403) {
                    (_f = ctx.userInteraction) === null || _f === void 0 ? void 0 : _f.showMessage("error", localizeUtils_1.getLocalizedString("plugins.spfx.deployFailedNotice", appCatalogSite), false, "OK");
                    return teamsfx_api_1.err(error_1.InsufficientPermissionError(appCatalogSite));
                }
                else {
                    return teamsfx_api_1.err(error_1.UploadAppPackageFailedError(e));
                }
            }
            const appID = await this.getAppID(inputs.projectPath);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                (_g = ctx.userInteraction) === null || _g === void 0 ? void 0 : _g.showMessage("info", guidance, false);
            }
            else {
                (_h = ctx.userInteraction) === null || _h === void 0 ? void 0 : _h.showMessage("info", guidance, false, "OK");
            }
            success = true;
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            await progress_helper_1.ProgressHelper.endDeployProgress(success);
        }
    }
    async getAppID(root) {
        const solutionConfig = await fs_extra_1.default.readJson(`${root}/SPFx/config/package-solution.json`);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
    async getTenant(tokenProvider) {
        var _a, _b;
        const graphTokenRes = await ((_a = tokenProvider.m365TokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken({
            scopes: tools_1.GraphScopes,
        }));
        const graphToken = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        if (!graphToken) {
            return teamsfx_api_1.err(error_1.GetGraphTokenFailedError());
        }
        const tokenJsonRes = await ((_b = tokenProvider.m365TokenProvider) === null || _b === void 0 ? void 0 : _b.getJsonObject({
            scopes: tools_1.GraphScopes,
        }));
        const username = tokenJsonRes.value.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                return teamsfx_api_1.err(error_1.GetTenantFailedError(username));
            }
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.GetTenantFailedError(username, e));
        }
        return teamsfx_api_1.ok(tenant);
    }
    static async findGulpCommand(rootPath) {
        let gulpCommand;
        const platform = process.platform;
        if (platform === "win32" &&
            (await fs_extra_1.default.pathExists(path_1.default.join(rootPath, "node_modules", ".bin", "gulp.cmd")))) {
            gulpCommand = path_1.default.join(".", "node_modules", ".bin", "gulp.cmd");
        }
        else if ((platform === "linux" || platform === "darwin") &&
            (await fs_extra_1.default.pathExists(path_1.default.join(rootPath, "node_modules", ".bin", "gulp")))) {
            gulpCommand = path_1.default.join(".", "node_modules", ".bin", "gulp");
        }
        else {
            gulpCommand = "gulp";
        }
        return gulpCommand;
    }
    async getPackage(root) {
        const solutionConfig = await fs_extra_1.default.readJson(`${root}/SPFx/config/package-solution.json`);
        const sharepointPackage = `${root}/SPFx/sharepoint/${solutionConfig.paths.zippedPackage}`;
        return sharepointPackage;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-spfx",
            telemetryEventName: "deploy",
            errorSource: "SPFx",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SpfxResource.prototype, "deploy", null);
SpfxResource = SpfxResource_1 = tslib_1.__decorate([
    typedi_1.Service(constants_2.ComponentNames.SPFx)
], SpfxResource);
exports.SpfxResource = SpfxResource;
//# sourceMappingURL=index.js.map