"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlClient = void 0;
const tslib_1 = require("tslib");
const tedious = tslib_1.__importStar(require("tedious"));
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const results_1 = require("../results");
const localizeUtils_1 = require("../../../../common/localizeUtils");
class SqlClient {
    constructor(config, token) {
        this.config = config;
        this.token = token;
    }
    static async create(azureAccountProvider, config) {
        const token = await SqlClient.initToken(azureAccountProvider, config);
        return new SqlClient(config, token);
    }
    async addDatabaseUser(database) {
        var _a;
        try {
            let query;
            query = `IF NOT EXISTS (SELECT name FROM [sys].[database_principals] WHERE name='${this.config.identity}')
      BEGIN
      CREATE USER [${this.config.identity}] FROM EXTERNAL PROVIDER;
      END;`;
            await this.doQuery(query, database);
            query = `sp_addrolemember 'db_datareader', '${this.config.identity}'`;
            await this.doQuery(query, database);
            query = `sp_addrolemember 'db_datawriter', '${this.config.identity}'`;
            await this.doQuery(query, database);
        }
        catch (error) {
            const link = constants_1.HelpLinks.default;
            if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes(errors_1.ErrorMessage.GuestAdminMessage)) {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(database, this.config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, [errorMessage[0], errorMessage[1] + `. ${errors_1.ErrorMessage.GuestAdminError}`], error, undefined, link);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
            else {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(database, this.config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, [errorMessage[0], errorMessage[1] + `. ${localizeUtils_1.getLocalizedString("error.sql.GetDetail")}`], error, undefined, link);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
        }
    }
    static async initToken(azureAccountProvider, config) {
        var _a;
        const credential = await azureAccountProvider.getIdentityCredentialAsync();
        const databaseNames = `(${config.databases.join(",")})`;
        if (!credential) {
            const link = constants_1.HelpLinks.default;
            const reason = errors_1.ErrorMessage.IdentityCredentialUndefine(config.identity, databaseNames);
            const message = errors_1.ErrorMessage.DatabaseUserCreateError.message(databaseNames, config.identity);
            message[0] += `. ${reason}`;
            message[1] += `. ${reason}`;
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, [message[0] + ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`, message[1]], undefined, undefined, link);
        }
        try {
            const accessToken = await credential.getToken(constants_1.Constants.azureSqlScope);
            return accessToken.token;
        }
        catch (error) {
            const link = constants_1.HelpLinks.default;
            if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes(errors_1.ErrorMessage.DomainCode)) {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(databaseNames, config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, [
                    errorMessage[0] + `. ${errors_1.ErrorMessage.DomainError}`,
                    errorMessage[1] + `. ${errors_1.ErrorMessage.DomainError}`,
                ], error, undefined, link);
                e.message += ` ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
            else {
                const errorMessage = errors_1.ErrorMessage.DatabaseUserCreateError.message(databaseNames, config.identity);
                const e = results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.DatabaseUserCreateError.name, [errorMessage[0], errorMessage[1] + `. ${localizeUtils_1.getLocalizedString("error.sql.GetDetail")}`], error, undefined, link);
                e.message += `Reason: ${error.message}. ${errors_1.ErrorMessage.LinkHelpMessage(link)}`;
                throw e;
            }
        }
    }
    async doQuery(cmd, database) {
        const config = {
            server: this.config.sqlEndpoint,
            authentication: {
                type: "azure-active-directory-access-token",
                options: {
                    token: this.token,
                },
            },
            options: {
                debug: {
                    packet: true,
                    data: true,
                    payload: true,
                    token: false,
                    log: true,
                },
                rowCollectionOnDone: true,
                database: database,
                encrypt: true,
                requestTimeout: 30000,
                connectTimeout: 30000,
            },
        };
        const connection = new tedious.Connection(config);
        return new Promise((resolve, reject) => {
            connection.connect((err) => {
                if (err) {
                    reject(err);
                }
            });
            connection.on("connect", (err) => {
                if (err) {
                    reject(err);
                }
                const request = new tedious.Request(cmd, (err) => {
                    if (err) {
                        reject(err);
                    }
                });
                let res;
                request.on("doneInProc", function (rowCount, more, rows) {
                    res = rows;
                });
                request.on("requestCompleted", () => {
                    connection.close();
                    resolve(res);
                });
                request.on("error", (error) => {
                    reject(error);
                });
                connection.execSql(request);
            });
            connection.on("error", (err) => {
                reject(err);
            });
        });
    }
    static isFireWallError(error) {
        var _a;
        if ((error === null || error === void 0 ? void 0 : error.code) === "ELOGIN" && ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.match(errors_1.ErrorMessage.FirewallErrorReg))) {
            return true;
        }
        return false;
    }
}
exports.SqlClient = SqlClient;
//# sourceMappingURL=sql.js.map