"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagementClient = void 0;
const tslib_1 = require("tslib");
const arm_sql_1 = require("@azure/arm-sql");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("../errors");
const constants_1 = require("../constants");
const results_1 = require("../results");
class ManagementClient {
    constructor(manager, config) {
        this.totalFirewallRuleCount = 0;
        this.manager = manager;
        this.config = config;
    }
    static async create(azureAccountProvider, config) {
        const credential = await azureAccountProvider.getIdentityCredentialAsync();
        const manager = new arm_sql_1.SqlManagementClient(credential, config.azureSubscriptionId);
        return new ManagementClient(manager, config);
    }
    async existAzureSQL() {
        try {
            const result = await this.manager.servers.checkNameAvailability({
                name: this.config.sqlServer,
                type: "Microsoft.Sql/servers",
            });
            if (result.available) {
                return false;
            }
            else {
                return true;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlCheckError.name, errors_1.ErrorMessage.SqlCheckError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async existAadAdmin(aadAdmin) {
        var e_1, _a;
        try {
            try {
                for (var _b = tslib_1.__asyncValues(this.manager.serverAzureADAdministrators
                    .listByServer(this.config.resourceGroup, this.config.sqlServer)
                    .byPage()), _c; _c = await _b.next(), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        if (item.login === aadAdmin) {
                            return true;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCheckAdminError.name, errors_1.ErrorMessage.SqlCheckAdminError.message(this.config.sqlServer, error.message), error);
        }
    }
    async addAADadmin(tenantId, aadAdminObjectId, aadAdmin) {
        const model = {
            tenantId: tenantId,
            sid: aadAdminObjectId,
            login: aadAdmin,
            administratorType: arm_sql_1.KnownAdministratorType.ActiveDirectory,
        };
        try {
            await this.manager.serverAzureADAdministrators.beginCreateOrUpdateAndWait(this.config.resourceGroup, this.config.sqlServer, arm_sql_1.KnownAdministratorType.ActiveDirectory, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlAddAdminError.name, errors_1.ErrorMessage.SqlAddAdminError.message(aadAdmin, error.message), error);
        }
    }
    async addLocalFirewallRule() {
        try {
            const response = await axios_1.default.get(constants_1.Constants.echoIpAddress);
            const localIp = response.data;
            const partials = localIp.split(".");
            partials[2] = constants_1.Constants.ipBeginToken;
            partials[3] = constants_1.Constants.ipBeginToken;
            const startIp = partials.join(".");
            partials[2] = constants_1.Constants.ipEndToken;
            partials[3] = constants_1.Constants.ipEndToken;
            const endIp = partials.join(".");
            const model = {
                startIpAddress: startIp,
                endIpAddress: endIp,
            };
            const ruleName = this.getRuleName(this.totalFirewallRuleCount);
            await this.manager.firewallRules.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, ruleName, model);
            this.totalFirewallRuleCount++;
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlLocalFirwallError.name, errors_1.ErrorMessage.SqlLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async deleteLocalFirewallRule() {
        try {
            await Promise.all(Array.from(Array(this.totalFirewallRuleCount).keys()).map(async (i) => {
                const ruleName = this.getRuleName(i);
                await this.manager.firewallRules.delete(this.config.resourceGroup, this.config.sqlServer, ruleName);
            }));
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlDeleteLocalFirwallError.name, errors_1.ErrorMessage.SqlDeleteLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    getRuleName(suffix) {
        return constants_1.Constants.firewall.localRule + suffix;
    }
    async delay(s) {
        return new Promise((resolve) => setTimeout(resolve, s * 1000));
    }
}
exports.ManagementClient = ManagementClient;
//# sourceMappingURL=management.js.map