"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilFunctions = void 0;
const tools_1 = require("../../../../common/tools");
const constants_1 = require("../../../constants");
const sql_1 = require("../clients/sql");
const constants_2 = require("../constants");
const errors_1 = require("../errors");
const results_1 = require("../results");
const common_1 = require("../utils/common");
class UtilFunctions {
    static async CheckAndSetAadAdmin(client, aadAdmin, objectId, tenantId) {
        const existAdmin = await client.existAadAdmin(aadAdmin);
        if (!existAdmin) {
            await client.addAADadmin(tenantId, objectId, aadAdmin);
        }
        return existAdmin;
    }
    static async parseLoginToken(azureAccountProvider) {
        // get login user info to set aad admin in sql
        try {
            const credential = await azureAccountProvider.getIdentityCredentialAsync();
            const token = await credential.getToken(tools_1.AzureScopes);
            const accessToken = token === null || token === void 0 ? void 0 : token.token;
            return common_1.parseToken(accessToken);
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlUserInfoError.name, errors_1.ErrorMessage.SqlUserInfoError.message(), error);
        }
    }
    static async getSkipAddingUser(config, azureAccountProvider) {
        const skipAddingUser = config[constants_2.Constants.skipAddingSqlUser];
        if (skipAddingUser === undefined) {
            return (await (azureAccountProvider === null || azureAccountProvider === void 0 ? void 0 : azureAccountProvider.getIdentityCredentialAsync())) ? false : true;
        }
        else {
            return skipAddingUser;
        }
    }
    static getIdentity(ctx) {
        const config = ctx.envInfo.state[constants_1.ComponentNames.Identity];
        const identity = config[constants_2.Constants.identityName];
        if (!identity) {
            const error = results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlGetConfigError.name, errors_1.ErrorMessage.SqlGetConfigError.message(constants_2.Constants.identityPlugin, constants_2.Constants.identityName));
            throw error;
        }
        return identity;
    }
    static async addDatabaseUser(logProvider, sqlClient, managementClient) {
        let retryCount = 0;
        const databaseWithUser = {};
        sqlClient.config.databases.forEach((element) => {
            databaseWithUser[element] = false;
        });
        while (true) {
            try {
                for (const database in databaseWithUser) {
                    if (!databaseWithUser[database]) {
                        await sqlClient.addDatabaseUser(database);
                        databaseWithUser[database] = true;
                    }
                }
                return;
            }
            catch (error) {
                if (!sql_1.SqlClient.isFireWallError(error === null || error === void 0 ? void 0 : error.innerError) ||
                    retryCount >= constants_2.Constants.maxRetryTimes) {
                    throw error;
                }
                else {
                    retryCount++;
                    logProvider.warning(`[${constants_2.Constants.pluginName}] Retry adding new firewall rule to access azure sql, because the local IP address has changed after added firewall rule for it. [Retry time: ${retryCount}]`);
                    await managementClient.addLocalFirewallRule();
                }
            }
        }
    }
}
exports.UtilFunctions = UtilFunctions;
//# sourceMappingURL=utils.js.map