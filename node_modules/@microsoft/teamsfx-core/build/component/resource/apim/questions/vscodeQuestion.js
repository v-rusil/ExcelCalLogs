"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewApiVersionQuestion = exports.ApiVersionQuestion = exports.ApiPrefixQuestion = exports.ExistingOpenApiDocumentFunc = exports.OpenApiDocumentQuestion = void 0;
const tools_1 = require("../../../../common/tools");
const migrate_1 = require("../../../../component/migrate");
const constants_1 = require("../../../constants");
const answer_1 = require("../answer");
const config_1 = require("../config");
const constants_2 = require("../constants");
const error_1 = require("../error");
const commonUtils_1 = require("../utils/commonUtils");
const namingRules_1 = require("../utils/namingRules");
const question_1 = require("./question");
class OpenApiDocumentQuestion extends question_1.BaseQuestionService {
    constructor(openApiProcessor, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.openApiProcessor = openApiProcessor;
    }
    getQuestion(projectPath) {
        return {
            type: "singleSelect",
            name: constants_2.QuestionConstants.VSCode.OpenApiDocument.questionName,
            title: constants_2.QuestionConstants.VSCode.OpenApiDocument.description,
            staticOptions: [],
            dynamicOptions: async (inputs) => {
                return this.getDynamicOptions(projectPath);
            },
            returnObject: true,
            skipSingleOption: false,
        };
    }
    async getDynamicOptions(root) {
        const filePath2OpenApiMap = await this.openApiProcessor.listOpenApiDocument(root, constants_2.QuestionConstants.VSCode.OpenApiDocument.excludeFolders, constants_2.QuestionConstants.VSCode.OpenApiDocument.openApiDocumentFileExtensions);
        if (filePath2OpenApiMap.size === 0) {
            throw error_1.BuildError(error_1.NoValidOpenApiDocument);
        }
        const result = [];
        filePath2OpenApiMap.forEach((value, key) => result.push({ id: key, label: key, data: value }));
        return result;
    }
}
exports.OpenApiDocumentQuestion = OpenApiDocumentQuestion;
class ExistingOpenApiDocumentFunc extends question_1.BaseQuestionService {
    constructor(openApiProcessor, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.openApiProcessor = openApiProcessor;
    }
    getQuestion(projectPath, envName, apimState) {
        return {
            type: "func",
            name: constants_2.QuestionConstants.VSCode.ExistingOpenApiDocument.questionName,
            func: async (inputs) => {
                const apimConfig = new config_1.ApimPluginConfig(apimState, envName);
                const openApiDocumentPath = apimConfig.checkAndGet(constants_2.ApimPluginConfigKeys.apiDocumentPath);
                const openApiDocument = await this.openApiProcessor.loadOpenApiDocument(openApiDocumentPath, projectPath);
                return { id: openApiDocumentPath, label: openApiDocumentPath, data: openApiDocument };
            },
        };
    }
}
exports.ExistingOpenApiDocumentFunc = ExistingOpenApiDocumentFunc;
class ApiPrefixQuestion extends question_1.BaseQuestionService {
    constructor(telemetryReporter, logger) {
        super(telemetryReporter, logger);
    }
    getQuestion() {
        return {
            type: "text",
            name: constants_2.QuestionConstants.VSCode.ApiPrefix.questionName,
            title: constants_2.QuestionConstants.VSCode.ApiPrefix.description,
            prompt: constants_2.QuestionConstants.VSCode.ApiPrefix.prompt,
            default: async (inputs) => {
                var _a, _b;
                const apiTitle = (_b = (_a = answer_1.buildAnswer(inputs)) === null || _a === void 0 ? void 0 : _a.openApiDocumentSpec) === null || _b === void 0 ? void 0 : _b.info.title;
                let apiPrefix;
                if (apiTitle) {
                    apiPrefix = namingRules_1.NamingRules.apiPrefix.sanitize(apiTitle);
                }
                return apiPrefix ? apiPrefix : constants_2.ApimDefaultValues.apiPrefix;
            },
            validation: {
                validFunc: (input, previousInputs) => namingRules_1.NamingRules.validate(input, namingRules_1.NamingRules.apiPrefix),
            },
        };
    }
}
exports.ApiPrefixQuestion = ApiPrefixQuestion;
class ApiVersionQuestion extends question_1.BaseQuestionService {
    constructor(lazyApimService, telemetryReporter, logger) {
        super(telemetryReporter, logger);
        this.lazyApimService = lazyApimService;
    }
    getQuestion(envInfo) {
        return {
            type: "singleSelect",
            name: constants_2.QuestionConstants.VSCode.ApiVersion.questionName,
            title: constants_2.QuestionConstants.VSCode.ApiVersion.description,
            staticOptions: [],
            dynamicOptions: async (inputs) => {
                return this.getDynamicOptions(inputs, envInfo);
            },
            returnObject: true,
            skipSingleOption: false,
        };
    }
    async getDynamicOptions(inputs, envInfo) {
        var _a, _b;
        const apimService = await this.lazyApimService.getValue();
        const apimState = envInfo.state.get
            ? envInfo.state.get(constants_1.BuiltInFeaturePluginNames.apim)
            : envInfo.state[migrate_1.APIM_STATE_KEY];
        const apimConfig = new config_1.ApimPluginConfig(apimState, envInfo.envName);
        const solutionConfig = new config_1.SolutionConfig(envInfo);
        const answer = answer_1.buildAnswer(inputs);
        const apimServiceResourceId = apimConfig.checkAndGet(constants_2.ApimPluginConfigKeys.serviceResourceId);
        const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(apimServiceResourceId);
        const serviceName = commonUtils_1.getApimServiceNameFromResourceId(apimServiceResourceId);
        const apiPrefix = (_a = answer.apiPrefix) !== null && _a !== void 0 ? _a : apimConfig.checkAndGet(constants_2.ApimPluginConfigKeys.apiPrefix);
        const versionSetId = (_b = apimConfig.versionSetId) !== null && _b !== void 0 ? _b : namingRules_1.NamingRules.versionSetId.sanitize(apiPrefix, solutionConfig.resourceNameSuffix);
        const apiContracts = await apimService.listApi(resourceGroupName, serviceName, versionSetId);
        const existingApiVersionOptions = apiContracts.map((api) => {
            var _a, _b, _c;
            const result = {
                id: (_a = api.name) !== null && _a !== void 0 ? _a : "",
                label: (_b = api.apiVersion) !== null && _b !== void 0 ? _b : "",
                description: (_c = api.name) !== null && _c !== void 0 ? _c : "",
                data: api,
            };
            return result;
        });
        const createNewApiVersionOption = {
            id: constants_2.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
            label: constants_2.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
        };
        return [createNewApiVersionOption, ...existingApiVersionOptions];
    }
}
exports.ApiVersionQuestion = ApiVersionQuestion;
class NewApiVersionQuestion extends question_1.BaseQuestionService {
    constructor(telemetryReporter, logger) {
        super(telemetryReporter, logger);
    }
    condition() {
        return {
            equals: constants_2.QuestionConstants.VSCode.ApiVersion.createNewApiVersionOption,
        };
    }
    getQuestion() {
        return {
            type: "text",
            name: constants_2.QuestionConstants.VSCode.NewApiVersion.questionName,
            title: constants_2.QuestionConstants.VSCode.NewApiVersion.description,
            default: async (inputs) => {
                var _a, _b;
                const apiVersion = (_b = (_a = answer_1.buildAnswer(inputs)) === null || _a === void 0 ? void 0 : _a.openApiDocumentSpec) === null || _b === void 0 ? void 0 : _b.info.version;
                let versionIdentity;
                if (apiVersion) {
                    versionIdentity = namingRules_1.NamingRules.versionIdentity.sanitize(apiVersion);
                }
                return versionIdentity ? versionIdentity : constants_2.ApimDefaultValues.apiVersion;
            },
            validation: {
                validFunc: (input, previousInputs) => namingRules_1.NamingRules.validate(input, namingRules_1.NamingRules.versionIdentity),
            },
        };
    }
}
exports.NewApiVersionQuestion = NewApiVersionQuestion;
//# sourceMappingURL=vscodeQuestion.js.map