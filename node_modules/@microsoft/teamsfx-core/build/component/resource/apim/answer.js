"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CLIAnswer = exports.VSCodeAnswer = exports.buildAnswer = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("./constants");
const error_1 = require("./error");
const namingRules_1 = require("./utils/namingRules");
const openApiProcessor_1 = require("./utils/openApiProcessor");
function buildAnswer(inputs) {
    inputs = error_1.AssertNotEmpty("inputs", inputs);
    switch (inputs.platform) {
        case teamsfx_api_1.Platform.VSCode:
            return new VSCodeAnswer(inputs);
        case teamsfx_api_1.Platform.CLI:
            return new CLIAnswer(inputs);
        default:
            throw error_1.BuildError(error_1.NotImplemented);
    }
}
exports.buildAnswer = buildAnswer;
class BaseAnswer {
    constructor(inputs) {
        this.inputs = inputs;
    }
    getOptionItem(questionName) {
        return this.inputs[questionName];
    }
    getString(questionName) {
        return this.inputs[questionName];
    }
}
class VSCodeAnswer extends BaseAnswer {
    constructor(inputs) {
        super(inputs);
    }
    get apiDocumentPath() {
        var _a;
        return (_a = this.getOptionItem(constants_1.QuestionConstants.VSCode.OpenApiDocument.questionName)) === null || _a === void 0 ? void 0 : _a.label;
    }
    get openApiDocumentSpec() {
        var _a;
        const openApiDocument = (_a = this.getOptionItem(constants_1.QuestionConstants.VSCode.OpenApiDocument.questionName)) === null || _a === void 0 ? void 0 : _a.data;
        return openApiDocument === null || openApiDocument === void 0 ? void 0 : openApiDocument.spec;
    }
    get apiPrefix() {
        return this.getString(constants_1.QuestionConstants.VSCode.ApiPrefix.questionName);
    }
    get apiId() {
        var _a;
        const api = (_a = this.getOptionItem(constants_1.QuestionConstants.VSCode.ApiVersion.questionName)) === null || _a === void 0 ? void 0 : _a.data;
        return api === null || api === void 0 ? void 0 : api.name;
    }
    get versionIdentity() {
        var _a, _b;
        const api = (_a = this.getOptionItem(constants_1.QuestionConstants.VSCode.ApiVersion.questionName)) === null || _a === void 0 ? void 0 : _a.data;
        return (_b = api === null || api === void 0 ? void 0 : api.apiVersion) !== null && _b !== void 0 ? _b : this.getString(constants_1.QuestionConstants.VSCode.NewApiVersion.questionName);
    }
    save(lifecycle, apimConfig) {
        var _a, _b;
        switch (lifecycle) {
            case constants_1.PluginLifeCycle.Deploy:
                apimConfig.apiDocumentPath = (_a = this.apiDocumentPath) !== null && _a !== void 0 ? _a : apimConfig.apiDocumentPath;
                apimConfig.apiPrefix = (_b = this.apiPrefix) !== null && _b !== void 0 ? _b : apimConfig.apiPrefix;
                break;
        }
    }
}
exports.VSCodeAnswer = VSCodeAnswer;
class CLIAnswer extends BaseAnswer {
    constructor(inputs) {
        super(inputs);
    }
    get apiDocumentPath() {
        return this.getString(constants_1.QuestionConstants.CLI.OpenApiDocument.questionName);
    }
    get apiPrefix() {
        return this.getString(constants_1.QuestionConstants.CLI.ApiPrefix.questionName);
    }
    get apiId() {
        return this.getString(constants_1.QuestionConstants.CLI.ApiId.questionName);
    }
    get versionIdentity() {
        return this.getString(constants_1.QuestionConstants.CLI.ApiVersion.questionName);
    }
    save(lifecycle, apimConfig) {
        var _a, _b;
        switch (lifecycle) {
            case constants_1.PluginLifeCycle.Deploy:
                apimConfig.apiDocumentPath = (_a = this.apiDocumentPath) !== null && _a !== void 0 ? _a : apimConfig.apiDocumentPath;
                apimConfig.apiPrefix = (_b = this.apiPrefix) !== null && _b !== void 0 ? _b : apimConfig.apiPrefix;
                break;
        }
    }
    async validate(lifecycle, apimConfig, projectRootDir) {
        const message = await this.validateWithMessage(lifecycle, apimConfig, projectRootDir);
        if (typeof message !== "undefined") {
            throw error_1.BuildError(error_1.InvalidCliOptionError, message);
        }
    }
    // TODO: delete the following logic after cli question model fix undefined / empty string validation bug
    // https://msazure.visualstudio.com/Microsoft%20Teams%20Extensibility/_workitems/edit/9893622
    // https://msazure.visualstudio.com/Microsoft%20Teams%20Extensibility/_workitems/edit/9823734
    async validateWithMessage(lifecycle, apimConfig, projectRootDir) {
        switch (lifecycle) {
            case constants_1.PluginLifeCycle.Deploy:
                // Validate the option requirements
                if (!apimConfig.apiPrefix && !this.apiPrefix) {
                    return constants_1.ValidationConstants.CLI.emptyOptionMessage(constants_1.QuestionConstants.CLI.ApiPrefix.questionName);
                }
                if (!apimConfig.apiDocumentPath && !this.apiDocumentPath) {
                    return constants_1.ValidationConstants.CLI.emptyOptionMessage(constants_1.QuestionConstants.CLI.OpenApiDocument.questionName);
                }
                if (!this.versionIdentity) {
                    return constants_1.ValidationConstants.CLI.emptyOptionMessage(constants_1.QuestionConstants.CLI.ApiVersion.questionName);
                }
                // Validate the option override
                if (apimConfig.apiPrefix && this.apiPrefix) {
                    return constants_1.ValidationConstants.CLI.overrideOptionMessage(constants_1.QuestionConstants.CLI.ApiPrefix.questionName);
                }
                // Validate the option format
                if (typeof this.apiPrefix !== "undefined") {
                    const message = namingRules_1.NamingRules.validate(this.apiPrefix, namingRules_1.NamingRules.apiPrefix);
                    if (message) {
                        return `${constants_1.ValidationConstants.CLI.invalidOptionMessage(constants_1.QuestionConstants.CLI.ApiPrefix.questionName)} ${message}`;
                    }
                }
                if (typeof this.apiDocumentPath !== "undefined") {
                    try {
                        const openApiProcessor = new openApiProcessor_1.OpenApiProcessor();
                        await openApiProcessor.loadOpenApiDocument(this.apiDocumentPath, projectRootDir);
                    }
                    catch (error) {
                        return `${constants_1.ValidationConstants.CLI.invalidOptionMessage(constants_1.QuestionConstants.CLI.OpenApiDocument.questionName)} ${error.message}`;
                    }
                }
                if (typeof this.versionIdentity != "undefined") {
                    const message = namingRules_1.NamingRules.validate(this.versionIdentity, namingRules_1.NamingRules.versionIdentity);
                    if (message) {
                        return `${constants_1.ValidationConstants.CLI.invalidOptionMessage(constants_1.QuestionConstants.CLI.ApiVersion.questionName)} ${message}`;
                    }
                }
                break;
        }
        return undefined;
    }
}
exports.CLIAnswer = CLIAnswer;
//# sourceMappingURL=answer.js.map