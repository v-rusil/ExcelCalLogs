"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuthServiceNameFromResourceId = exports.getProductNameFromResourceId = exports.getApimServiceNameFromResourceId = exports.Lazy = exports.delay = exports.RetryHandler = exports.capitalizeFirstLetter = exports.getFileExtension = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const tools_1 = require("../../../../common/tools");
const constants_1 = require("../constants");
const error_1 = require("../error");
function getFileExtension(filePath) {
    const basename = filePath.split(/[\\/]/).pop();
    if (!basename) {
        return "";
    }
    const pos = basename.lastIndexOf(".");
    if (basename === "" || pos < 1) {
        return "";
    }
    return basename.slice(pos + 1);
}
exports.getFileExtension = getFileExtension;
function capitalizeFirstLetter(str) {
    const firstLetter = str.length > 0 ? str.charAt(0).toUpperCase() : "";
    const nextLetters = str.length > 1 ? str.slice(1) : "";
    return firstLetter + nextLetters;
}
exports.capitalizeFirstLetter = capitalizeFirstLetter;
class RetryHandler {
    static async retry(fn, maxRetries, retryTimeInterval) {
        let executionIndex = 0;
        let error = undefined;
        while (executionIndex <= (maxRetries !== null && maxRetries !== void 0 ? maxRetries : constants_1.ProjectConstants.maxRetries)) {
            await delay(executionIndex * (retryTimeInterval !== null && retryTimeInterval !== void 0 ? retryTimeInterval : constants_1.ProjectConstants.retryTimeInterval));
            try {
                const response = await fn(executionIndex);
                return response;
            }
            catch (e) {
                error = e;
                ++executionIndex;
            }
        }
        throw error;
    }
}
exports.RetryHandler = RetryHandler;
function delay(ms) {
    if (ms <= 0) {
        return Promise.resolve();
    }
    // tslint:disable-next-line no-string-based-set-timeout
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.delay = delay;
// Do not support parallel execution
class Lazy {
    constructor(factoryFunc) {
        this.factoryFunc = factoryFunc;
    }
    async getValue() {
        if (typeof this.factoryOutput === "undefined") {
            this.factoryOutput = await this.factoryFunc();
        }
        return this.factoryOutput;
    }
}
exports.Lazy = Lazy;
function getApimServiceNameFromResourceId(resourceId) {
    const result = tools_1.parseFromResourceId(/providers\/Microsoft.ApiManagement\/service\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.BuildError(error_1.FailedToParseResourceIdError, "API Management service name", resourceId);
    }
    return result;
}
exports.getApimServiceNameFromResourceId = getApimServiceNameFromResourceId;
function getProductNameFromResourceId(resourceId) {
    const result = tools_1.parseFromResourceId(/products\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.BuildError(error_1.FailedToParseResourceIdError, "product name", resourceId);
    }
    return result;
}
exports.getProductNameFromResourceId = getProductNameFromResourceId;
function getAuthServiceNameFromResourceId(resourceId) {
    const result = tools_1.parseFromResourceId(/authorizationServers\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.BuildError(error_1.FailedToParseResourceIdError, " auth server name", resourceId);
    }
    return result;
}
exports.getAuthServiceNameFromResourceId = getAuthServiceNameFromResourceId;
//# sourceMappingURL=commonUtils.js.map