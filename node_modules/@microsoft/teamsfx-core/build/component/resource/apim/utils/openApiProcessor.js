"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiProcessor = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const swagger_parser_1 = tslib_1.__importDefault(require("@apidevtools/swagger-parser"));
const error_1 = require("../error");
const url_parse_1 = tslib_1.__importDefault(require("url-parse"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../constants");
const log_1 = require("../log");
class OpenApiProcessor {
    constructor(telemetryReporter, logger) {
        this.logger = logger;
        this.telemetryReporter = telemetryReporter;
        this.swaggerParser = new swagger_parser_1.default();
    }
    async generateDefaultOpenApi(fileName, title, version) {
        var _a;
        const exists = fs.existsSync(fileName);
        if (exists) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(log_1.LogMessages.openApiDocumentExists(fileName));
            return;
        }
        const spec = {
            openapi: "3.0.1",
            info: {
                title: title,
                version: version,
            },
            paths: {},
        };
        await fs.outputJSON(fileName, spec, { spaces: 4 });
    }
    async listOpenApiDocument(dir, excludeFolders, openApiDocumentFileExtensions) {
        const files = await this.listAllFiles(dir, excludeFolders, openApiDocumentFileExtensions);
        const fileName2OpenApi = new Map();
        for (const file of files) {
            try {
                const openApi = await this.loadOpenApiDocument(file);
                const relativePath = path.relative(dir, file).replace(/\\/g, "/");
                fileName2OpenApi.set(relativePath, openApi);
            }
            catch (error) {
                continue;
            }
        }
        return fileName2OpenApi;
    }
    async loadOpenApiDocument(fileName, dir) {
        let srcSpec;
        const filepath = path.isAbsolute(fileName) || !dir ? fileName : path.join(dir, fileName);
        try {
            srcSpec = await this.swaggerParser.validate(filepath, {
                parse: {
                    json: { allowEmpty: false },
                    yaml: { allowEmpty: false },
                },
                validate: {
                    spec: false,
                    schema: true,
                },
            });
        }
        catch (error) {
            throw error_1.BuildError(error_1.InvalidOpenApiDocument, filepath);
        }
        this.validateOpenApiInfo(srcSpec, filepath);
        const schemaVersion = this.getSchemaVersion(srcSpec, filepath);
        return {
            schemaVersion: schemaVersion,
            spec: srcSpec,
        };
    }
    patchOpenApiDocument(spec, schemaVersion, endpoint, basePath) {
        const parsedUrl = url_parse_1.default(endpoint);
        basePath = basePath !== null && basePath !== void 0 ? basePath : constants_1.ApimDefaultValues.functionBasePath;
        parsedUrl.set("pathname", basePath);
        const scheme = this.getScheme(parsedUrl.protocol);
        switch (schemaVersion) {
            case constants_1.OpenApiSchemaVersion.V2:
                spec = spec;
                spec.schemes = [scheme];
                spec.host = parsedUrl.hostname;
                spec.basePath = parsedUrl.pathname;
                break;
            case constants_1.OpenApiSchemaVersion.V3:
                spec = spec;
                spec.servers = [{ url: parsedUrl.toString() }];
                break;
        }
        return spec;
    }
    async listAllFiles(dir, excludeFolders, fileExtensions) {
        var _a;
        const result = [];
        const files = await fs.readdir(dir);
        for (const fileName of files) {
            try {
                const filePath = path.join(dir, fileName);
                if ((await fs.stat(filePath)).isDirectory()) {
                    if (excludeFolders.includes(fileName)) {
                        continue;
                    }
                    result.push(...(await this.listAllFiles(filePath, excludeFolders, fileExtensions)));
                }
                else {
                    if (!fileExtensions) {
                        result.push(filePath);
                        continue;
                    }
                    for (const fileExtension of fileExtensions) {
                        if (filePath.endsWith(`.${fileExtension}`)) {
                            result.push(filePath);
                            break;
                        }
                    }
                }
            }
            catch (error) {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warning(log_1.LogMessages.accessFileFailed(dir, fileName));
                continue;
            }
        }
        return result;
    }
    getSchemaVersion(spec, filePath) {
        if ("swagger" in spec) {
            return constants_1.OpenApiSchemaVersion.V2;
        }
        else if ("openapi" in spec) {
            return constants_1.OpenApiSchemaVersion.V3;
        }
        else {
            throw error_1.BuildError(error_1.InvalidOpenApiDocument, filePath);
        }
    }
    validateOpenApiInfo(spec, filePath) {
        if (!spec.info.title) {
            throw error_1.BuildError(error_1.EmptyTitleInOpenApiDocument, filePath);
        }
        if (!spec.info.version) {
            throw error_1.BuildError(error_1.EmptyVersionInOpenApiDocument, filePath);
        }
    }
    getScheme(protocol) {
        if (protocol.startsWith("https")) {
            return "https";
        }
        else if (protocol.startsWith("http")) {
            return "http";
        }
        else {
            throw error_1.BuildError(error_1.InvalidFunctionEndpoint);
        }
    }
}
exports.OpenApiProcessor = OpenApiProcessor;
//# sourceMappingURL=openApiProcessor.js.map