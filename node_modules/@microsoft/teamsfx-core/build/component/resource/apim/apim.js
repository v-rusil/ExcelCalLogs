"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsForDeployAPIM = exports.APIMResource = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const constants_1 = require("../../constants");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const azureResource_1 = require("../azureResource");
const answer_1 = require("./answer");
const config_1 = require("./config");
const constants_2 = require("./constants");
const error_1 = require("./error");
const factory_1 = require("./factory");
let APIMResource = class APIMResource extends azureResource_1.AzureResource {
    constructor() {
        super(...arguments);
        this.name = constants_1.ComponentNames.APIM;
        this.bicepModuleName = constants_1.ComponentNames.APIM;
        this.outputs = constants_1.APIMOutputs;
        this.finalOutputKeys = [
            "apimClientAADObjectId",
            "apimClientAADClientId",
            "apimClientAADClientSecret",
            "serviceResourceId",
            "productResourceId",
            "authServerResourceId",
        ];
        this.secretKeys = ["apimClientAADClientSecret"];
    }
    async generateBicep(context, inputs) {
        return super.generateBicep(context, inputs);
    }
    async provision(context, inputs, actionContext) {
        var _a, _b;
        if (context.envInfo.envName !== "local") {
            context.envInfo.state[constants_1.ComponentNames.APIM] = context.envInfo.state[constants_1.ComponentNames.APIM] || {};
            const apimState = context.envInfo.state[constants_1.ComponentNames.APIM];
            const apimConfig = new config_1.ApimPluginConfig(apimState, context.envInfo.envName);
            const apimManager = await factory_1.Factory.buildApimManager(context.envInfo, context.telemetryReporter, context.tokenProvider.azureAccountProvider, context.logProvider);
            const aadManager = await factory_1.Factory.buildAadManager(context.tokenProvider.m365TokenProvider, context.telemetryReporter, context.logProvider);
            const appName = error_1.AssertNotEmpty("projectSettings.appName", context.projectSetting.appName);
            await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(constants_2.ProgressMessages[constants_2.ProgressStep.Provision].CreateApim));
            await apimManager.provision(apimConfig);
            await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(constants_2.ProgressMessages[constants_2.ProgressStep.Provision].CreateAad));
            await aadManager.provision(apimConfig, appName);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async configure(context, inputs, actionContext) {
        var _a, _b;
        if (context.envInfo.envName !== "local") {
            const apimResource = context.envInfo.state[constants_1.ComponentNames.APIM];
            const apimConfig = new config_1.ApimPluginConfig(apimResource, context.envInfo.envName);
            const aadConfig = new config_1.AadPluginConfig(context.envInfo);
            const aadManager = await factory_1.Factory.buildAadManager(context.tokenProvider.m365TokenProvider, context.telemetryReporter, context.logProvider);
            const teamsAppAadManager = await factory_1.Factory.buildTeamsAppAadManager(context.tokenProvider.m365TokenProvider, context.telemetryReporter, context.logProvider);
            await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(constants_2.ProgressMessages[constants_2.ProgressStep.PostProvision].ConfigClientAad));
            await aadManager.postProvision(apimConfig, aadConfig, constants_2.AadDefaultValues.redirectUris);
            await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(constants_2.ProgressMessages[constants_2.ProgressStep.PostProvision].ConfigAppAad));
            await teamsAppAadManager.postProvision(aadConfig, apimConfig);
            // Delete user sensitive configuration
            delete apimResource[constants_2.ApimPluginConfigKeys.publisherEmail];
            delete apimResource[constants_2.ApimPluginConfigKeys.publisherName];
        }
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(context, inputs, actionContext) {
        var _a;
        const solutionConfig = new config_1.SolutionConfig(context.envInfo);
        const apimConfig = new config_1.ApimPluginConfig(context.envInfo.state[constants_1.ComponentNames.APIM], context.envInfo.envName);
        const functionConfig = new config_1.FunctionPluginConfig(context.envInfo);
        const answer = answer_1.buildAnswer(inputs);
        if (answer.validate) {
            await answer.validate(constants_2.PluginLifeCycle.Deploy, apimConfig, inputs.projectPath);
        }
        answer.save(constants_2.PluginLifeCycle.Deploy, apimConfig);
        const apimManager = await factory_1.Factory.buildApimManager(context.envInfo, context.telemetryReporter, context.tokenProvider.azureAccountProvider, context.logProvider);
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(constants_2.ProgressMessages[constants_2.ProgressStep.Deploy].ImportApi));
        await apimManager.deploy(apimConfig, solutionConfig, functionConfig, answer, inputs.projectPath);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-apim",
            telemetryEventName: constants_2.PluginLifeCycle.GenerateArmTemplates,
            errorSource: constants_2.ProjectConstants.pluginShortName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], APIMResource.prototype, "generateBicep", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressSteps: 2,
            progressTitle: constants_2.ProgressStep.Provision,
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-apim",
            telemetryEventName: constants_2.PluginLifeCycle.Provision,
            errorSource: constants_2.ProjectConstants.pluginShortName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], APIMResource.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressSteps: 3,
            progressTitle: constants_2.ProgressStep.PostProvision,
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-apim",
            telemetryEventName: constants_2.PluginLifeCycle.PostProvision,
            errorSource: constants_2.ProjectConstants.pluginShortName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], APIMResource.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressSteps: 1,
            progressTitle: constants_2.ProgressStep.Deploy,
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-apim",
            telemetryEventName: constants_2.PluginLifeCycle.Deploy,
            errorSource: constants_2.ProjectConstants.pluginShortName,
            question: (context, inputs) => {
                return getQuestionsForDeployAPIM(context, inputs);
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], APIMResource.prototype, "deploy", null);
APIMResource = tslib_1.__decorate([
    typedi_1.Service(constants_1.ComponentNames.APIM)
], APIMResource);
exports.APIMResource = APIMResource;
async function getQuestionsForDeployAPIM(context, inputs) {
    const questionManager = await factory_1.Factory.buildQuestionManager(inputs.platform, context.envInfo, context.tokenProvider.azureAccountProvider, context.telemetryReporter, context.logProvider);
    const apimState = context.envInfo && context.envInfo.state && context.envInfo.state[constants_1.ComponentNames.APIM]
        ? context.envInfo.state[constants_1.ComponentNames.APIM]
        : {};
    const apimConfig = context.envInfo
        ? new config_1.ApimPluginConfig(apimState, context.envInfo.envName)
        : undefined;
    const node = await questionManager.deploy(inputs.projectPath, context.envInfo, apimConfig);
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForDeployAPIM = getQuestionsForDeployAPIM;
//# sourceMappingURL=apim.js.map