"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApimService = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../constants");
const error_1 = require("../error");
const telemetry_1 = require("../utils/telemetry");
const log_1 = require("../log");
class ApimService {
    constructor(apimClient, resourceProviderClient, credential, subscriptionId, telemetryReporter, logger) {
        this.credential = credential;
        this.subscriptionId = subscriptionId;
        this.apimClient = apimClient;
        this.resourceProviderClient = resourceProviderClient;
        this.telemetryReporter = telemetryReporter;
        this.logger = logger;
    }
    async getService(resourceGroupName, serviceName) {
        const fn = () => this.apimClient.apiManagementService.get(resourceGroupName, serviceName);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.APIM, serviceName, fn, resourceNotFoundErrorHandler);
    }
    async getApi(resourceGroupName, serviceName, apiId) {
        const fn = () => this.apimClient.api.get(resourceGroupName, serviceName, apiId);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.API, apiId, fn, resourceNotFoundErrorHandler);
    }
    // The maximum number of APIs in consumption tier is 50. There are no limits for other tiers.
    // Detail: https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#api-management-limits
    async listApi(resourceGroupName, serviceName, versionSetId) {
        var e_1, _a;
        var _b, _c, _d, _e;
        const resourceId = versionSetId
            ? this.generateVersionSetResourceId(this.subscriptionId, resourceGroupName, serviceName, versionSetId)
            : undefined;
        const result = [];
        try {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(log_1.LogMessages.operationStarts(constants_1.Operation.List, constants_1.AzureResource.API, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, constants_1.Operation.List, constants_1.AzureResource.API, constants_1.OperationStatus.Started);
            try {
                for (var _f = tslib_1.__asyncValues(this.apimClient.api
                    .listByService(resourceGroupName, serviceName, {
                    expandApiVersionSet: true,
                })
                    .byPage({ maxPageSize: 100 })), _g; _g = await _f.next(), !_g.done;) {
                    const page = _g.value;
                    for (const item of page) {
                        if (!!resourceId && ((_c = item.apiVersionSet) === null || _c === void 0 ? void 0 : _c.id) === resourceId) {
                            result.push(item);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) await _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_d = this.logger) === null || _d === void 0 ? void 0 : _d.info(log_1.LogMessages.operationSuccess(constants_1.Operation.List, constants_1.AzureResource.API, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, constants_1.Operation.List, constants_1.AzureResource.API, constants_1.OperationStatus.Succeeded);
            return result;
        }
        catch (error) {
            const wrappedError = error_1.BuildError(error_1.ApimOperationError, error, constants_1.Operation.List.displayName, constants_1.AzureResource.API.displayName);
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.warning(log_1.LogMessages.operationFailed(constants_1.Operation.List, constants_1.AzureResource.API, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, constants_1.Operation.List, constants_1.AzureResource.API, constants_1.OperationStatus.Failed, wrappedError);
            throw wrappedError;
        }
    }
    async importApi(resourceGroupName, serviceName, apiId, apiPath, version, versionSetId, oAuthServerId, schemaVersion, spec) {
        const newApi = {
            authenticationSettings: {
                oAuth2: {
                    authorizationServerId: oAuthServerId,
                },
            },
            path: apiPath,
            apiVersion: version,
            apiVersionSetId: `/apiVersionSets/${versionSetId}`,
            format: schemaVersion === constants_1.OpenApiSchemaVersion.V2 ? "swagger-json" : "openapi+json",
            value: JSON.stringify(spec),
            subscriptionRequired: false,
            protocols: ["https"],
        };
        const fn = () => this.apimClient.api.beginCreateOrUpdateAndWait(resourceGroupName, serviceName, apiId, newApi);
        await this.execute(constants_1.Operation.Import, constants_1.AzureResource.API, apiId, fn, validationErrorHandler);
    }
    async getVersionSet(resourceGroupName, serviceName, versionSetId) {
        const fn = () => this.apimClient.apiVersionSet.get(resourceGroupName, serviceName, versionSetId);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.VersionSet, versionSetId, fn, resourceNotFoundErrorHandler);
    }
    async createVersionSet(resourceGroupName, serviceName, versionSetId, versionSetName) {
        const originVersionSet = await this.getVersionSet(resourceGroupName, serviceName, versionSetId);
        if (originVersionSet) {
            return;
        }
        const newVersionSet = {
            displayName: versionSetName !== null && versionSetName !== void 0 ? versionSetName : versionSetId,
            versioningScheme: "Segment",
        };
        const fn = () => this.apimClient.apiVersionSet.createOrUpdate(resourceGroupName, serviceName, versionSetId, newVersionSet);
        await this.execute(constants_1.Operation.Create, constants_1.AzureResource.VersionSet, versionSetId, fn);
    }
    async checkProductApiExistence(resourceGroupName, serviceName, productId, apiId) {
        const fn = () => this.apimClient.productApi.checkEntityExists(resourceGroupName, serviceName, productId, apiId);
        const id = `${productId} - ${apiId}`;
        return !!(await this.execute(constants_1.Operation.Get, constants_1.AzureResource.ProductAPI, id, fn, productApiNotFoundErrorHandler));
    }
    async addApiToProduct(resourceGroupName, serviceName, productId, apiId) {
        const existence = await this.checkProductApiExistence(resourceGroupName, serviceName, productId, apiId);
        if (existence) {
            return;
        }
        const fn = () => this.apimClient.productApi.createOrUpdate(resourceGroupName, serviceName, productId, apiId);
        const id = `${productId} - ${apiId}`;
        await this.execute(constants_1.Operation.Create, constants_1.AzureResource.ProductAPI, id, fn, validationErrorHandler);
    }
    async getUserId() {
        // Related to CI/CD test, use service principle to login TeamsFx CLI
        // TODO: fix to get the user id from credential
        // const token = (await this.credential?.getToken(ApimScopes))?.token;
        // const tokenJson = token ? (ConvertTokenToJson(token) as any) : undefined;
        // if (!tokenJson?.userId) {
        //   this.logger?.warning(LogMessages.useDefaultUserId);
        //   return ApimDefaultValues.userId;
        // } else {
        //   return tokenJson.userId;
        // }
        return constants_1.ApimDefaultValues.userId;
    }
    async execute(operation, resourceType, resourceId, fn, errorHandler) {
        var _a, _b, _c, _d, _e;
        try {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(log_1.LogMessages.operationStarts(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Started);
            const result = await fn();
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(log_1.LogMessages.operationSuccess(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Succeeded);
            return result;
        }
        catch (error) {
            if (!!errorHandler && errorHandler(error) === constants_1.ErrorHandlerResult.Return) {
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(log_1.LogMessages.operationSuccess(operation, resourceType, resourceId));
                telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Succeeded);
                if (operation === constants_1.Operation.Get) {
                    (_d = this.logger) === null || _d === void 0 ? void 0 : _d.info(log_1.LogMessages.resourceNotFound(resourceType, resourceId));
                }
                return undefined;
            }
            const wrappedError = error_1.BuildError(error_1.ApimOperationError, error, operation.displayName, resourceType.displayName);
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.warning(log_1.LogMessages.operationFailed(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Failed, wrappedError);
            throw wrappedError;
        }
    }
    generateVersionSetResourceId(subscriptionId, resourceGroupName, serviceName, versionSetId) {
        return `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}/providers/Microsoft.ApiManagement/service/${serviceName}/apiVersionSets/${versionSetId}`;
    }
}
exports.ApimService = ApimService;
function resourceNotFoundErrorHandler(error) {
    if ("code" in error) {
        if (error.code === "ResourceNotFound") {
            return constants_1.ErrorHandlerResult.Return;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
function productApiNotFoundErrorHandler(error) {
    if ("statusCode" in error) {
        if (error.statusCode === 404) {
            return constants_1.ErrorHandlerResult.Return;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
function validationErrorHandler(error) {
    if ("code" in error) {
        if (error.code === "ValidationError") {
            if (error.body.details instanceof Array) {
                for (const detailError of error.body.details) {
                    if (detailError.message) {
                        error.message += ` [Detail] ${detailError.message}`;
                    }
                }
            }
        }
        else if (typeof error.body === "string") {
            error.message += `[Detail] ${error.body}.`;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
//# sourceMappingURL=apimService.js.map