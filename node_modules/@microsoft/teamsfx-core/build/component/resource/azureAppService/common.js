"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipFolderAsync = void 0;
const tslib_1 = require("tslib");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const fs = tslib_1.__importStar(require("fs-extra"));
const dir_walk_1 = require("./dir-walk");
const path_1 = tslib_1.__importDefault(require("path"));
const hostingConstant_1 = require("../../../common/azure-hosting/hostingConstant");
/**
 * Asynchronously zip a folder and return buffer
 * @param sourceDir base dir
 * @param notIncluded block list
 * @param cache zip cache file location
 */
async function zipFolderAsync(sourceDir, cache, notIncluded) {
    const normalizeTime = (t) => Math.floor(t / hostingConstant_1.AzureOperationCommonConstants.zipTimeMSGranularity);
    const tasks = [];
    const zipFiles = new Set();
    const ig = notIncluded !== null && notIncluded !== void 0 ? notIncluded : ignore_1.default();
    const zip = (await readZipFromCache(cache)) || new adm_zip_1.default();
    const addFileIntoZip = async (zp, filePath, zipPath, stats) => {
        const content = await fs.readFile(filePath);
        zp.addFile(zipPath, content);
        if (stats) {
            zp.getEntry(zipPath).header.time = stats.mtime;
        }
    };
    await dir_walk_1.forEachFileAndDir(sourceDir, (itemPath, stats) => {
        const relativePath = path_1.default.relative(sourceDir, itemPath);
        if (relativePath && !stats.isDirectory() && ig.filter([relativePath]).length > 0) {
            zipFiles.add(relativePath);
            const entry = zip.getEntry(relativePath);
            if (entry) {
                // The header is an object, the ts declare of adm-zip is wrong.
                const header = entry.header;
                const mtime = header && header.time;
                // Some files' mtime in node_modules are too old, which may be invalid,
                // so we arbitrarily add a limitation to update this kind of files.
                // If mtime is valid and the two mtime is same in two-seconds, we think the two are same file.
                if (mtime >= hostingConstant_1.AzureOperationCommonConstants.latestTrustMtime &&
                    normalizeTime(mtime.getTime()) === normalizeTime(stats.mtime.getTime())) {
                    return;
                }
                // Delete the entry because the file has been updated.
                zip.deleteFile(relativePath);
            }
            // If fail to reuse cached entry, load it from disk.
            const fullPath = path_1.default.join(sourceDir, relativePath);
            const task = addFileIntoZip(zip, fullPath, relativePath, stats);
            tasks.push(task);
        }
    });
    await Promise.all(tasks);
    removeLegacyFileInZip(zip, zipFiles);
    return zip.toBuffer();
}
exports.zipFolderAsync = zipFolderAsync;
async function readZipFromCache(cache) {
    try {
        const content = await fs.readFile(cache);
        return new adm_zip_1.default(content);
    }
    catch (_a) {
        // Failed to load cache, it doesn't block deployment.
    }
    return undefined;
}
function removeLegacyFileInZip(zip, existenceFiles) {
    zip
        .getEntries()
        .filter((entry) => !existenceFiles.has(entry.name))
        .forEach((entry) => {
        zip.deleteFile(entry.name);
    });
}
//# sourceMappingURL=common.js.map