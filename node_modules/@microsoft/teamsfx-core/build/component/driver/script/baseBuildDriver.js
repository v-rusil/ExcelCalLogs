"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseBuildDriver = void 0;
const tslib_1 = require("tslib");
const common_1 = require("../../utils/common");
const utils_1 = require("../../code/utils");
const componentError_1 = require("../../error/componentError");
const deployConstant_1 = require("../../constant/deployConstant");
const path = tslib_1.__importStar(require("path"));
class BaseBuildDriver {
    constructor(args, context, helpLink) {
        var _a;
        this.progressBarSteps = 1;
        this.args = BaseBuildDriver.toBuildArgs(args, helpLink);
        this.args.workingDirectory = (_a = this.args.workingDirectory) !== null && _a !== void 0 ? _a : "./";
        // if working dir is not absolute path, then join the path with project path
        this.workingDirectory = path.isAbsolute(this.args.workingDirectory)
            ? this.args.workingDirectory
            : path.join(context.projectPath, this.args.workingDirectory);
        this.progressBarName = `Building project ${this.workingDirectory}`;
        this.logProvider = context.logProvider;
        this.telemetryReporter = context.telemetryReporter;
        this.context = context;
        this.execPath = this.args.execPath;
    }
    static toBuildArgs(args, helpLink) {
        return BaseBuildDriver.asBuildArgs(args, helpLink);
    }
    async run() {
        var _a, _b, _c, _d, _e;
        this.progressBar = (_a = this.context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(this.progressBarName, this.progressBarSteps);
        const command = this.getCommand();
        await ((_b = this.progressBar) === null || _b === void 0 ? void 0 : _b.start());
        // add path to env if execPath is set
        let env = undefined;
        if (this.execPath) {
            env = { PATH: `${this.execPath}${path.delimiter}${process.env.PATH}` };
        }
        await ((_c = this.progressBar) === null || _c === void 0 ? void 0 : _c.next(`Run command ${command} at ${this.workingDirectory}`));
        try {
            const output = await utils_1.execute(command, this.workingDirectory, this.logProvider, env);
            await this.logProvider.debug(`execute ${command} output is ${output}`);
            await ((_d = this.progressBar) === null || _d === void 0 ? void 0 : _d.end(true));
        }
        catch (e) {
            throw componentError_1.ExecuteCommandError.fromErrorOutput(deployConstant_1.DeployConstant.DEPLOY_ERROR_TYPE, [command, (_e = this.workingDirectory) !== null && _e !== void 0 ? _e : ""], e);
        }
        return BaseBuildDriver.emptyMap;
    }
    getCommand() {
        const commandSuffix = common_1.checkMissingArgs("BuildCommand", this.args.args).trim();
        return `${this.buildPrefix} ${commandSuffix}`;
    }
    /**
     * call when error happens
     * do some resource clean up
     */
    async cleanup() {
        var _a;
        await ((_a = this.progressBar) === null || _a === void 0 ? void 0 : _a.end(false));
    }
}
exports.BaseBuildDriver = BaseBuildDriver;
BaseBuildDriver.emptyMap = new Map();
BaseBuildDriver.asBuildArgs = common_1.asFactory({
    workingDirectory: common_1.asOptional(common_1.asString),
    args: common_1.asString,
    execPath: common_1.asOptional(common_1.asString),
});
//# sourceMappingURL=baseBuildDriver.js.map