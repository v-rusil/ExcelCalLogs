"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateEnvDriver = void 0;
const tslib_1 = require("tslib");
const dotenv = tslib_1.__importStar(require("dotenv"));
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const constants_1 = require("../aad/utility/constants");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const invalidParameterUserError_1 = require("./error/invalidParameterUserError");
const unhandledError_1 = require("./error/unhandledError");
const actionName = "file/updateEnv";
const helpLink = "https://aka.ms/teamsfx-actions/file-updateEnv";
let UpdateEnvDriver = class UpdateEnvDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.file.description");
    }
    async run(args, context) {
        return common_1.wrapRun(async () => {
            const result = await this.handler(args, context);
            return result.output;
        });
    }
    async execute(args, ctx) {
        let summaries = [];
        const outputResult = await common_1.wrapRun(async () => {
            const result = await this.handler(args, ctx);
            summaries = result.summaries;
            return result.output;
        });
        return {
            result: outputResult,
            summaries,
        };
    }
    async handler(args, context) {
        var _a, _b, _c;
        const progressHandler = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("driver.file.progressBar.title"), 1);
        try {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.start());
            this.validateArgs(args);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("driver.file.progressBar.generate")));
            if (args.target) {
                const target = this.getAbsolutePath(args.target, context.projectPath);
                await fs.ensureFile(target);
                const envs = dotenv.parse(await fs.readFile(target));
                const content = Object.entries(Object.assign(Object.assign({}, envs), args.envs))
                    .map(([key, value]) => `${key}=${value}`)
                    .join(os.EOL);
                await fs.writeFile(target, content);
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
                return {
                    output: new Map(),
                    summaries: [localizeUtils_1.getLocalizedString("driver.file.summary.withTarget", path.normalize(target))],
                };
            }
            else {
                const state = this.loadCurrentState();
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
                return {
                    output: new Map(Object.entries(args.envs)),
                    summaries: [localizeUtils_1.getLocalizedString("driver.file.summary.default", state.TEAMSFX_ENV)],
                };
            }
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, error.displayMessage));
                throw error;
            }
            const message = JSON.stringify(error);
            (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
            throw new unhandledError_1.UnhandledSystemError(actionName, message);
        }
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (args.target !== undefined &&
            (typeof args.target !== "string" || args.target.length === 0)) {
            invalidParameters.push("target");
        }
        if (!args.envs || typeof args.envs !== "object") {
            invalidParameters.push("envs");
        }
        else {
            for (const value of Object.values(args.envs)) {
                if (!value || typeof value === "object") {
                    invalidParameters.push("envs");
                }
            }
        }
        if (invalidParameters.length > 0) {
            throw new invalidParameterUserError_1.InvalidParameterUserError(actionName, invalidParameters, helpLink);
        }
    }
    getAbsolutePath(relativeOrAbsolutePath, projectPath) {
        return path.isAbsolute(relativeOrAbsolutePath)
            ? relativeOrAbsolutePath
            : path.join(projectPath, relativeOrAbsolutePath);
    }
    loadCurrentState() {
        return {
            TEAMSFX_ENV: process.env.TEAMSFX_ENV,
        };
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], UpdateEnvDriver.prototype, "run", null);
UpdateEnvDriver = tslib_1.__decorate([
    typedi_1.Service(actionName) // DO NOT MODIFY the service name
], UpdateEnvDriver);
exports.UpdateEnvDriver = UpdateEnvDriver;
//# sourceMappingURL=updateEnv.js.map