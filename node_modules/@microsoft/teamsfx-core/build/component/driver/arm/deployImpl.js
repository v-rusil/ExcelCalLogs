"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArmDeployImpl = void 0;
const tslib_1 = require("tslib");
const constant_1 = require("./constant");
const validator_1 = require("./validator");
const util_1 = require("./util/util");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../../common/constants");
const fs = tslib_1.__importStar(require("fs-extra"));
const common_1 = require("../../utils/common");
const cpUtils_1 = require("../../../common/cpUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const arm_resources_1 = require("@azure/arm-resources");
const constants_2 = require("../../constants");
const invalidParameterUserError_1 = require("../aad/error/invalidParameterUserError");
const bicepChecker_1 = require("../../utils/depsChecker/bicepChecker");
const arm_1 = require("../../arm");
const helpLink = "https://aka.ms/teamsfx-actions/arm-deploy";
class ArmDeployImpl {
    constructor(args, context) {
        this.args = args;
        this.context = context;
    }
    async run() {
        await this.validateArgs();
        await this.createClient();
        const needBicepCli = util_1.hasBicepTemplate(this.args.templates);
        if (needBicepCli) {
            this.bicepCommand = await this.ensureBicepCli();
        }
        const deployRes = await this.deployTemplates();
        if (deployRes.isOk()) {
            const outputs = deployRes.value;
            return util_1.convertOutputs(outputs);
        }
        else {
            throw deployRes.error;
        }
    }
    async validateArgs() {
        const invalidParameters = await validator_1.validateArgs(this.args);
        if (invalidParameters.length > 0) {
            throw new invalidParameterUserError_1.InvalidParameterUserError(constant_1.Constants.actionName, invalidParameters, helpLink);
        }
    }
    async ensureBicepCli() {
        return await bicepChecker_1.ensureBicepForDriver(this.context, this.args.bicepCliVersion);
    }
    async createClient() {
        const azureToken = await this.context.azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken) {
            throw new teamsfx_api_1.SystemError(constants_1.PluginDisplayName.Solution, constants_2.SolutionError.FailedToGetAzureCredential, localizeUtils_1.getDefaultString("core.deployArmTemplates.InvalidAzureCredential"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.InvalidAzureCredential"));
        }
        this.client = new arm_resources_1.ResourceManagementClient(azureToken, this.args.subscriptionId);
    }
    async deployTemplates() {
        const outputs = [];
        this.setTelemetries();
        await Promise.all(this.args.templates.map(async (template) => {
            const res = await this.deployTemplate(template);
            if (res.isOk() && res.value) {
                this.context.addSummary(localizeUtils_1.getLocalizedString("core.deployArmTemplates.ActionSuccess", this.args.resourceGroupName, template.deploymentName));
                outputs.push(res.value);
            }
            else if (res.isErr()) {
                throw res.error;
            }
        }));
        return teamsfx_api_1.ok(outputs);
    }
    async deployTemplate(templateArg) {
        const deployCtx = {
            ctx: this.context,
            finished: false,
            deploymentStartTime: Date.now(),
            client: this.client,
            resourceGroupName: this.args.resourceGroupName,
            deploymentName: templateArg.deploymentName,
        };
        try {
            const progressBar = await this.context.createProgressBar(`Deploy arm: ${templateArg.deploymentName}`, 1);
            const parameters = await this.getDeployParameters(templateArg.parameters);
            const template = await this.getDeployTemplate(templateArg.path);
            const deploymentParameters = {
                properties: {
                    parameters: parameters ? parameters.parameters : null,
                    template: template,
                    mode: "Incremental",
                },
            };
            const res = await this.executeDeployment(templateArg, deploymentParameters, deployCtx);
            progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(res.isOk() ? true : false);
            return res;
        }
        catch (error) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                error,
                source: constants_2.SolutionSource,
                name: constants_2.SolutionError.FailedToDeployArmTemplatesToAzure,
            }));
        }
    }
    async executeDeployment(templateArg, deploymentParameters, deployCtx) {
        try {
            return await this.innerExecuteDeployment(templateArg, deploymentParameters);
        }
        catch (error) {
            const errRes = arm_1.handleArmDeploymentError(error, deployCtx);
            return errRes;
        }
    }
    async innerExecuteDeployment(templateArg, deploymentParameters) {
        var _a, _b;
        const result = await ((_a = this.client) === null || _a === void 0 ? void 0 : _a.deployments.beginCreateOrUpdateAndWait(this.args.resourceGroupName, templateArg.deploymentName, deploymentParameters));
        return teamsfx_api_1.ok((_b = result === null || result === void 0 ? void 0 : result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
    }
    async getDeployParameters(parameters) {
        if (!parameters) {
            return null;
        }
        const filePath = common_1.getAbsolutePath(parameters, this.context.projectPath);
        const template = await fs.readFile(filePath, constants_1.ConstantString.UTF8Encoding);
        const parameterJsonString = common_1.expandEnvironmentVariable(template);
        return JSON.parse(parameterJsonString);
    }
    async getDeployTemplate(templatePath) {
        const templateType = util_1.getFileExtension(templatePath);
        const filePath = common_1.getAbsolutePath(templatePath, this.context.projectPath);
        let templateJsonString;
        if (templateType === constant_1.TemplateType.Bicep) {
            templateJsonString = await this.compileBicepToJson(filePath);
        }
        else {
            const template = await fs.readFile(filePath, constants_1.ConstantString.UTF8Encoding);
            templateJsonString = JSON.parse(template);
        }
        return templateJsonString;
    }
    async compileBicepToJson(filePath) {
        try {
            const result = await cpUtils_1.executeCommand(this.bicepCommand, ["build", filePath, "--stdout"], this.context.logProvider, { shell: false });
            return JSON.parse(result);
        }
        catch (err) {
            throw new Error(localizeUtils_1.getDefaultString("driver.arm.error.CompileBicepFailed", err.message));
        }
    }
    setTelemetries() {
        let bicepCount = 0;
        let jsonCount = 0;
        for (const template of this.args.templates) {
            const templateType = util_1.getFileExtension(template.path);
            if (templateType === constant_1.TemplateType.Bicep) {
                bicepCount++;
            }
            else {
                jsonCount++;
            }
        }
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.bicepTemplateCount]: bicepCount.toString(),
            [constant_1.TelemetryProperties.jsonTemplateCount]: jsonCount.toString(),
        });
    }
}
exports.ArmDeployImpl = ArmDeployImpl;
//# sourceMappingURL=deployImpl.js.map