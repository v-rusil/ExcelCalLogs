"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishAppPackageDriver = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const lib_1 = require("@feathersjs/hooks/lib");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const appStudioClient_1 = require("../../resource/appManifest/appStudioClient");
const constants_1 = require("../../resource/appManifest/constants");
const results_1 = require("../../resource/appManifest/results");
const telemetry_1 = require("../../resource/appManifest/utils/telemetry");
const errors_1 = require("../../resource/appManifest/errors");
const telemetry_2 = require("../../resource/appManifest/utils/telemetry");
const tools_1 = require("../../../common/tools");
const localizeUtils_1 = require("../../../common/localizeUtils");
const typedi_1 = require("typedi");
const common_1 = require("../../utils/common");
const actionName = "teamsApp/publishAppPackage";
const outputKeys = {
    publishedAppId: "TEAMS_APP_PUBLISHED_APP_ID",
};
let PublishAppPackageDriver = class PublishAppPackageDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.teamsApp.description.publishDriver");
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.publish(args, wrapContext);
        console.log("Summaries");
        wrapContext.summaries.forEach((value) => console.log(value));
        return res;
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.publish(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async publish(args, context) {
        var _a, _b, _c, _d, _e;
        telemetry_1.TelemetryUtils.init(context);
        const argsValidationResult = this.validateArgs(args);
        if (argsValidationResult.isErr()) {
            return teamsfx_api_1.err(argsValidationResult.error);
        }
        const progressHandler = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppTitle"), 2);
        progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.start();
        const appPackagePath = common_1.getAbsolutePath(args.appPackagePath, context.projectPath);
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(args.appPackagePath), "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE), "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        // manifest.id === externalID
        const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
            scopes: tools_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        let result;
        const telemetryProps = {};
        const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep1");
        progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(message);
        context.addSummary(message);
        const existApp = await appStudioClient_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioTokenRes.value);
        if (existApp) {
            context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppExists", manifest.id));
            let executePublishUpdate = false;
            let description = localizeUtils_1.getLocalizedString("plugins.appstudio.pubWarn", existApp.displayName, existApp.publishingState);
            if (existApp.lastModifiedDateTime) {
                description =
                    description +
                        localizeUtils_1.getLocalizedString("plugins.appstudio.lastModified", (_b = existApp.lastModifiedDateTime) === null || _b === void 0 ? void 0 : _b.toLocaleString());
            }
            description = description + localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublihsedAppConfirm");
            const confirm = localizeUtils_1.getLocalizedString("core.option.confirm");
            const res = await ((_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("warn", description, true, confirm));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === confirm)
                executePublishUpdate = true;
            if (executePublishUpdate) {
                const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep2.1");
                progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(message);
                context.addSummary(message);
                const appId = await appStudioClient_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioTokenRes.value);
                result = new Map([[outputKeys.publishedAppId, appId]]);
                // TODO: how to send telemetry with own properties
                telemetryProps[telemetry_2.TelemetryPropertyKey.updateExistingApp] = "true";
            }
            else {
                progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true);
                return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
            }
        }
        else {
            context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppNotExists", manifest.id));
            const message = localizeUtils_1.getLocalizedString("driver.teamsApp.progressBar.publishTeamsAppStep2.2");
            progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(message);
            context.addSummary(message);
            const appId = await appStudioClient_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioTokenRes.value);
            result = new Map([[outputKeys.publishedAppId, appId]]);
            telemetryProps[telemetry_2.TelemetryPropertyKey.updateExistingApp] = "false";
        }
        progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true);
        context.logProvider.info(`Publish success!`);
        context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.publishTeamsAppSuccess", manifest.id));
        if (context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice.cli", manifest.name.short, constants_1.Constants.TEAMS_ADMIN_PORTAL, constants_1.Constants.TEAMS_MANAGE_APP_DOC);
            (_d = context.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
        }
        else {
            const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice", manifest.name.short, constants_1.Constants.TEAMS_MANAGE_APP_DOC);
            const adminPortal = localizeUtils_1.getLocalizedString("plugins.appstudio.adminPortal");
            (_e = context.ui) === null || _e === void 0 ? void 0 : _e.showMessage("info", msg, false, adminPortal).then((value) => {
                var _a;
                if (value.isOk() && value.value === adminPortal) {
                    (_a = context.ui) === null || _a === void 0 ? void 0 : _a.openUrl(constants_1.Constants.TEAMS_ADMIN_PORTAL);
                }
            });
        }
        return teamsfx_api_1.ok(result);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.appPackagePath) {
            invalidParams.push("appPackagePath");
        }
        if (invalidParams.length > 0) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidParameterError.name, errors_1.AppStudioError.InvalidParameterError.message(actionName, invalidParams), "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], PublishAppPackageDriver.prototype, "publish", null);
PublishAppPackageDriver = tslib_1.__decorate([
    typedi_1.Service(actionName)
], PublishAppPackageDriver);
exports.PublishAppPackageDriver = PublishAppPackageDriver;
//# sourceMappingURL=publishAppPackage.js.map