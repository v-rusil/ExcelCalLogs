"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyAppPackageToSPFxDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../resource/appManifest/constants");
const errors_1 = require("../../resource/appManifest/errors");
const results_1 = require("../../resource/appManifest/results");
const common_1 = require("../../utils/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const actionName = "teamsApp/copyAppPackageToSPFx";
let copyAppPackageToSPFxDriver = class copyAppPackageToSPFxDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.teamsApp.description.copyAppPackageToSPFxDriver");
        this.EmptyMap = new Map();
        this.asCopyAppPackageArgs = common_1.asFactory({
            appPackagePath: common_1.asString,
            spfxFolder: common_1.asString,
        });
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        return common_1.wrapRun(() => this.copy(args, wrapContext));
    }
    async execute(args, ctx) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(ctx, actionName, actionName);
        const result = await this.run(args, wrapContext);
        return {
            result,
            summaries: wrapContext.summaries,
        };
    }
    async copy(args, context) {
        const copyAppPackageArgs = this.asCopyAppPackageArgs(args);
        const appPackagePath = path_1.default.isAbsolute(copyAppPackageArgs.appPackagePath)
            ? copyAppPackageArgs.appPackagePath
            : path_1.default.join(context.projectPath, copyAppPackageArgs.appPackagePath);
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(appPackagePath));
        }
        const pictures = await this.getIcons(appPackagePath);
        const spfxFolder = path_1.default.isAbsolute(copyAppPackageArgs.spfxFolder)
            ? copyAppPackageArgs.spfxFolder
            : path_1.default.join(context.projectPath, copyAppPackageArgs.spfxFolder);
        const spfxTeamsPath = `${spfxFolder}/teams`;
        await fs_extra_1.default.copyFile(appPackagePath, path_1.default.join(spfxTeamsPath, "TeamsSPFxApp.zip"));
        context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.copyAppPackageSuccess", appPackagePath, path_1.default.join(spfxTeamsPath, "TeamsSPFxApp.zip")));
        let replacedIcons = 0;
        for (const file of await fs_extra_1.default.readdir(spfxTeamsPath)) {
            if (file.endsWith("color.png") && pictures.color) {
                await fs_extra_1.default.writeFile(path_1.default.join(spfxTeamsPath, file), pictures.color);
                replacedIcons++;
            }
            else if (file.endsWith("outline.png") && pictures.outline) {
                await fs_extra_1.default.writeFile(path_1.default.join(spfxTeamsPath, file), pictures.outline);
                replacedIcons++;
            }
        }
        if (replacedIcons > 0) {
            context.addSummary(localizeUtils_1.getLocalizedString("driver.teamsApp.summary.copyIconSuccess", replacedIcons, spfxTeamsPath));
        }
        return this.EmptyMap;
    }
    async getIcons(appPackagePath) {
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        const colorFile = manifest.icons.color && !manifest.icons.color.startsWith("https://")
            ? zipEntries.find((x) => x.entryName.includes("color.png"))
            : undefined;
        const outlineFile = manifest.icons.outline && !manifest.icons.outline.startsWith("https://")
            ? zipEntries.find((x) => x.entryName.includes("outline.png"))
            : undefined;
        return { color: colorFile === null || colorFile === void 0 ? void 0 : colorFile.getData(), outline: outlineFile === null || outlineFile === void 0 ? void 0 : outlineFile.getData() };
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], copyAppPackageToSPFxDriver.prototype, "run", null);
copyAppPackageToSPFxDriver = tslib_1.__decorate([
    typedi_1.Service(actionName)
], copyAppPackageToSPFxDriver);
exports.copyAppPackageToSPFxDriver = copyAppPackageToSPFxDriver;
//# sourceMappingURL=copyAppPackageToSPFx.js.map