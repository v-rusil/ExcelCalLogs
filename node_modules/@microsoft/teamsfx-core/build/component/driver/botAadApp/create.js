"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateBotAadAppDriver = void 0;
const tslib_1 = require("tslib");
const typedi_1 = require("typedi");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const timer_1 = tslib_1.__importDefault(require("@dbpiper/timer"));
const invalidParameterUserError_1 = require("./error/invalidParameterUserError");
const unhandledError_1 = require("./error/unhandledError");
const axios_1 = tslib_1.__importDefault(require("axios"));
const common_1 = require("../../utils/common");
const remoteBotRegistration_1 = require("../../resource/botService/botRegistration/remoteBotRegistration");
const lib_1 = require("@feathersjs/hooks/lib");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const constants_1 = require("./utility/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_2 = require("../../resource/botService/botRegistration/constants");
const actionName = "botAadApp/create"; // DO NOT MODIFY the name
const helpLink = "https://aka.ms/teamsfx-actions/botaadapp-create";
const successRegisterBotAad = `${actionName}/success`;
const propertyKeys = {
    reusingExistingBotAad: "reuse-existing-bot-aad",
    registerBotAadTime: "register-bot-aad-time",
};
let CreateBotAadAppDriver = class CreateBotAadAppDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.botAadApp.create.description");
    }
    async run(args, context) {
        return common_1.wrapRun(async () => {
            const result = await this.handler(args, context);
            return result.output;
        });
    }
    async execute(args, ctx) {
        let summaries = [];
        const outputResult = await common_1.wrapRun(async () => {
            const result = await this.handler(args, ctx);
            summaries = result.summaries;
            return result.output;
        });
        return {
            result: outputResult,
            summaries,
        };
    }
    async handler(args, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const progressHandler = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString(constants_2.progressBarKeys.creatingBotAadApp), 1);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.start());
        try {
            (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.startExecuteDriver, actionName));
            this.validateArgs(args);
            const botAadAppState = this.loadCurrentState();
            const botConfig = {
                botId: (_c = botAadAppState.BOT_ID) !== null && _c !== void 0 ? _c : "",
                botPassword: (_d = botAadAppState.SECRET_BOT_PASSWORD) !== null && _d !== void 0 ? _d : "",
            };
            const botRegistration = new remoteBotRegistration_1.RemoteBotRegistration();
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString(constants_2.progressBarKeys.creatingBotAadApp)));
            const timer = new timer_1.default();
            timer.start();
            const createRes = await botRegistration.createBotRegistration(context.m365TokenProvider, args.name, args.name, botConfig, context.logProvider);
            const timeResult = timer.stop();
            if (createRes.isErr()) {
                throw createRes.error;
            }
            const isReusingExisting = botConfig.botId && botConfig.botPassword;
            const successCreateBotAadLog = localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.successCreateBotAad, createRes.value.botId);
            const useExistingBotAadLog = localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.useExistingBotAad, botConfig.botId);
            const summary = isReusingExisting ? useExistingBotAadLog : successCreateBotAadLog;
            (_e = context.logProvider) === null || _e === void 0 ? void 0 : _e.info(summary);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            (_f = context.logProvider) === null || _f === void 0 ? void 0 : _f.info(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.successExecuteDriver, actionName));
            context.telemetryReporter.sendTelemetryEvent(successRegisterBotAad, {
                [propertyKeys.reusingExistingBotAad]: isReusingExisting,
                [propertyKeys.registerBotAadTime]: timeResult.milliseconds.toString(),
            });
            return {
                output: new Map([
                    ["BOT_ID", createRes.value.botId],
                    ["SECRET_BOT_PASSWORD", createRes.value.botPassword],
                ]),
                summaries: [summary],
            };
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                (_g = context.logProvider) === null || _g === void 0 ? void 0 : _g.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, error.displayMessage));
                throw error;
            }
            if (axios_1.default.isAxiosError(error)) {
                const message = JSON.stringify((_h = error.response) === null || _h === void 0 ? void 0 : _h.data);
                (_j = context.logProvider) === null || _j === void 0 ? void 0 : _j.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
                if (error.response.status >= 400 && error.response.status < 500) {
                    throw new unhandledError_1.UnhandledUserError(actionName, JSON.stringify(error.response.data), helpLink);
                }
                else {
                    throw new unhandledError_1.UnhandledSystemError(actionName, JSON.stringify(error.response.data));
                }
            }
            const message = JSON.stringify(error);
            (_k = context.logProvider) === null || _k === void 0 ? void 0 : _k.error(localizeUtils_1.getLocalizedString(constants_1.logMessageKeys.failExecuteDriver, actionName, message));
            throw new unhandledError_1.UnhandledSystemError(actionName, JSON.stringify(error));
        }
    }
    validateArgs(args) {
        const invalidParameters = [];
        if (typeof args.name !== "string" || !args.name) {
            invalidParameters.push("name");
        }
        if (invalidParameters.length > 0) {
            throw new invalidParameterUserError_1.InvalidParameterUserError(actionName, invalidParameters, helpLink);
        }
    }
    loadCurrentState() {
        return {
            BOT_ID: process.env.BOT_ID,
            SECRET_BOT_PASSWORD: process.env.SECRET_BOT_PASSWORD,
        };
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateBotAadAppDriver.prototype, "run", null);
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateBotAadAppDriver.prototype, "execute", null);
CreateBotAadAppDriver = tslib_1.__decorate([
    typedi_1.Service(actionName) // DO NOT MODIFY the service name
], CreateBotAadAppDriver);
exports.CreateBotAadAppDriver = CreateBotAadAppDriver;
//# sourceMappingURL=create.js.map