"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseDeployImpl = void 0;
const tslib_1 = require("tslib");
const componentError_1 = require("../../../../error/componentError");
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const deployConstant_1 = require("../../../../constant/deployConstant");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const fileOperation_1 = require("../../../../utils/fileOperation");
const common_1 = require("../../../../utils/common");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
class BaseDeployImpl {
    constructor(args, context) {
        this.dryRun = false;
        this.helpLink = undefined;
        this.progressPrepare = [];
        this.args = args;
        this.workingDirectory = context.projectPath;
        this.distDirectory = "";
        this.ui = context.ui;
        this.context = {
            azureAccountProvider: context.azureAccountProvider,
            progressBar: this.progressBar,
            logProvider: context.logProvider,
            telemetryReporter: context.telemetryReporter,
        };
    }
    async run() {
        await this.context.logProvider.debug("start deploy process");
        return await this.wrapErrorHandler(async () => {
            var _a, _b;
            const deployArgs = BaseDeployImpl.asDeployArgs(this.args, this.helpLink);
            // if working directory not set, use current working directory
            deployArgs.workingDirectory = (_a = deployArgs.workingDirectory) !== null && _a !== void 0 ? _a : "./";
            // if working dir is not absolute path, then join the path with project path
            this.workingDirectory = this.handlePath(deployArgs.workingDirectory, this.workingDirectory);
            // if distribution path is not absolute path, then join the path with project path
            this.distDirectory = this.handlePath(deployArgs.distributionPath, this.workingDirectory);
            this.dryRun = (_b = deployArgs.dryRun) !== null && _b !== void 0 ? _b : false;
            // call real deploy
            return await this.deploy(deployArgs);
        });
    }
    handlePath(inputPath, baseFolder) {
        return path.isAbsolute(inputPath) ? inputPath : path.join(baseFolder, inputPath);
    }
    /**
     * pack dist folder into zip
     * @param args dist folder and ignore files
     * @param context log provider etc..
     * @protected
     */
    async packageToZip(args, context) {
        var _a, _b;
        const ig = await this.handleIgnore(args, context);
        const zipFilePath = path.join(this.workingDirectory, deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER, deployConstant_1.DeployConstant.DEPLOYMENT_ZIP_CACHE_FILE);
        await ((_a = this.context.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`start zip dist folder ${this.distDirectory}`));
        const res = await fileOperation_1.zipFolderAsync(this.distDirectory, zipFilePath, ig);
        await ((_b = this.context.logProvider) === null || _b === void 0 ? void 0 : _b.debug(`zip dist folder ${this.distDirectory} to ${zipFilePath} complete`));
        return res;
    }
    async handleIgnore(args, context) {
        // always add deploy temp folder into ignore list
        const ig = ignore_1.default().add(deployConstant_1.DeployConstant.DEPLOYMENT_TMP_FOLDER);
        if (args.ignoreFile) {
            const ignoreFilePath = path.join(this.workingDirectory, args.ignoreFile);
            if (await fs.pathExists(ignoreFilePath)) {
                const ignoreFileContent = await fs.readFile(ignoreFilePath);
                ignoreFileContent
                    .toString()
                    .split("\n")
                    .map((line) => line.trim())
                    .forEach((it) => {
                    ig.add(it);
                });
            }
            else {
                await context.logProvider.warning(`already set deploy ignore file ${args.ignoreFile} but file not exists in ${this.workingDirectory}, skip ignore!`);
            }
        }
        return ig;
    }
    async wrapErrorHandler(fn) {
        var _a;
        try {
            return (await fn())
                ? { result: teamsfx_api_1.ok(BaseDeployImpl.emptyMap), summaries: this.summaries }
                : { result: teamsfx_api_1.ok(BaseDeployImpl.emptyMap), summaries: this.summaryPrepare };
        }
        catch (e) {
            await ((_a = this.context.progressBar) === null || _a === void 0 ? void 0 : _a.end(false));
            if (e instanceof componentError_1.BaseComponentInnerError) {
                const errorDetail = e.detail ? `Detail: ${e.detail}` : "";
                await this.context.logProvider.error(`${e.message} ${errorDetail}`);
                return { result: teamsfx_api_1.err(e.toFxError()), summaries: [] };
            }
            else {
                await this.context.logProvider.error(`Unknown error: ${e}`);
                return {
                    result: teamsfx_api_1.err(componentError_1.BaseComponentInnerError.unknownError("Deploy", e).toFxError()),
                    summaries: [],
                };
            }
        }
    }
}
exports.BaseDeployImpl = BaseDeployImpl;
BaseDeployImpl.emptyMap = new Map();
BaseDeployImpl.asDeployArgs = common_1.asFactory({
    workingDirectory: common_1.asOptional(common_1.asString),
    distributionPath: common_1.asString,
    ignoreFile: common_1.asOptional(common_1.asString),
    resourceId: common_1.asString,
    dryRun: common_1.asOptional(common_1.asBoolean),
});
//# sourceMappingURL=baseDeployImpl.js.map