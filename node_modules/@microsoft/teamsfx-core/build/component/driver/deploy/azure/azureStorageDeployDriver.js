"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageDeployDriverImpl = exports.AzureStorageDeployDriver = void 0;
const tslib_1 = require("tslib");
const azureDeployImpl_1 = require("./impl/azureDeployImpl");
const deployConstant_1 = require("../../../constant/deployConstant");
const deployError_1 = require("../../../error/deployError");
const fileOperation_1 = require("../../../utils/fileOperation");
const path_1 = tslib_1.__importDefault(require("path"));
const mime = tslib_1.__importStar(require("mime"));
const typedi_1 = require("typedi");
const azureResourceOperation_1 = require("../../../utils/azureResourceOperation");
const hooks_1 = require("@feathersjs/hooks");
const addStartAndEndTelemetry_1 = require("../../middleware/addStartAndEndTelemetry");
const commonConstant_1 = require("../../../constant/commonConstant");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const progressBarHelper_1 = require("./impl/progressBarHelper");
const ACTION_NAME = "azureStorage/deploy";
let AzureStorageDeployDriver = class AzureStorageDeployDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.deploy.deployToAzureStorageDescription");
    }
    async run(args, context) {
        const impl = new AzureStorageDeployDriverImpl(args, context);
        return (await impl.run()).result;
    }
    execute(args, ctx) {
        const impl = new AzureStorageDeployDriverImpl(args, ctx);
        return impl.run();
    }
};
tslib_1.__decorate([
    hooks_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, commonConstant_1.TelemetryConstant.DEPLOY_COMPONENT_NAME)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageDeployDriver.prototype, "run", null);
tslib_1.__decorate([
    hooks_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, commonConstant_1.TelemetryConstant.DEPLOY_COMPONENT_NAME)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageDeployDriver.prototype, "execute", null);
AzureStorageDeployDriver = tslib_1.__decorate([
    typedi_1.Service(ACTION_NAME)
], AzureStorageDeployDriver);
exports.AzureStorageDeployDriver = AzureStorageDeployDriver;
/**
 * deploy to Azure Storage
 */
class AzureStorageDeployDriverImpl extends azureDeployImpl_1.AzureDeployImpl {
    constructor() {
        super(...arguments);
        this.summaries = [localizeUtils_1.getLocalizedString("driver.deploy.azureStorageDeploySummary")];
        this.summaryPrepare = [];
        this.progressHandler = progressBarHelper_1.progressBarHelper(deployConstant_1.ProgressBarConstant.UPLOAD_DEPLOY_TO_AZURE_STORAGE_PROGRESS);
        this.progressNames = deployConstant_1.ProgressBarConstant.UPLOAD_DEPLOY_TO_AZURE_STORAGE_PROGRESS;
        this.pattern = /\/subscriptions\/([^\/]*)\/resourceGroups\/([^\/]*)\/providers\/Microsoft.Storage\/storageAccounts\/([^\/]*)/i;
        this.helpLink = "https://aka.ms/teamsfx-actions/azure-storage-deploy";
    }
    async azureDeploy(args, azureResource, azureCredential) {
        var _a, _b, _c;
        await this.context.logProvider.debug("Start deploying to Azure Storage Service");
        await this.context.logProvider.debug("Get Azure Storage Service deploy credential");
        await ((_a = this.progressHandler) === null || _a === void 0 ? void 0 : _a.next());
        const containerClient = await AzureStorageDeployDriverImpl.createContainerClient(azureResource, azureCredential);
        // delete all existing blobs
        await ((_b = this.progressHandler) === null || _b === void 0 ? void 0 : _b.next());
        await this.deleteAllBlobs(containerClient, azureResource.instanceId, this.context.logProvider);
        await this.context.logProvider.debug("Uploading files to Azure Storage Service");
        // upload all to storage
        await ((_c = this.progressHandler) === null || _c === void 0 ? void 0 : _c.next());
        const ig = await this.handleIgnore(args, this.context);
        const sourceFolder = this.distDirectory;
        const tasks = [];
        await fileOperation_1.forEachFileAndDir(sourceFolder, (filePath, stats) => {
            const destFilePath = path_1.default.relative(sourceFolder, filePath);
            if (!destFilePath || stats.isDirectory()) {
                return;
            }
            const options = {
                blobHTTPHeaders: {
                    blobContentType: mime.getType(filePath) || undefined,
                },
            };
            const client = containerClient.getBlockBlobClient(destFilePath);
            tasks.push(client.uploadFile(filePath, options));
        }, (itemPath) => {
            return !ig.test(path_1.default.relative(sourceFolder, itemPath)).ignored;
        });
        const responses = await Promise.all(tasks);
        const errorResponse = responses.find((res) => res.errorCode);
        if (errorResponse) {
            throw deployError_1.DeployExternalApiCallError.uploadToStorageError(sourceFolder, errorResponse, this.helpLink);
        }
        await this.context.logProvider.debug("Upload files to Azure Storage Service successfully");
        return;
    }
    static async createContainerClient(azureResource, azureCredential) {
        const blobServiceClient = await azureResourceOperation_1.createBlobServiceClient(azureResource, azureCredential);
        const container = blobServiceClient.getContainerClient(deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME);
        if (!(await container.exists())) {
            await container.create();
        }
        return container;
    }
    async deleteAllBlobs(client, storageName, logProvider) {
        var e_1, _a;
        await logProvider.debug(`Deleting all existing blobs in container '${deployConstant_1.DeployConstant.AZURE_STORAGE_CONTAINER_NAME}' for Azure Storage account '${storageName}'.`);
        const deleteJobs = [];
        try {
            for (var _b = tslib_1.__asyncValues(client.listBlobsFlat()), _c; _c = await _b.next(), !_c.done;) {
                const blob = _c.value;
                if (AzureStorageDeployDriverImpl.isBlobFile(blob)) {
                    deleteJobs.push(client.deleteBlob(blob.name));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const responses = await Promise.all(deleteJobs);
        const errorResponse = responses.find((res) => res.errorCode);
        if (errorResponse) {
            throw deployError_1.DeployExternalApiCallError.clearStorageError("delete blob", errorResponse.errorCode, errorResponse, this.helpLink);
        }
    }
    static isBlobFile(blob) {
        var _a;
        return ((_a = blob.properties.contentLength) !== null && _a !== void 0 ? _a : -1) > 0;
    }
    createProgressBar(ui) {
        var _a;
        return ui === null || ui === void 0 ? void 0 : ui.createProgressBar(`Deploying ${(_a = this.workingDirectory) !== null && _a !== void 0 ? _a : ""} to Azure Storage Service`, this.progressNames.length);
    }
}
exports.AzureStorageDeployDriverImpl = AzureStorageDeployDriverImpl;
//# sourceMappingURL=azureStorageDeployDriver.js.map