"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureZipDeployImpl = void 0;
const tslib_1 = require("tslib");
const azureDeployImpl_1 = require("./azureDeployImpl");
const messages_1 = require("../../../../messages");
const deployConstant_1 = require("../../../../constant/deployConstant");
const crypto_1 = require("crypto");
const axios_1 = tslib_1.__importDefault(require("axios"));
const deployError_1 = require("../../../../error/deployError");
const commonConstant_1 = require("../../../../constant/commonConstant");
class AzureZipDeployImpl extends azureDeployImpl_1.AzureDeployImpl {
    constructor(args, context, serviceName, helpLink, summaries, summaryPrepare) {
        super(args, context);
        this.pattern = /\/subscriptions\/([^\/]*)\/resourceGroups\/([^\/]*)\/providers\/Microsoft.Web\/sites\/([^\/]*)/i;
        this.prepare = async (args) => {
            var _a;
            await ((_a = this.progressHandler) === null || _a === void 0 ? void 0 : _a.next());
            await this.packageToZip(args, this.context);
        };
        this.helpLink = helpLink;
        this.serviceName = serviceName;
        this.summaries = summaries;
        this.summaryPrepare = summaryPrepare;
        this.progressNames = deployConstant_1.ProgressBarConstant.ZIP_DEPLOY_IN_AZURE_PROGRESS;
        this.progressPrepare = deployConstant_1.ProgressBarConstant.DRY_RUN_ZIP_DEPLOY_IN_AZURE_PROGRESS;
    }
    async azureDeploy(args, azureResource, azureCredential) {
        var _a, _b;
        const cost = await this.zipDeploy(args, azureResource, azureCredential);
        await ((_a = this.progressHandler) === null || _a === void 0 ? void 0 : _a.next());
        await this.restartFunctionApp(azureResource);
        if (cost > deployConstant_1.DeployConstant.DEPLOY_OVER_TIME) {
            await ((_b = this.context.logProvider) === null || _b === void 0 ? void 0 : _b.info(messages_1.getLocalizedMessage("driver.deploy.notice.deployAcceleration", "https://aka.ms/teamsfx-config-run-from-package").localized));
        }
    }
    /**
     * deploy to azure app service or azure function use zip deploy method
     * @param args local file needed to be deployed
     * @param azureResource azure resource info
     * @param azureCredential azure user login credential
     * @return the zip deploy time cost
     * @protected
     */
    async zipDeploy(args, azureResource, azureCredential) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        await ((_a = this.progressHandler) === null || _a === void 0 ? void 0 : _a.next());
        const zipBuffer = await this.packageToZip(args, this.context);
        await ((_b = this.progressHandler) === null || _b === void 0 ? void 0 : _b.next());
        await this.context.logProvider.debug("Start to get Azure account info for deploy");
        const config = await this.createAzureDeployConfig(azureResource, azureCredential);
        await this.context.logProvider.debug("Get Azure account info for deploy complete");
        await ((_c = this.progressHandler) === null || _c === void 0 ? void 0 : _c.next());
        const endpoint = this.getZipDeployEndpoint(azureResource.instanceId);
        await this.context.logProvider.debug(`Start to upload code to ${endpoint}`);
        await ((_d = this.progressHandler) === null || _d === void 0 ? void 0 : _d.next());
        const startTime = Date.now();
        const location = await this.zipDeployPackage(endpoint, zipBuffer, config, this.context.logProvider);
        await this.context.logProvider.debug("Upload code to Azure complete");
        await ((_e = this.progressHandler) === null || _e === void 0 ? void 0 : _e.next());
        await this.context.logProvider.debug("Start to check Azure deploy status");
        const deployRes = await this.checkDeployStatus(location, config, this.context.logProvider);
        await this.context.logProvider.debug("Check Azure deploy status complete");
        const cost = Date.now() - startTime;
        (_f = this.context.telemetryReporter) === null || _f === void 0 ? void 0 : _f.sendTelemetryEvent("deployResponse", {
            time_cost: cost.toString(),
            status: (_g = deployRes === null || deployRes === void 0 ? void 0 : deployRes.status.toString()) !== null && _g !== void 0 ? _g : "",
            message: (_h = deployRes === null || deployRes === void 0 ? void 0 : deployRes.message) !== null && _h !== void 0 ? _h : "",
            received_time: (_j = deployRes === null || deployRes === void 0 ? void 0 : deployRes.received_time) !== null && _j !== void 0 ? _j : "",
            started_time: (_k = deployRes === null || deployRes === void 0 ? void 0 : deployRes.start_time.toString()) !== null && _k !== void 0 ? _k : "",
            end_time: (_l = deployRes === null || deployRes === void 0 ? void 0 : deployRes.end_time.toString()) !== null && _l !== void 0 ? _l : "",
            last_success_end_time: (_m = deployRes === null || deployRes === void 0 ? void 0 : deployRes.last_success_end_time.toString()) !== null && _m !== void 0 ? _m : "",
            complete: (_o = deployRes === null || deployRes === void 0 ? void 0 : deployRes.complete.toString()) !== null && _o !== void 0 ? _o : "",
            active: (_p = deployRes === null || deployRes === void 0 ? void 0 : deployRes.active.toString()) !== null && _p !== void 0 ? _p : "",
            is_readonly: (_q = deployRes === null || deployRes === void 0 ? void 0 : deployRes.is_readonly.toString()) !== null && _q !== void 0 ? _q : "",
            site_name_hash: (deployRes === null || deployRes === void 0 ? void 0 : deployRes.site_name)
                ? crypto_1.createHash("sha256").update(deployRes.site_name).digest("hex")
                : "",
        });
        return cost;
    }
    /**
     * call azure app service or azure function zip deploy method
     * @param zipDeployEndpoint azure zip deploy endpoint
     * @param zipBuffer zip file buffer
     * @param config azure upload config, including azure account credential
     * @param logger log provider
     * @protected
     */
    async zipDeployPackage(zipDeployEndpoint, zipBuffer, config, logger) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        let res;
        let retryCount = 0;
        while (true) {
            try {
                res = await azureDeployImpl_1.AzureDeployImpl.AXIOS_INSTANCE.post(zipDeployEndpoint, zipBuffer, config);
                break;
            }
            catch (e) {
                if (axios_1.default.isAxiosError(e)) {
                    // if the error is remote server error, retry
                    if (((_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : commonConstant_1.HttpStatusCode.OK) >= commonConstant_1.HttpStatusCode.INTERNAL_SERVER_ERROR) {
                        retryCount += 1;
                        if (retryCount < deployConstant_1.DeployConstant.DEPLOY_UPLOAD_RETRY_TIMES) {
                            await (logger === null || logger === void 0 ? void 0 : logger.warning(`Upload zip file failed with response status code: ${(_d = (_c = e.response) === null || _c === void 0 ? void 0 : _c.status) !== null && _d !== void 0 ? _d : "NA"}. Retrying...`));
                        }
                        else {
                            // if retry times exceed, throw error
                            await (logger === null || logger === void 0 ? void 0 : logger.warning(`Retry times exceeded. Upload zip file failed with remote server error. Message: ${JSON.stringify((_e = e.response) === null || _e === void 0 ? void 0 : _e.data)}`));
                            throw deployError_1.DeployExternalApiCallError.zipDeployWithRemoteError(e, undefined, this.helpLink);
                        }
                    }
                    else {
                        // None server error, throw
                        await (logger === null || logger === void 0 ? void 0 : logger.error(`Upload zip file failed with response status code: ${(_g = (_f = e.response) === null || _f === void 0 ? void 0 : _f.status) !== null && _g !== void 0 ? _g : "NA"}, message: ${JSON.stringify((_h = e.response) === null || _h === void 0 ? void 0 : _h.data)}`));
                        throw deployError_1.DeployExternalApiCallError.zipDeployError(e, (_k = (_j = e.response) === null || _j === void 0 ? void 0 : _j.status) !== null && _k !== void 0 ? _k : -1, this.helpLink);
                    }
                }
                else {
                    // if the error is not axios error, throw
                    await (logger === null || logger === void 0 ? void 0 : logger.error(`Upload zip file failed with error: ${JSON.stringify(e)}`));
                    throw deployError_1.DeployExternalApiCallError.zipDeployError(e, -1, this.helpLink);
                }
            }
        }
        if ((res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.OK && (res === null || res === void 0 ? void 0 : res.status) !== commonConstant_1.HttpStatusCode.ACCEPTED) {
            if (res === null || res === void 0 ? void 0 : res.status) {
                await (logger === null || logger === void 0 ? void 0 : logger.error(`Deployment is failed with error code: ${res.status}.`));
            }
            throw deployError_1.DeployExternalApiCallError.zipDeployError(res, res.status, this.helpLink);
        }
        return res.headers.location;
    }
    /**
     * create azure zip deploy endpoint
     * @param siteName azure app service or azure function name
     * @protected
     */
    getZipDeployEndpoint(siteName) {
        return `https://${siteName}.scm.azurewebsites.net/api/zipdeploy?isAsync=true`;
    }
    createProgressBar(ui) {
        var _a;
        return ui === null || ui === void 0 ? void 0 : ui.createProgressBar(`Deploying ${(_a = this.workingDirectory) !== null && _a !== void 0 ? _a : ""} to ${this.serviceName}`, this.progressNames.length);
    }
}
exports.AzureZipDeployImpl = AzureZipDeployImpl;
//# sourceMappingURL=AzureZipDeployImpl.js.map