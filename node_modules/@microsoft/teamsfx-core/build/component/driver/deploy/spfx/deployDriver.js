"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxDeployDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const tools_1 = require("../../../../common/tools");
const common_1 = require("../../../utils/common");
const addStartAndEndTelemetry_1 = require("../../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../../util/wrapUtil");
const createAppCatalogFailedError_1 = require("./error/createAppCatalogFailedError");
const getGraphTokenFailedError_1 = require("./error/getGraphTokenFailedError");
const getSPOTokenFailedError_1 = require("./error/getSPOTokenFailedError");
const getTenantFailedError_1 = require("./error/getTenantFailedError");
const insufficientPermissionError_1 = require("./error/insufficientPermissionError");
const noSPPackageError_1 = require("./error/noSPPackageError");
const noValidAppCatelogError_1 = require("./error/noValidAppCatelogError");
const uploadAppPackageFailedError_1 = require("./error/uploadAppPackageFailedError");
const constants_1 = require("./utility/constants");
const sleep_1 = require("./utility/sleep");
const spoClient_1 = require("./utility/spoClient");
let SPFxDeployDriver = class SPFxDeployDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.spfx.deploy.description");
        this.EmptyMap = new Map();
        this.asDeployArgs = common_1.asFactory({
            createAppCatalogIfNotExist: common_1.asBoolean,
            packageSolutionPath: common_1.asString,
        });
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        return common_1.wrapRun(() => this.deploy(args, wrapContext));
    }
    async execute(args, ctx) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(ctx, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        const result = await this.run(args, wrapContext);
        return {
            result,
            summaries: wrapContext.summaries,
        };
    }
    async deploy(args, context) {
        var _a, _b, _c, _d, _e;
        const deployArgs = this.asDeployArgs(args);
        const progressHandler = (_a = context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(constants_1.Constants.DeployProgressTitle(), 3);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.start());
        let success = false;
        try {
            const tenant = await this.getTenant(context.m365TokenProvider);
            spoClient_1.SPOClient.setBaseUrl(tenant);
            const spoToken = await tools_1.getSPFxToken(context.m365TokenProvider);
            if (!spoToken) {
                throw new getSPOTokenFailedError_1.GetSPOTokenFailedError();
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.SkipCreateSPAppCatalog()));
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                context.addSummary(constants_1.DeployProgressMessage.SkipCreateSPAppCatalog());
            }
            else {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.CreateSPAppCatalog()));
                if (deployArgs.createAppCatalogIfNotExist) {
                    try {
                        await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        context.addSummary(constants_1.DeployProgressMessage.CreateSPAppCatalog());
                    }
                    catch (e) {
                        throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(e);
                    }
                }
                else {
                    throw new noValidAppCatelogError_1.NoValidAppCatelog();
                }
                let retry = 0;
                appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                    context.logProvider.warning(localizeUtils_1.getLocalizedString("driver.spfx.warn.noTenantAppCatalogFound", retry));
                    await sleep_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                    appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                    retry += 1;
                }
                if (appCatalogSite) {
                    spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                    context.logProvider.info(localizeUtils_1.getLocalizedString("driver.spfx.info.tenantAppCatalogCreated", appCatalogSite));
                    await sleep_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
                }
                else {
                    throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(new Error(localizeUtils_1.getLocalizedString("driver.spfx.error.failedToGetAppCatalog")));
                }
            }
            const packageSolutionPath = path_1.default.isAbsolute(deployArgs.packageSolutionPath)
                ? deployArgs.packageSolutionPath
                : path_1.default.join(context.projectPath, deployArgs.packageSolutionPath);
            const appPackage = await this.getPackagePath(packageSolutionPath);
            if (!(await fs_extra_1.default.pathExists(appPackage))) {
                throw new noSPPackageError_1.NoSPPackageError(appPackage);
            }
            const fileName = path_1.default.parse(appPackage).base;
            const bytes = await fs_extra_1.default.readFile(appPackage);
            try {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.Upload()));
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
                context.addSummary(constants_1.DeployProgressMessage.Upload());
            }
            catch (e) {
                if (((_b = e.response) === null || _b === void 0 ? void 0 : _b.status) === 403) {
                    (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("error", localizeUtils_1.getLocalizedString("plugins.spfx.deployFailedNotice", appCatalogSite), false, "OK");
                    throw new insufficientPermissionError_1.InsufficientPermissionError(appCatalogSite);
                }
                else {
                    throw new uploadAppPackageFailedError_1.UploadAppPackageFailedError(e);
                }
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.Deploy()));
            const appID = await this.getAppID(packageSolutionPath);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            context.addSummary(constants_1.DeployProgressMessage.Deploy());
            const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
            if (context.platform === teamsfx_api_1.Platform.CLI) {
                (_d = context.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", guidance, false);
            }
            else {
                (_e = context.ui) === null || _e === void 0 ? void 0 : _e.showMessage("info", guidance, false, "OK");
            }
            success = true;
        }
        finally {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(success));
        }
        return this.EmptyMap;
    }
    async getTenant(tokenProvider) {
        const graphTokenRes = await tokenProvider.getAccessToken({
            scopes: tools_1.GraphScopes,
        });
        const graphToken = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        if (!graphToken) {
            throw new getGraphTokenFailedError_1.GetGraphTokenFailedError();
        }
        const tokenJsonRes = await tokenProvider.getJsonObject({
            scopes: tools_1.GraphScopes,
        });
        const username = tokenJsonRes.value.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                throw new getTenantFailedError_1.GetTenantFailedError(username);
            }
        }
        catch (e) {
            throw new getTenantFailedError_1.GetTenantFailedError(username, e);
        }
        return tenant;
    }
    async getPackagePath(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new teamsfx_api_1.PathNotExistError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const sharepointFolder = path_1.default.dirname(solutionConfigPath).replace("config", "sharepoint");
        return path_1.default.resolve(sharepointFolder, solutionConfig.paths.zippedPackage);
    }
    async getAppID(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new teamsfx_api_1.PathNotExistError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxDeployDriver.prototype, "run", null);
SPFxDeployDriver = tslib_1.__decorate([
    typedi_1.Service(constants_1.Constants.DeployDriverName)
], SPFxDeployDriver);
exports.SPFxDeployDriver = SPFxDeployDriver;
//# sourceMappingURL=deployDriver.js.map