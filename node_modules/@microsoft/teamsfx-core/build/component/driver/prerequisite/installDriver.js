"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolsInstallDriverImpl = exports.ToolsInstallDriver = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const deps_checker_1 = require("../../../common/deps-checker");
const localCertificateManager_1 = require("../../../common/local/localCertificateManager");
const wrapUtil_1 = require("../util/wrapUtil");
const constant_1 = require("./constant");
const dotnetInstallationUserError_1 = require("./error/dotnetInstallationUserError");
const funcInstallationUserError_1 = require("./error/funcInstallationUserError");
const invalidParameterUserError_1 = require("./error/invalidParameterUserError");
const ACTION_NAME = "prerequisite/install";
const outputName = Object.freeze({
    SSL_CRT_FILE: "SSL_CRT_FILE",
    SSL_KEY_FILE: "SSL_KEY_FILE",
    FUNC_PATH: "FUNC_PATH",
    DOTNET_PATH: "DOTNET_PATH",
});
const helpLink = "https://aka.ms/teamsfx-actions/prerequisite-install";
let ToolsInstallDriver = class ToolsInstallDriver {
    constructor() {
        this.description = constant_1.toolsInstallDescription();
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
        const impl = new ToolsInstallDriverImpl(wrapContext);
        return (await wrapUtil_1.wrapRun(wrapContext, () => impl.run(args)));
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
        const impl = new ToolsInstallDriverImpl(wrapContext);
        return (await wrapUtil_1.wrapRun(wrapContext, () => impl.run(args), true));
    }
};
ToolsInstallDriver = tslib_1.__decorate([
    typedi_1.Service(ACTION_NAME)
], ToolsInstallDriver);
exports.ToolsInstallDriver = ToolsInstallDriver;
class ToolsInstallDriverImpl {
    constructor(context) {
        this.context = context;
    }
    async run(args) {
        const res = new Map();
        this.validateArgs(args);
        this.setArgTelemetry(args);
        const progressBar = await this.createProgressBar(this.getSteps(args));
        if (args.devCert) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(constant_1.ProgressMessages.devCert()));
            const localCertRes = await this.resolveLocalCertificate(args.devCert.trust);
            localCertRes.forEach((v, k) => res.set(k, v));
        }
        if (args.func) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(constant_1.ProgressMessages.func()));
            const funcRes = await this.resolveFuncCoreTools();
            funcRes.forEach((v, k) => res.set(k, v));
        }
        if (args.dotnet) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.next(constant_1.ProgressMessages.dotnet()));
            const dotnetRes = await this.resolveDotnet();
            dotnetRes.forEach((v, k) => res.set(k, v));
        }
        return res;
    }
    async resolveLocalCertificate(trustDevCert) {
        const res = new Map();
        // Do not print any log in LocalCertificateManager, use the error message returned instead.
        const certManager = new localCertificateManager_1.LocalCertificateManager(this.context.ui);
        const localCertResult = await certManager.setupCertificate(trustDevCert);
        if (trustDevCert) {
            res.set(outputName.SSL_CRT_FILE, localCertResult.certPath);
            res.set(outputName.SSL_KEY_FILE, localCertResult.keyPath);
        }
        this.setDevCertTelemetry(trustDevCert, localCertResult);
        if (typeof localCertResult.isTrusted === "undefined") {
            this.context.logProvider.warning(constant_1.Summaries.devCertSkipped());
            this.context.addSummary(constant_1.Summaries.devCertSkipped());
        }
        else if (localCertResult.isTrusted === false) {
            throw localCertResult.error;
        }
        else {
            this.context.addSummary(constant_1.Summaries.devCertSuccess(trustDevCert));
        }
        return res;
    }
    async resolveFuncCoreTools() {
        var _a, _b, _c, _d;
        const res = new Map();
        const depsManager = new deps_checker_1.DepsManager(new deps_checker_1.EmptyLogger(), new deps_checker_1.EmptyTelemetry());
        const funcStatus = await depsManager.ensureDependency(deps_checker_1.DepsType.FuncCoreTools, true);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.funcStatus, funcStatus);
        if (!funcStatus.isInstalled && funcStatus.error) {
            throw new funcInstallationUserError_1.FuncInstallationUserError(ACTION_NAME, funcStatus.error);
        }
        else if (funcStatus.error) {
            this.context.logProvider.warning((_a = funcStatus.error) === null || _a === void 0 ? void 0 : _a.message);
            this.context.addSummary((_b = funcStatus.error) === null || _b === void 0 ? void 0 : _b.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.funcSuccess((_c = funcStatus === null || funcStatus === void 0 ? void 0 : funcStatus.details) === null || _c === void 0 ? void 0 : _c.binFolders));
        }
        if (((_d = funcStatus === null || funcStatus === void 0 ? void 0 : funcStatus.details) === null || _d === void 0 ? void 0 : _d.binFolders) !== undefined) {
            const funcBinFolder = funcStatus.details.binFolders.join(path.delimiter);
            res.set(outputName.FUNC_PATH, funcBinFolder);
        }
        return res;
    }
    async resolveDotnet() {
        var _a, _b, _c, _d;
        const res = new Map();
        const depsManager = new deps_checker_1.DepsManager(new deps_checker_1.EmptyLogger(), new deps_checker_1.EmptyTelemetry());
        const dotnetStatus = await depsManager.ensureDependency(deps_checker_1.DepsType.Dotnet, true);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.dotnetStatus, dotnetStatus);
        if (!dotnetStatus.isInstalled && dotnetStatus.error) {
            throw new dotnetInstallationUserError_1.DotnetInstallationUserError(ACTION_NAME, dotnetStatus.error);
        }
        else if (dotnetStatus.error) {
            this.context.logProvider.warning((_a = dotnetStatus.error) === null || _a === void 0 ? void 0 : _a.message);
            this.context.addSummary((_b = dotnetStatus.error) === null || _b === void 0 ? void 0 : _b.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.dotnetSuccess((_c = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _c === void 0 ? void 0 : _c.binFolders));
        }
        if (((_d = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _d === void 0 ? void 0 : _d.binFolders) !== undefined) {
            const dotnetBinFolder = `${dotnetStatus.details.binFolders
                .map((f) => path.dirname(f))
                .join(path.delimiter)}`;
            res.set(outputName.DOTNET_PATH, dotnetBinFolder);
        }
        return res;
    }
    validateArgs(args) {
        var _a;
        if (!!args.devCert && typeof ((_a = args.devCert) === null || _a === void 0 ? void 0 : _a.trust) !== "boolean") {
            throw new invalidParameterUserError_1.InvalidParameterUserError(ACTION_NAME, "devCert.trust", helpLink);
        }
        if (!!args.func && typeof args.func !== "boolean") {
            throw new invalidParameterUserError_1.InvalidParameterUserError(ACTION_NAME, "func", helpLink);
        }
        if (!!args.dotnet && typeof args.dotnet !== "boolean") {
            throw new invalidParameterUserError_1.InvalidParameterUserError(ACTION_NAME, "dotnet", helpLink);
        }
    }
    getSteps(args) {
        return (args.devCert ? 1 : 0) + (args.dotnet ? 1 : 0) + (args.func ? 1 : 0);
    }
    setArgTelemetry(args) {
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.driverArgs]: JSON.stringify({
                devCert: args.devCert,
                func: args.func,
                dotnet: args.dotnet,
            }),
        });
    }
    setDevCertTelemetry(trustDevCert, localCertResult) {
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.devCertStatus]: !trustDevCert
                ? constant_1.TelemetryDevCertStatus.Disabled
                : localCertResult.alreadyTrusted
                    ? constant_1.TelemetryDevCertStatus.AlreadyTrusted
                    : localCertResult.isTrusted
                        ? constant_1.TelemetryDevCertStatus.Trusted
                        : constant_1.TelemetryDevCertStatus.NotTrusted,
        });
    }
    setDepsCheckTelemetry(propertyName, depStatus) {
        this.context.addTelemetryProperties({
            [propertyName]: depStatus.isInstalled
                ? depStatus.error
                    ? constant_1.TelemetryDepsCheckStatus.warn
                    : constant_1.TelemetryDepsCheckStatus.success
                : constant_1.TelemetryDepsCheckStatus.failed,
        });
    }
    async createProgressBar(steps) {
        var _a;
        const progressBar = (_a = this.context.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(constant_1.ProgressMessages.title(), steps);
        if (progressBar) {
            this.context.progressBars.push(progressBar);
        }
        await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.start());
        return progressBar;
    }
}
exports.ToolsInstallDriverImpl = ToolsInstallDriverImpl;
//# sourceMappingURL=installDriver.js.map