"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureResourceConfig = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const tools_1 = require("../../common/tools");
const utils_1 = require("../../common/utils");
const question_1 = require("../../core/question");
const folder_1 = require("../../folder");
const constants_1 = require("../constants");
const workflow_1 = require("../workflow");
class AzureResourceConfig {
    constructor() {
        this.templateContext = {};
    }
    async generateBicep(context, inputs) {
        var _a, _b;
        const update = inputs.update;
        const requisiteComponent = workflow_1.getComponentByScenario(context.projectSetting, this.requisite, inputs.scenario);
        if (!requisiteComponent)
            return teamsfx_api_1.ok([]);
        this.templateContext.connections = requisiteComponent.connections || [];
        for (const refComponentName of this.references) {
            this.templateContext[refComponentName] = { outputs: {} };
            try {
                const refResource = typedi_1.Container.get(refComponentName);
                if (refResource.outputs) {
                    for (const key of Object.keys(refResource.outputs)) {
                        const entry = refResource.outputs[key];
                        const value = tools_1.compileHandlebarsTemplateString((_a = entry.bicepVariable) !== null && _a !== void 0 ? _a : "", inputs);
                        this.templateContext[refComponentName].outputs[entry.key] = value;
                    }
                }
            }
            catch (e) { }
        }
        this.templateContext.scenario = inputs.scenario || "";
        this.templateContext.scenarioInLowerCase = (inputs.scenario || "").toLowerCase();
        const configs = [];
        configs.push((_b = constants_1.languageToRuntime.get(context.projectSetting.programmingLanguage ||
            (inputs === null || inputs === void 0 ? void 0 : inputs[question_1.CoreQuestionNames.ProgrammingLanguage]))) !== null && _b !== void 0 ? _b : "");
        this.templateContext.configs = configs;
        const modulePath = path.join(folder_1.getTemplatesFolder(), "bicep", `${this.bicepModuleName}.config.module.bicep`);
        let module = await fs_extra_1.default.readFile(modulePath, "utf-8");
        module = tools_1.compileHandlebarsTemplateString(module, this.templateContext);
        const templatesFolder = await utils_1.getProjectTemplatesFolderPath(inputs.projectPath);
        const targetModuleFilePath = path.join(templatesFolder, "azure", "teamsFx", `${this.bicepModuleName}${inputs.scenario}Config.bicep`);
        const targetModuleFilePathExists = await fs_extra_1.default.pathExists(targetModuleFilePath);
        const sourceOrchTemplatePath = path.join(folder_1.getTemplatesFolder(), "bicep", `${this.bicepModuleName}.config.orchestration.bicep`);
        // orchestration part will be added only for first time
        const orch = targetModuleFilePathExists
            ? undefined
            : tools_1.compileHandlebarsTemplateString(await fs_extra_1.default.readFile(sourceOrchTemplatePath, "utf-8"), this.templateContext);
        const moduleName = this.bicepModuleName + (inputs.scenario || "");
        const bicep = {
            type: "bicep",
            Configuration: {
                Modules: { [`${moduleName}Config`]: module },
                Orchestration: update ? undefined : orch,
            },
        };
        return teamsfx_api_1.ok([bicep]);
    }
}
exports.AzureResourceConfig = AzureResourceConfig;
//# sourceMappingURL=azureResourceConfig.js.map