"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.developerPortalScaffoldUtils = exports.isFromDevPortalInVSC = exports.updateScope = exports.getTemplateId = exports.TabUrlType = exports.DeveloperPortalScaffoldUtils = exports.answerToReplaceMessageExtensionBotId = exports.answerToRepaceBotId = void 0;
const tslib_1 = require("tslib");
const appStudio = tslib_1.__importStar(require("./resource/appManifest/appStudio"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const environment_1 = require("../core/environment");
const question_1 = require("../core/question");
const constants_1 = require("./resource/appManifest/constants");
const error_1 = require("../core/error");
const constants_2 = require("./constants");
const localizeUtils_1 = require("../common/localizeUtils");
const ManifestUtils_1 = require("./resource/appManifest/utils/ManifestUtils");
const utils_1 = require("./resource/appManifest/utils/utils");
const appPackageFolderName = "appPackage";
const resourcesFolderName = "resources";
const colorFileName = "color.png";
const outlineFileName = "outline.png";
const manifestFileName = "manifest.json";
exports.answerToRepaceBotId = "bot";
exports.answerToReplaceMessageExtensionBotId = "messageExtension";
class DeveloperPortalScaffoldUtils {
    async updateFilesForTdp(ctx, appDefinition, inputs) {
        if (!ctx.projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        if (!ctx.tokenProvider) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("tokenProvider"));
        }
        const manifestRes = await updateManifest(ctx, appDefinition, inputs);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const envRes = await updateEnv(appDefinition.teamsAppId, ctx.projectPath);
        if (envRes.isErr()) {
            return teamsfx_api_1.err(envRes.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
}
exports.DeveloperPortalScaffoldUtils = DeveloperPortalScaffoldUtils;
var TabUrlType;
(function (TabUrlType) {
    TabUrlType["WebsiteUrl"] = "WebsiteUrl";
    TabUrlType["ContentUrl"] = "ContentUrl";
})(TabUrlType = exports.TabUrlType || (exports.TabUrlType = {}));
async function updateManifest(ctx, appDefinition, inputs) {
    var _a;
    const res = await appStudio.getAppPackage(appDefinition.teamsAppId, ctx.tokenProvider.m365TokenProvider, ctx.logProvider);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    const appPackage = res.value;
    if (!appPackage.manifest) {
        const msg = localizeUtils_1.getLocalizedString("core.developerPortal.scaffold.CannotFindManifest", appDefinition.teamsAppId);
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.CoordinatorSource, "CouldNotFoundManifest", msg, msg));
    }
    const colorFilePath = path_1.default.join(ctx.projectPath, appPackageFolderName, resourcesFolderName, colorFileName);
    const outlineFilePath = path_1.default.join(ctx.projectPath, appPackageFolderName, resourcesFolderName, outlineFileName);
    const manifestTemplatePath = path_1.default.join(ctx.projectPath, appPackageFolderName, manifestFileName);
    const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestTemplatePath);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const existingManifestTemplate = manifestRes.value;
    // icons
    const icons = appPackage.icons;
    if (icons) {
        if (icons.color) {
            await fs_extra_1.default.writeFile(colorFilePath, icons.color);
        }
        if (icons.outline) {
            await fs_extra_1.default.writeFile(outlineFilePath, icons.outline);
        }
    }
    // manifest
    const manifest = JSON.parse(appPackage.manifest.toString("utf8"));
    manifest.id = "${{TEAMS_APP_ID}}";
    manifest.icons.color = "resources/color.png";
    manifest.icons.outline = "resources/outline.png";
    // Adding a feature with groupchat scope in TDP won't pass manifest validation in TTK.
    // This is a short-term solution to convert the value to what TTK expects.
    if (!!manifest.configurableTabs && manifest.configurableTabs.length > 0) {
        if (manifest.configurableTabs[0].scopes) {
            {
                manifest.configurableTabs[0].scopes = updateScope(manifest.configurableTabs[0].scopes);
            }
        }
    }
    if (!!manifest.bots && manifest.bots.length > 0) {
        if (manifest.bots[0].scopes) {
            {
                manifest.bots[0].scopes = updateScope(manifest.bots[0].scopes);
            }
        }
    }
    // manifest: tab
    const tabs = manifest.staticTabs;
    let needUpdateStaticTabUrls = false;
    if (inputs[question_1.CoreQuestionNames.ReplaceContentUrl] &&
        inputs[question_1.CoreQuestionNames.ReplaceContentUrl].length != 0) {
        needUpdateStaticTabUrls = true;
        updateTabUrl(inputs[question_1.CoreQuestionNames.ReplaceContentUrl], TabUrlType.ContentUrl, tabs);
    }
    if (inputs[question_1.CoreQuestionNames.ReplaceWebsiteUrl] &&
        inputs[question_1.CoreQuestionNames.ReplaceWebsiteUrl].length != 0) {
        needUpdateStaticTabUrls = true;
        updateTabUrl(inputs[question_1.CoreQuestionNames.ReplaceWebsiteUrl], TabUrlType.WebsiteUrl, tabs);
    }
    if (needUpdateStaticTabUrls) {
        const validDomains = (_a = manifest.validDomains) !== null && _a !== void 0 ? _a : [];
        validDomains.push("${{TAB_DOMAIN}}");
        manifest.validDomains = validDomains;
    }
    // manifest: bot
    if (inputs[question_1.CoreQuestionNames.ReplaceBotIds]) {
        if (inputs[question_1.CoreQuestionNames.ReplaceBotIds].includes(exports.answerToRepaceBotId)) {
            if (existingManifestTemplate.bots && existingManifestTemplate.bots.length > 0) {
                manifest.bots = existingManifestTemplate.bots;
                manifest.validDomains = existingManifestTemplate.validDomains;
            }
            else {
                manifest.bots = constants_1.BOTS_TPL_V3;
                manifest.bots[0].botId = "${{BOT_ID}}";
                manifest.validDomains = existingManifestTemplate.validDomains;
            }
        }
        if (inputs[question_1.CoreQuestionNames.ReplaceBotIds].includes(exports.answerToReplaceMessageExtensionBotId)) {
            if (existingManifestTemplate.composeExtensions &&
                existingManifestTemplate.composeExtensions.length > 0) {
                manifest.composeExtensions = existingManifestTemplate.composeExtensions;
                manifest.validDomains = existingManifestTemplate.validDomains;
            }
            else {
                manifest.composeExtensions = constants_1.COMPOSE_EXTENSIONS_TPL_V3;
                manifest.composeExtensions[0].botId = "${{BOT_ID}}";
                manifest.validDomains = existingManifestTemplate.validDomains;
            }
        }
    }
    // manifest: no tab, bot or me selected on TDP before
    if (!getTemplateId(appDefinition)) {
        // which means user selects a capability through TTK UI.
        manifest.bots = existingManifestTemplate.bots;
        manifest.composeExtensions = existingManifestTemplate.composeExtensions;
        manifest.staticTabs = existingManifestTemplate.staticTabs;
        manifest.configurableTabs = existingManifestTemplate.configurableTabs;
        manifest.permissions = existingManifestTemplate.permissions;
        manifest.validDomains = existingManifestTemplate.validDomains;
        manifest.webApplicationInfo = existingManifestTemplate.webApplicationInfo;
    }
    // manifest: developer
    if (manifest.developer) {
        if (!manifest.developer.websiteUrl) {
            manifest.developer.websiteUrl = constants_1.DEFAULT_DEVELOPER.websiteUrl;
        }
        if (!manifest.developer.privacyUrl) {
            manifest.developer.privacyUrl = constants_1.DEFAULT_DEVELOPER.privacyUrl;
        }
        if (!manifest.developer.termsOfUseUrl) {
            manifest.developer.termsOfUseUrl = constants_1.DEFAULT_DEVELOPER.termsOfUseUrl;
        }
    }
    await fs_extra_1.default.writeFile(manifestTemplatePath, JSON.stringify(manifest, null, "\t"), "utf-8");
    // languages
    const languages = appPackage.languages;
    if (languages) {
        for (const code in languages) {
            const content = JSON.parse(languages[code].toString("utf8"));
            const languageFilePath = path_1.default.join(ctx.projectPath, appPackageFolderName, `${code}.json`);
            await fs_extra_1.default.writeFile(languageFilePath, JSON.stringify(content, null, "\t"), "utf-8");
        }
    }
    return teamsfx_api_1.ok(undefined);
}
async function updateEnv(appId, projectPath) {
    const dotEnvFile = environment_1.environmentManager.getDotEnvPath("local", projectPath);
    const source = await fs_extra_1.default.readFile(dotEnvFile);
    const writeStream = fs_extra_1.default.createWriteStream(dotEnvFile);
    source
        .toString()
        .split(/\r?\n/)
        .forEach((line) => {
        const reg = /^([a-zA-Z_][a-zA-Z0-9_]*=)/g;
        const match = reg.exec(line);
        if (match) {
            if (match[1].startsWith("TEAMS_APP_ID=")) {
                writeStream.write(`TEAMS_APP_ID=${appId}${os.EOL}`);
            }
            else {
                writeStream.write(`${line.trim()}${os.EOL}`);
            }
        }
        else {
            writeStream.write(`${line.trim()}${os.EOL}`);
        }
    });
    writeStream.end();
    return teamsfx_api_1.ok(undefined);
}
function updateTabUrl(answers, tabUrlType, tabs) {
    if (!tabs || tabs.length === 0) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("static tabs"));
    }
    answers.forEach((answer) => {
        const tabToUpdate = findTabBasedOnName(answer, tabs);
        if (tabToUpdate) {
            switch (tabUrlType) {
                case TabUrlType.ContentUrl:
                    tabToUpdate.contentUrl = "${{TAB_ENDPOINT}}/index.html#/tab";
                    break;
                case TabUrlType.WebsiteUrl:
                    tabToUpdate.websiteUrl = "${{TAB_ENDPOINT}}/index.html#/tab";
                    break;
                default:
                    break;
            }
        }
    });
}
function findTabBasedOnName(name, tabs) {
    return tabs.find((o) => o.name === name);
}
function getTemplateId(teamsApp) {
    // tab with bot, tab with message extension, tab with bot and message extension
    if (utils_1.needTabAndBotCode(teamsApp)) {
        return constants_2.TabNonSsoAndDefaultBotItem().id;
    }
    // tab only
    if (utils_1.needTabCode(teamsApp)) {
        return constants_2.TabNonSsoItem().id;
    }
    // bot and message extension
    if (utils_1.isBotAndMessageExtension(teamsApp)) {
        return constants_2.DefaultBotAndMessageExtensionItem().id;
    }
    // message extension
    if (utils_1.isMessageExtension(teamsApp)) {
        return constants_2.MessageExtensionNewUIItem().id;
    }
    // bot
    if (utils_1.isBot(teamsApp)) {
        return constants_2.BotOptionItem().id;
    }
    return undefined;
}
exports.getTemplateId = getTemplateId;
function updateScope(scopes) {
    return scopes.map((o) => o.toLowerCase());
}
exports.updateScope = updateScope;
function isFromDevPortalInVSC(inputs) {
    return !!inputs.teamsAppFromTdp && inputs.platform === teamsfx_api_1.Platform.VSCode;
}
exports.isFromDevPortalInVSC = isFromDevPortalInVSC;
exports.developerPortalScaffoldUtils = new DeveloperPortalScaffoldUtils();
//# sourceMappingURL=developerPortalScaffoldUtils.js.map