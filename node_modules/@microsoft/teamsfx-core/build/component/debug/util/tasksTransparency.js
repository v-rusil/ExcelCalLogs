// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSpfxTasksJson = exports.mergeTasksJson = exports.generateM365Tasks = exports.generateTasks = exports.generateM365TasksJson = exports.generateTasksJson = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../../../common/local/constants");
const comment_json_1 = require("comment-json");
const commentJson = tslib_1.__importStar(require("comment-json"));
const constants_2 = require("../../../common/local/constants");
const constants_3 = require("../../constants");
function generateTasksJson(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage) {
    const comment = `
  // This file is automatically generated by Teams Toolkit.
  // The teamsfx tasks defined in this file require Teams Toolkit version >= 4.1.0.
  // See https://aka.ms/teamsfx-debug-tasks for details on how to customize each task and how to integrate with existing Teams Toolkit projects.
  {}
  `;
    return commentJson.assign(commentJson.parse(comment), {
        version: "2.0.0",
        tasks: generateTasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage),
    });
}
exports.generateTasksJson = generateTasksJson;
function generateM365TasksJson(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage) {
    const comment = `
  // This file is automatically generated by Teams Toolkit.
  // See https://aka.ms/teamsfx-debug-tasks to know the details and how to customize each task.
  {}
  `;
    return commentJson.assign(commentJson.parse(comment), {
        version: "2.0.0",
        tasks: generateM365Tasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage),
    });
}
exports.generateM365TasksJson = generateM365TasksJson;
function generateTasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage) {
    /**
     * Referenced by launch.json
     *   - Start Teams App Locally
     *
     * Referenced inside tasks.json
     *   - Validate & install prerequisites
     *   - Install npm packages
     *   - Start local tunnel
     *   - Set up tab
     *   - Set up bot
     *   - Set up SSO
     *   - Build & upload Teams manifest
     *   - Start services
     *   - Start frontend
     *   - Start backend
     *   - Install Azure Functions binding extensions
     *   - Watch backend
     *   - Start bot
     *   - Start Azurite emulator
     */
    const tasks = [
        startTeamsAppLocally(includeFrontend, includeBackend, includeBot, includeSSO),
        validateAndInstallPrerequisites(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, false),
        installNPMpackages(includeFrontend, includeBackend, includeBot, false),
    ];
    if (includeBot) {
        tasks.push(startLocalTunnel());
    }
    if (includeFrontend) {
        tasks.push(setUpTab());
    }
    if (includeBot) {
        tasks.push(setUpBot());
    }
    if (includeSSO) {
        tasks.push(setUpSSO());
    }
    tasks.push(buildAndUploadTeamsManifest());
    tasks.push(startServices(includeFrontend, includeBackend, includeBot));
    if (includeFrontend) {
        tasks.push(startFrontend());
    }
    if (includeBackend) {
        tasks.push(startBackend(programmingLanguage));
        tasks.push(installAzureFunctionsBindingExtensions());
        if (programmingLanguage === constants_3.ProgrammingLanguage.TS) {
            tasks.push(watchBackend());
        }
    }
    if (includeBot) {
        if (includeFuncHostedBot) {
            tasks.push(startFuncHostedBot(includeFrontend, programmingLanguage));
            tasks.push(startAzuriteEmulator());
            if (programmingLanguage === constants_3.ProgrammingLanguage.TS) {
                tasks.push(watchFuncHostedBot());
            }
        }
        else {
            tasks.push(startBot(includeFrontend));
        }
    }
    return tasks;
}
exports.generateTasks = generateTasks;
function generateM365Tasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage) {
    /**
     * Referenced by launch.json
     *   - Start Teams App Locally
     *   - Start Teams App Locally & Install App
     *
     * Referenced inside tasks.json
     *   - Validate & install prerequisites
     *   - Install npm packages
     *   - Start local tunnel
     *   - Set up tab
     *   - Set up bot
     *   - Set up SSO
     *   - Build & upload Teams manifest
     *   - Start services
     *   - Start frontend
     *   - Start backend
     *   - Install Azure Functions binding extensions
     *   - Watch backend
     *   - Start bot
     *   - Start Azurite emulator
     *   - Install app in Teams
     */
    const tasks = generateTasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSSO, programmingLanguage);
    tasks.splice(1, 0, startTeamsAppLocallyAndInstallApp(includeFrontend, includeBackend, includeBot, includeSSO));
    tasks.push(installAppInTeams());
    return tasks;
}
exports.generateM365Tasks = generateM365Tasks;
function mergeTasksJson(existingData, newData) {
    const mergedData = commentJson.assign(commentJson.parse(`{}`), existingData);
    if (mergedData.version === undefined) {
        mergedData.version = newData.version;
    }
    if (mergedData.tasks === undefined) {
        mergedData.tasks = newData.tasks;
    }
    else {
        const existingTasks = mergedData.tasks;
        const newTasks = newData.tasks;
        const keptTasks = new comment_json_1.CommentArray();
        for (const existingTask of existingTasks) {
            if (!newTasks.some((newTask) => existingTask.label === newTask.label && existingTask.type === newTask.type)) {
                keptTasks.push(existingTask);
            }
        }
        mergedData.tasks = new comment_json_1.CommentArray(...keptTasks, ...newTasks);
    }
    if (mergedData.inputs === undefined) {
        mergedData.inputs = newData.inputs;
    }
    else if (newData.inputs !== undefined) {
        const existingInputs = mergedData.inputs;
        const newInputs = newData.inputs;
        const keptInputs = new comment_json_1.CommentArray();
        for (const existingInput of existingInputs) {
            if (!newInputs.some((newInput) => existingInput.id === newInput.id && existingInput.type === newInput.type)) {
                keptInputs.push(existingInput);
            }
        }
        mergedData.inputs = new comment_json_1.CommentArray(...keptInputs, ...newInputs);
    }
    return mergedData;
}
exports.mergeTasksJson = mergeTasksJson;
function startTeamsAppLocally(includeFrontend, includeBackend, includeBot, includeSSO) {
    const result = {
        label: constants_1.TaskOverallLabel.TransparentDefault,
        dependsOn: [constants_2.TaskLabel.PrerequisiteCheck, constants_2.TaskLabel.InstallNpmPackages],
        dependsOrder: "sequence",
    };
    if (includeBot) {
        result.dependsOn.push(constants_2.TaskLabel.StartLocalTunnel);
    }
    if (includeFrontend) {
        result.dependsOn.push(constants_2.TaskLabel.SetUpTab);
    }
    if (includeBot) {
        result.dependsOn.push(constants_2.TaskLabel.SetUpBot);
    }
    if (includeSSO) {
        result.dependsOn.push(constants_2.TaskLabel.SetUpSSO);
    }
    result.dependsOn.push(constants_2.TaskLabel.PrepareManifest, constants_2.TaskLabel.StartServices);
    return result;
}
function startTeamsAppLocallyAndInstallApp(includeFrontend, includeBackend, includeBot, includeSSO) {
    const result = startTeamsAppLocally(includeFrontend, includeBackend, includeBot, includeSSO);
    result.label = constants_1.TaskOverallLabel.TransparentM365;
    result.dependsOn.push(constants_2.TaskLabel.InstallAppInTeams);
    return result;
}
function validateAndInstallPrerequisites(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeSpfx) {
    const prerequisites = [
        `"${constants_2.Prerequisite.nodejs}", // Validate if Node.js is installed.`,
        `"${constants_2.Prerequisite.m365Account}", // Sign-in prompt for Microsoft 365 account, then validate if the account enables the sideloading permission.`,
    ];
    const ports = [];
    if (includeFrontend) {
        prerequisites.push(`"${constants_2.Prerequisite.devCert}", // Install localhost SSL certificate. It's used to serve the development sites over HTTPS to debug the Tab app in Teams.`);
        ports.push(`${constants_2.TaskDefaultValue.checkPrerequisites.ports.tabService}, // tab service port`);
    }
    if (includeBackend) {
        prerequisites.push(`"${constants_2.Prerequisite.func}", // Install Azure Functions Core Tools. It's used to serve Azure Functions hosted project locally.`, `"${constants_2.Prerequisite.dotnet}", // Ensure .NET Core SDK is installed. TeamsFx Azure Functions project depends on extra .NET binding extensions for HTTP trigger authorization.`);
        ports.push(`${constants_2.TaskDefaultValue.checkPrerequisites.ports.backendService}, // backend service port`, `${constants_2.TaskDefaultValue.checkPrerequisites.ports.backendDebug}, // backend inspector port for Node.js debugger`);
    }
    if (includeFuncHostedBot && !includeBackend) {
        prerequisites.push(`"${constants_2.Prerequisite.func}", // Install Azure Functions Core Tools. It's used to serve Azure Functions hosted project locally.`);
    }
    if (includeBot) {
        prerequisites.push(`"${constants_2.Prerequisite.ngrok}", // Install Ngrok. Bot project requires a public message endpoint, and ngrok can help create public tunnel for your local service.`);
        ports.push(`${constants_2.TaskDefaultValue.checkPrerequisites.ports.botService}, // bot service port`, `${constants_2.TaskDefaultValue.checkPrerequisites.ports.botDebug}, // bot inspector port for Node.js debugger`);
    }
    if (includeSpfx) {
        ports.push(`${constants_2.TaskDefaultValue.checkPrerequisites.ports.spfxService}, // SPFx service port`);
    }
    prerequisites.push(`"${constants_2.Prerequisite.portOccupancy}", // Validate available ports to ensure those debug ones are not occupied.`);
    const prerequisitesComment = `
  [
    ${prerequisites.join("\n  ")}
  ]`;
    const portsComment = `
  [
    ${ports.join("\n  ")}
  ]
  `;
    const comment = `{
    // Check if all required prerequisites are installed and will install them if not.
    // See https://aka.ms/teamsfx-check-prerequisites-task to know the details and how to customize the args.
  }`;
    const args = {
        prerequisites: commentJson.parse(prerequisitesComment),
    };
    args["portOccupancy"] = commentJson.parse(portsComment);
    const task = {
        label: constants_2.TaskLabel.PrerequisiteCheck,
        type: "teamsfx",
        command: constants_2.TaskCommand.checkPrerequisites,
        args: args,
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function installNPMpackages(includeFrontend, includeBackend, includeBot, includeSpfx) {
    const comment = `{
    // Check if all the npm packages are installed and will install them if not.
    // See https://aka.ms/teamsfx-npm-package-task to know the details and how to customize the args.
  }`;
    const result = {
        label: constants_2.TaskLabel.InstallNpmPackages,
        type: "teamsfx",
        command: constants_2.TaskCommand.npmInstall,
        args: {
            projects: [],
        },
    };
    if (includeFrontend) {
        result.args.projects.push({
            cwd: "${workspaceFolder}/tabs",
            npmInstallArgs: constants_2.TaskDefaultValue.npmInstall.npmInstallArgs,
        });
    }
    if (includeBackend) {
        result.args.projects.push({
            cwd: "${workspaceFolder}/api",
            npmInstallArgs: constants_2.TaskDefaultValue.npmInstall.npmInstallArgs,
        });
    }
    if (includeBot) {
        result.args.projects.push({
            cwd: "${workspaceFolder}/bot",
            npmInstallArgs: constants_2.TaskDefaultValue.npmInstall.npmInstallArgs,
        });
    }
    if (includeSpfx) {
        result.args.projects.push({
            cwd: "${workspaceFolder}/SPFx",
            npmInstallArgs: constants_2.TaskDefaultValue.npmInstall.npmInstallArgs,
        });
    }
    return commentJson.assign(commentJson.parse(comment), result);
}
function installAzureFunctionsBindingExtensions() {
    const comment = `{
    // TeamsFx Azure Functions project depends on extra Azure Functions binding extensions for HTTP trigger authorization.
  }`;
    const task = {
        label: constants_2.TaskLabel.InstallAzureFuncBindingExt,
        type: "shell",
        command: "dotnet build extensions.csproj -o ./bin --ignore-failed-sources",
        options: {
            cwd: "${workspaceFolder}/api",
            env: {
                PATH: "${command:fx-extension.get-dotnet-path}${env:PATH}",
            },
        },
        presentation: {
            reveal: "silent",
        },
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function startLocalTunnel() {
    const comment = `{
    // Start the local tunnel service to forward public ngrok URL to local port and inspect traffic.
    // See https://aka.ms/teamsfx-local-tunnel-task for the detailed args definitions,
    // as well as samples to:
    //   - use your own ngrok command / configuration / binary
    //   - use your own tunnel solution
    //   - provide alternatives if ngrok does not work on your dev machine
  }`;
    const task = {
        label: constants_2.TaskLabel.StartLocalTunnel,
        type: "teamsfx",
        command: constants_2.TaskCommand.startLocalTunnel,
        args: {
            ngrokArgs: constants_2.TaskDefaultValue.startLocalTunnel.ngrokArgs,
        },
        isBackground: true,
        problemMatcher: "$teamsfx-local-tunnel-watch",
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function setUpTab() {
    const comment = `{
    // Prepare local launch information for Tab.
    // See https://aka.ms/teamsfx-debug-set-up-tab-task to know the details and how to customize the args.
  }`;
    const task = {
        label: constants_2.TaskLabel.SetUpTab,
        type: "teamsfx",
        command: constants_2.TaskCommand.setUpTab,
        args: {
            baseUrl: constants_2.TaskDefaultValue.setUpTab.baseUrl,
        },
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function setUpBot() {
    const comment = `{
    // Register resources and prepare local launch information for Bot.
    // See https://aka.ms/teamsfx-debug-set-up-bot-task to know the details and how to customize the args.
  }`;
    const existingBot = `
  {
    //// Enter your own bot information if using the existing bot. ////
    // "botId": "",
    // "botPassword": "", // use plain text or environment variable reference like \${env:BOT_PASSWORD}
    "botMessagingEndpoint": "/api/messages", // use your own routing "/any/path", or full URL "https://contoso.com/any/path"
  }
  `;
    const task = {
        label: constants_2.TaskLabel.SetUpBot,
        type: "teamsfx",
        command: constants_2.TaskCommand.setUpBot,
        args: commentJson.parse(existingBot),
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function setUpSSO() {
    const comment = `{
    // Register resources and prepare local launch information for SSO functionality.
    // See https://aka.ms/teamsfx-debug-set-up-sso-task to know the details and how to customize the args.
  }`;
    const existingAAD = `
  {
    //// Enter your own AAD app information if using the existing AAD app. ////
    // "objectId": "",
    // "clientId": "",
    // "clientSecret": "", // use plain text or environment variable reference like \${env:CLIENT_SECRET}
    // "accessAsUserScopeId": "
  }
  `;
    const task = {
        label: constants_2.TaskLabel.SetUpSSO,
        type: "teamsfx",
        command: constants_2.TaskCommand.setUpSSO,
        args: commentJson.parse(existingAAD),
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function buildAndUploadTeamsManifest() {
    const comment = `
  {
    // Build and upload Teams manifest.
    // See https://aka.ms/teamsfx-debug-prepare-manifest-task to know the details and how to customize the args.
  }`;
    const existingApp = `
  {
    //// Enter your own Teams app package path if using the existing Teams manifest. ////
    // "appPackagePath": ""
  }
  `;
    const task = {
        label: constants_2.TaskLabel.PrepareManifest,
        type: "teamsfx",
        command: constants_2.TaskCommand.prepareManifest,
        args: commentJson.parse(existingApp),
    };
    return commentJson.assign(commentJson.parse(comment), task);
}
function startFrontend() {
    return {
        label: constants_2.TaskLabel.StartFrontend,
        type: "shell",
        command: "npm run dev:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/tabs",
        },
        problemMatcher: {
            pattern: {
                regexp: "^.*$",
                file: 0,
                location: 1,
                message: 2,
            },
            background: {
                activeOnStart: true,
                beginsPattern: ".*",
                endsPattern: "Compiled|Failed|compiled|failed",
            },
        },
    };
}
function startBackend(programmingLanguage) {
    const result = {
        label: constants_2.TaskLabel.StartBackend,
        type: "shell",
        command: "npm run dev:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/api",
            env: {
                PATH: "${command:fx-extension.get-func-path}${env:PATH}",
            },
        },
        problemMatcher: {
            pattern: {
                regexp: "^.*$",
                file: 0,
                location: 1,
                message: 2,
            },
            background: {
                activeOnStart: true,
                beginsPattern: "^.*(Job host stopped|signaling restart).*$",
                endsPattern: "^.*(Worker process started and initialized|Host lock lease acquired by instance ID).*$",
            },
        },
        presentation: {
            reveal: "silent",
        },
        dependsOn: [constants_2.TaskLabel.InstallAzureFuncBindingExt],
    };
    if (programmingLanguage === constants_3.ProgrammingLanguage.TS) {
        result.dependsOn.push(constants_2.TaskLabel.WatchBackend);
    }
    return result;
}
function watchBackend() {
    return {
        label: constants_2.TaskLabel.WatchBackend,
        type: "shell",
        command: "npm run watch:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/api",
        },
        problemMatcher: "$tsc-watch",
        presentation: {
            reveal: "silent",
        },
    };
}
function watchFuncHostedBot() {
    return {
        label: constants_2.TaskLabel.WatchBot,
        type: "shell",
        command: "npm run watch:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/bot",
        },
        problemMatcher: "$tsc-watch",
        presentation: {
            reveal: "silent",
        },
    };
}
function startBot(includeFrontend) {
    const result = {
        label: constants_2.TaskLabel.StartBot,
        type: "shell",
        command: "npm run dev:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/bot",
        },
        problemMatcher: {
            pattern: [
                {
                    regexp: "^.*$",
                    file: 0,
                    location: 1,
                    message: 2,
                },
            ],
            background: {
                activeOnStart: true,
                beginsPattern: "[nodemon] starting",
                endsPattern: "restify listening to|Bot/ME service listening at|[nodemon] app crashed",
            },
        },
    };
    if (includeFrontend) {
        result.presentation = { reveal: "silent" };
    }
    return result;
}
function startFuncHostedBot(includeFrontend, programmingLanguage) {
    const result = {
        label: constants_2.TaskLabel.StartBot,
        type: "shell",
        command: "npm run dev:teamsfx",
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/bot",
            env: {
                PATH: "${command:fx-extension.get-func-path}${env:PATH}",
            },
        },
        problemMatcher: {
            pattern: {
                regexp: "^.*$",
                file: 0,
                location: 1,
                message: 2,
            },
            background: {
                activeOnStart: true,
                beginsPattern: "^.*(Job host stopped|signaling restart).*$",
                endsPattern: "^.*(Worker process started and initialized|Host lock lease acquired by instance ID).*$",
            },
        },
    };
    if (includeFrontend) {
        result.presentation = { reveal: "silent" };
    }
    const dependsOn = [constants_2.TaskLabel.StartAzuriteEmulator];
    if (programmingLanguage === constants_3.ProgrammingLanguage.TS) {
        dependsOn.push(constants_2.TaskLabel.WatchBot);
    }
    result.dependsOn = dependsOn;
    return result;
}
function startServices(includeFrontend, includeBackend, includeBot) {
    const dependsOn = [];
    if (includeFrontend) {
        dependsOn.push(constants_2.TaskLabel.StartFrontend);
    }
    if (includeBackend) {
        dependsOn.push(constants_2.TaskLabel.StartBackend);
    }
    if (includeBot) {
        dependsOn.push(constants_2.TaskLabel.StartBot);
    }
    return {
        label: constants_2.TaskLabel.StartServices,
        dependsOn,
    };
}
function startAzuriteEmulator() {
    return {
        label: constants_2.TaskLabel.StartAzuriteEmulator,
        type: "shell",
        command: "npm run prepare-storage:teamsfx",
        isBackground: true,
        problemMatcher: {
            pattern: [
                {
                    regexp: "^.*$",
                    file: 0,
                    location: 1,
                    message: 2,
                },
            ],
            background: {
                activeOnStart: true,
                beginsPattern: "Azurite",
                endsPattern: "successfully listening",
            },
        },
        options: {
            cwd: "${workspaceFolder}/bot",
        },
        presentation: { reveal: "silent" },
    };
}
function installAppInTeams() {
    return {
        label: constants_2.TaskLabel.InstallAppInTeams,
        type: "shell",
        command: "exit ${command:fx-extension.install-app-in-teams}",
        presentation: {
            reveal: "never",
        },
    };
}
function generateSpfxTasksJson() {
    const comment = `
  // This file is automatically generated by Teams Toolkit.
  // The teamsfx tasks defined in this file require Teams Toolkit version >= 4.1.0.
  // See https://aka.ms/teamsfx-debug-tasks for details on how to customize each task and how to integrate with existing Teams Toolkit projects.
  {}
  `;
    return commentJson.assign(commentJson.parse(comment), {
        version: "2.0.0",
        tasks: generateSpfxTasks(),
        inputs: generateInputs(),
    });
}
exports.generateSpfxTasksJson = generateSpfxTasksJson;
function generateSpfxTasks() {
    /**
     * Referenced by launch.json
     *   - Start Teams App Locally
     *
     * Referenced inside tasks.json
     *   - Validate & install prerequisites
     *   - Build & upload Teams manifest
     *   - gulp serve
     */
    return [
        startSpfxTeamsAppLocally(),
        validateAndInstallPrerequisites(false, false, false, false, true),
        buildAndUploadTeamsManifest(),
        installNPMpackages(false, false, false, true),
        gulpTrustDevCert(),
        gulpServe(),
        terminateAllTasks(),
    ];
}
function startSpfxTeamsAppLocally() {
    return {
        label: constants_1.TaskOverallLabel.TransparentDefault,
        dependsOn: [constants_2.TaskLabel.PrerequisiteCheck, constants_2.TaskLabel.PrepareManifest, constants_2.TaskLabel.GulpServe],
        dependsOrder: "sequence",
    };
}
function gulpTrustDevCert() {
    return {
        label: constants_2.TaskLabel.GulpTrustDevCert,
        type: "process",
        command: "node",
        args: ["${workspaceFolder}/SPFx/node_modules/gulp/bin/gulp.js", "trust-dev-cert"],
        options: {
            cwd: "${workspaceFolder}/SPFx",
        },
        dependsOn: constants_2.TaskLabel.InstallNpmPackages,
    };
}
function gulpServe() {
    return {
        label: "gulp serve",
        type: "process",
        command: "node",
        args: ["${workspaceFolder}/SPFx/node_modules/gulp/bin/gulp.js", "serve", "--nobrowser"],
        problemMatcher: [
            {
                pattern: [
                    {
                        regexp: ".",
                        file: 1,
                        location: 2,
                        message: 3,
                    },
                ],
                background: {
                    activeOnStart: true,
                    beginsPattern: "^.*Starting gulp.*",
                    endsPattern: "^.*Finished subtask 'reload'.*",
                },
            },
        ],
        isBackground: true,
        options: {
            cwd: "${workspaceFolder}/SPFx",
        },
        dependsOn: constants_2.TaskLabel.GulpTrustDevCert,
    };
}
function terminateAllTasks() {
    return {
        label: "Terminate All Tasks",
        command: "echo ${input:terminate}",
        type: "shell",
        problemMatcher: [],
    };
}
function generateInputs() {
    return [
        {
            id: "terminate",
            type: "command",
            command: "workbench.action.tasks.terminate",
            args: "terminateAll",
        },
    ];
}
//# sourceMappingURL=tasksTransparency.js.map