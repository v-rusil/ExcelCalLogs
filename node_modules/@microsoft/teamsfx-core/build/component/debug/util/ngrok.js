// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNgrokTunnelFromApi = exports.getNgrokHttpUrl = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
function delay(ms) {
    // tslint:disable-next-line no-string-based-set-timeout
    return new Promise((resolve) => setTimeout(resolve, ms));
}
async function getNgrokHttpUrl(addr) {
    for (let ngrokWebInterfacePort = 4040; ngrokWebInterfacePort < 4045; ++ngrokWebInterfacePort) {
        let numRetries = 5;
        while (numRetries > 0) {
            try {
                const resp = await axios_1.default.get(`http://127.0.0.1:${ngrokWebInterfacePort}/api/tunnels`);
                if (resp && resp.data) {
                    const tunnels = resp.data.tunnels;
                    // tunnels will be empty if tunnel connection is not completed
                    for (const tunnel of tunnels) {
                        if (typeof addr === "number" || Number.isInteger(Number.parseInt(addr))) {
                            addr = `http://localhost:${addr}`;
                        }
                        if (removeTrailingSlash(tunnel.config.addr) === removeTrailingSlash(addr) &&
                            tunnel.proto === "https") {
                            return tunnel.public_url;
                        }
                    }
                }
            }
            catch (err) {
                // ECONNREFUSED if ngrok is not started
            }
            await delay(2000);
            --numRetries;
        }
    }
    return undefined;
}
exports.getNgrokHttpUrl = getNgrokHttpUrl;
// TODO: support http://127.0.0.1:4040/api/tunnels/bot
async function getNgrokTunnelFromApi(webServiceUrl) {
    try {
        const resp = await axios_1.default.get(webServiceUrl);
        if (resp && resp.data) {
            const tunnels = resp.data.tunnels;
            // tunnels will be empty if tunnel connection is not completed
            for (const tunnel of tunnels) {
                if (tunnel.proto === "https") {
                    return { src: tunnel.config.addr, dist: tunnel.public_url };
                }
            }
        }
    }
    catch (err) {
        // ECONNREFUSED if ngrok is not started
    }
    return undefined;
}
exports.getNgrokTunnelFromApi = getNgrokTunnelFromApi;
function removeTrailingSlash(str) {
    return str.replace(/\/$/, "");
}
//# sourceMappingURL=ngrok.js.map