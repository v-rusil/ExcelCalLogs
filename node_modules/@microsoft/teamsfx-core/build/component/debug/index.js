"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateCommentJson = exports.updateJson = exports.useTransparentTasks = exports.useNewTasks = exports.generateLocalDebugSettingsCommon = exports.configLocalEnvironmentCommon = exports.setupLocalEnvironmentCommon = exports.generateLocalDebugSettings = exports.configLocalEnvironment = exports.setupLocalEnvironment = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const constants_1 = require("../../common/local/constants");
const localCertificateManager_1 = require("../../common/local/localCertificateManager");
const localEnvProvider_1 = require("../../common/local/localEnvProvider");
const projectSettingsHelperV3_1 = require("../../common/projectSettingsHelperV3");
const tools_1 = require("../../common/tools");
const error_1 = require("./error");
const codespace_1 = require("./util/codespace");
const localService_1 = require("./util/localService");
const ngrok_1 = require("./util/ngrok");
const telemetry_1 = require("./util/telemetry");
const constants_2 = require("../constants");
const Launch = tslib_1.__importStar(require("./util/launch"));
const LaunchNext = tslib_1.__importStar(require("./util/launchNext"));
const LaunchTransparency = tslib_1.__importStar(require("./util/launchTransparency"));
const Tasks = tslib_1.__importStar(require("./util/tasks"));
const TasksNext = tslib_1.__importStar(require("./util/tasksNext"));
const TasksTransparency = tslib_1.__importStar(require("./util/tasksTransparency"));
const Settings = tslib_1.__importStar(require("./util/settings"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const globalVars_1 = require("../../core/globalVars");
const workflow_1 = require("../workflow");
const question_1 = require("../../core/question");
const enums_1 = require("../code/api/enums");
const constants_3 = require("../feature/api/constants");
const commentJson = tslib_1.__importStar(require("comment-json"));
const os = tslib_1.__importStar(require("os"));
const constants_4 = require("../../common/local/constants");
function convertToConfig(context, inputs) {
    var _a, _b;
    const settings = context.projectSetting;
    const bot = workflow_1.getComponent(settings, constants_2.ComponentNames.TeamsBot);
    const botCapabilities = (bot === null || bot === void 0 ? void 0 : bot.capabilities) || [];
    const api = workflow_1.getComponent(settings, constants_2.ComponentNames.TeamsApi);
    let defaultFuncName;
    if (api) {
        if (api.functionNames && api.functionNames.length > 0) {
            defaultFuncName = api.functionNames[0];
        }
        defaultFuncName =
            defaultFuncName ||
                settings.defaultFunctionName ||
                inputs[enums_1.QuestionKey.functionName] ||
                constants_3.DefaultValues.functionName;
    }
    const config = {
        hasAzureTab: projectSettingsHelperV3_1.hasAzureTab(settings),
        hasSPFxTab: projectSettingsHelperV3_1.hasSPFxTab(settings),
        hasApi: projectSettingsHelperV3_1.hasApi(settings),
        hasBot: projectSettingsHelperV3_1.hasBot(settings),
        hasAAD: projectSettingsHelperV3_1.hasAAD(settings),
        hasSimpleAuth: projectSettingsHelperV3_1.hasSimpleAuth(settings),
        hasFunctionBot: projectSettingsHelperV3_1.hasFunctionBot(settings),
        botCapabilities: botCapabilities,
        defaultFunctionName: defaultFuncName,
        programmingLanguage: settings.programmingLanguage || inputs[question_1.CoreQuestionNames.ProgrammingLanguage] || "javascript",
        isM365: settings.isM365,
        skipNgrok: (_a = inputs.checkerInfo) === null || _a === void 0 ? void 0 : _a.skipNgrok,
        vscodeEnv: inputs.vscodeEnv,
        trustDevCert: (_b = inputs.checkerInfo) === null || _b === void 0 ? void 0 : _b.trustDevCert,
    };
    return config;
}
async function setupLocalEnvironment(context, inputs) {
    const config = convertToConfig(context, inputs);
    return await setupLocalEnvironmentCommon(inputs, config, context.envInfo);
}
exports.setupLocalEnvironment = setupLocalEnvironment;
async function configLocalEnvironment(context, inputs) {
    const config = convertToConfig(context, inputs);
    return await configLocalEnvironmentCommon(inputs, config, context.envInfo);
}
exports.configLocalEnvironment = configLocalEnvironment;
async function generateLocalDebugSettings(context, inputs) {
    const config = convertToConfig(context, inputs);
    return await generateLocalDebugSettingsCommon(inputs, config);
}
exports.generateLocalDebugSettings = generateLocalDebugSettings;
async function setupLocalEnvironmentCommon(inputs, config, envInfo) {
    var _a, _b, _c;
    var _d, _e;
    const API_STATE_KEY = constants_2.ComponentNames.TeamsApi;
    const TAB_STATE_KEY = constants_2.ComponentNames.TeamsTab;
    const BOT_STATE_KEY = constants_2.ComponentNames.TeamsBot;
    const SIMPLE_AUTH_STATE_KEY = constants_2.ComponentNames.SimpleAuth;
    const vscEnv = inputs.vscodeEnv;
    const includeTab = config.hasAzureTab;
    const includeBackend = config.hasApi;
    const includeBot = config.hasBot;
    const includeAAD = config.hasAAD;
    const includeSimpleAuth = config.hasSimpleAuth;
    const skipNgrok = config.skipNgrok;
    const includeFuncHostedBot = config.hasFunctionBot;
    const botCapabilities = config.botCapabilities;
    const telemetryProperties = {
        platform: inputs.platform,
        vscenv: vscEnv,
        frontend: includeTab ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "skip-ngrok": skipNgrok ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
    };
    telemetry_1.TelemetryUtils.init(globalVars_1.TOOLS.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, telemetryProperties);
    try {
        // setup configs used by other plugins
        // TODO: dynamicly determine local ports
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            const frontendPort = 53000;
            const authPort = 55000;
            let localTabEndpoint;
            let localTabDomain;
            let localAuthEndpoint;
            let localFuncEndpoint;
            if (vscEnv === teamsfx_api_1.VsCodeEnv.codespaceBrowser || vscEnv === teamsfx_api_1.VsCodeEnv.codespaceVsCode) {
                const codespaceName = await codespace_1.getCodespaceName();
                localTabEndpoint = codespace_1.getCodespaceUrl(codespaceName, frontendPort);
                localTabDomain = new URL(localTabEndpoint).host;
                localAuthEndpoint = codespace_1.getCodespaceUrl(codespaceName, authPort);
                localFuncEndpoint = codespace_1.getCodespaceUrl(codespaceName, 7071);
            }
            else {
                localTabDomain = "localhost";
                localTabEndpoint = `https://localhost:${frontendPort}`;
                localAuthEndpoint = `http://localhost:${authPort}`;
                localFuncEndpoint = "http://localhost:7071";
            }
            if (includeAAD) {
                envInfo.state[SIMPLE_AUTH_STATE_KEY] = envInfo.state[SIMPLE_AUTH_STATE_KEY] || {};
                if (includeSimpleAuth) {
                    envInfo.state[SIMPLE_AUTH_STATE_KEY].endpoint = localAuthEndpoint;
                }
            }
            if (includeTab) {
                envInfo.state[TAB_STATE_KEY] = envInfo.state[TAB_STATE_KEY] || {};
                envInfo.state[TAB_STATE_KEY].endpoint = localTabEndpoint;
                envInfo.state[TAB_STATE_KEY].domain = localTabDomain;
            }
            if (includeBackend) {
                envInfo.state[API_STATE_KEY] = envInfo.state[API_STATE_KEY] || {};
                envInfo.state[API_STATE_KEY].functionEndpoint = localFuncEndpoint;
            }
            if (includeBot) {
                envInfo.state[BOT_STATE_KEY] = envInfo.state[BOT_STATE_KEY] || {};
                if (skipNgrok) {
                    const localBotEndpoint = (_a = envInfo.config.bot) === null || _a === void 0 ? void 0 : _a.siteEndpoint;
                    if (localBotEndpoint === undefined) {
                        const error = error_1.LocalBotEndpointNotConfigured();
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    const botEndpointRegex = /https:\/\/.*(:\d+)?/g;
                    if (!botEndpointRegex.test(localBotEndpoint)) {
                        const error = error_1.InvalidLocalBotEndpointFormat(localBotEndpoint);
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    // validDomain is old style state key for backward compatibility
                    envInfo.state[BOT_STATE_KEY].siteEndpoint = localBotEndpoint;
                    envInfo.state[BOT_STATE_KEY].validDomain = localBotEndpoint.slice(8);
                    envInfo.state[BOT_STATE_KEY].domain = localBotEndpoint.slice(8);
                }
                else {
                    const ngrokHttpUrl = await ngrok_1.getNgrokHttpUrl(3978);
                    if (!ngrokHttpUrl) {
                        const error = error_1.NgrokTunnelNotConnected();
                        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                        return teamsfx_api_1.err(error);
                    }
                    else {
                        envInfo.state[BOT_STATE_KEY].siteEndpoint = ngrokHttpUrl;
                        envInfo.state[BOT_STATE_KEY].validDomain = ngrokHttpUrl.slice(8);
                        envInfo.state[BOT_STATE_KEY].domain = ngrokHttpUrl.slice(8);
                    }
                }
            }
        }
        else if (inputs.platform === teamsfx_api_1.Platform.VS) {
            if (includeTab) {
                (_b = (_d = envInfo.state)[TAB_STATE_KEY]) !== null && _b !== void 0 ? _b : (_d[TAB_STATE_KEY] = {});
                envInfo.state[TAB_STATE_KEY].endpoint = "https://localhost:44302";
                envInfo.state[TAB_STATE_KEY].domain = "localhost";
            }
            if (includeBot) {
                (_c = (_e = envInfo.state)[BOT_STATE_KEY]) !== null && _c !== void 0 ? _c : (_e[BOT_STATE_KEY] = {});
                const ngrokHttpUrl = await ngrok_1.getNgrokHttpUrl(5130);
                if (!ngrokHttpUrl) {
                    const error = error_1.NgrokTunnelNotConnected();
                    telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, error);
                    return teamsfx_api_1.err(error);
                }
                else {
                    envInfo.state[BOT_STATE_KEY].siteEndpoint = ngrokHttpUrl;
                    envInfo.state[BOT_STATE_KEY].validDomain = ngrokHttpUrl.slice(8);
                    envInfo.state[BOT_STATE_KEY].domain = ngrokHttpUrl.slice(8);
                }
            }
        }
    }
    catch (error) {
        const systemError = error_1.SetupLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.setupLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.setupLocalEnvironmentCommon = setupLocalEnvironmentCommon;
async function configLocalEnvironmentCommon(inputs, config, envInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const API_STATE_KEY = constants_2.ComponentNames.TeamsApi;
    const AAD_STATE_KEY = constants_2.ComponentNames.AadApp;
    const TAB_STATE_KEY = constants_2.ComponentNames.TeamsTab;
    const BOT_STATE_KEY = constants_2.ComponentNames.TeamsBot;
    const SIMPLE_AUTH_STATE_KEY = constants_2.ComponentNames.SimpleAuth;
    const APP_MANIFEST_KEY = constants_2.ComponentNames.AppManifest;
    const includeTab = config.hasAzureTab;
    const includeBackend = config.hasApi;
    const includeBot = config.hasBot;
    const includeAAD = config.hasAAD;
    const includeSimpleAuth = config.hasSimpleAuth;
    const includeFuncHostedBot = config.hasFunctionBot;
    const botCapabilities = config.botCapabilities;
    let trustDevCert = config.trustDevCert;
    const telemetryProperties = {
        platform: inputs.platform,
        frontend: includeTab ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
        "trust-development-certificate": trustDevCert + "",
    };
    telemetry_1.TelemetryUtils.init(globalVars_1.TOOLS.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, telemetryProperties);
    try {
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            const localEnvProvider = new localEnvProvider_1.LocalEnvProvider(inputs.projectPath);
            const frontendEnvs = includeTab
                ? await localEnvProvider.loadFrontendLocalEnvs(includeBackend, includeAAD)
                : undefined;
            const backendEnvs = includeBackend
                ? await localEnvProvider.loadBackendLocalEnvs()
                : undefined;
            const botEnvs = includeBot ? await localEnvProvider.loadBotLocalEnvs() : undefined;
            // get config for local debug
            const clientId = (_a = envInfo.state[AAD_STATE_KEY]) === null || _a === void 0 ? void 0 : _a.clientId;
            const clientSecret = (_b = envInfo.state[AAD_STATE_KEY]) === null || _b === void 0 ? void 0 : _b.clientSecret;
            const applicationIdUri = (_c = envInfo.state[AAD_STATE_KEY]) === null || _c === void 0 ? void 0 : _c.applicationIdUris;
            const teamsAppTenantId = ((_d = envInfo.state[APP_MANIFEST_KEY]) === null || _d === void 0 ? void 0 : _d.tenantId) || envInfo.state.solution.teamsAppTenantId;
            const localTabEndpoint = (_e = envInfo.state[TAB_STATE_KEY]) === null || _e === void 0 ? void 0 : _e.endpoint;
            const localFuncEndpoint = (_f = envInfo.state[API_STATE_KEY]) === null || _f === void 0 ? void 0 : _f.functionEndpoint;
            const localAuthEndpoint = (_g = envInfo.state[SIMPLE_AUTH_STATE_KEY]) === null || _g === void 0 ? void 0 : _g.endpoint;
            const localAuthPackagePath = (_h = envInfo.state[SIMPLE_AUTH_STATE_KEY]) === null || _h === void 0 ? void 0 : _h.simpleAuthFilePath;
            if (includeTab) {
                frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.Port] = "53000";
                frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.Browser] = "none";
                frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.Https] = "true";
                if (includeAAD) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.LoginUrl] = `${localTabEndpoint}/auth-start.html`;
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.ClientId] = clientId;
                }
                if (includeSimpleAuth) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.TeamsFxEndpoint] = localAuthEndpoint;
                    await localService_1.prepareLocalAuthService(localAuthPackagePath);
                }
                if (includeBackend) {
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.FuncEndpoint] = localFuncEndpoint;
                    frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.FuncName] = config.defaultFunctionName;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.FuncWorkerRuntime] = "node";
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ClientId] = clientId;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ClientSecret] = clientSecret;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.AuthorityHost] =
                        "https://login.microsoftonline.com";
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.TenantId] = teamsAppTenantId;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApiEndpoint] = localFuncEndpoint;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApplicationIdUri] = applicationIdUri;
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.AllowedAppIds] =
                        tools_1.getAllowedAppIds().join(";");
                }
                // setup local certificate
                try {
                    if (trustDevCert === undefined) {
                        trustDevCert = true;
                    }
                    const certManager = new localCertificateManager_1.LocalCertificateManager(globalVars_1.TOOLS.ui, globalVars_1.TOOLS.logProvider);
                    const localCert = await certManager.setupCertificate(trustDevCert);
                    if (envInfo.config.frontend &&
                        envInfo.config.frontend.sslCertFile &&
                        envInfo.config.frontend.sslKeyFile) {
                        envInfo.state[TAB_STATE_KEY].sslCertFile = envInfo.config.frontend.sslCertFile;
                        envInfo.state[TAB_STATE_KEY].sslKeyFile = envInfo.config.frontend.sslKeyFile;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslCrtFile] =
                            envInfo.config.frontend.sslCertFile;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslKeyFile] =
                            envInfo.config.frontend.sslKeyFile;
                    }
                    else if (localCert) {
                        envInfo.state[TAB_STATE_KEY].sslCertFile = localCert.certPath;
                        envInfo.state[TAB_STATE_KEY].sslKeyFile = localCert.keyPath;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslCrtFile] = localCert.certPath;
                        frontendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysFrontend.SslKeyFile] = localCert.keyPath;
                    }
                }
                catch (error) {
                    // do not break if cert error
                }
            }
            if (includeBot) {
                const botId = (_j = envInfo.state[BOT_STATE_KEY]) === null || _j === void 0 ? void 0 : _j.botId;
                const botPassword = (_k = envInfo.state[BOT_STATE_KEY]) === null || _k === void 0 ? void 0 : _k.botPassword;
                botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.BotId] = botId;
                botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.BotPassword] = botPassword;
                if (includeAAD) {
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ClientId] = clientId;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ClientSecret] = clientSecret;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.TenantID] = teamsAppTenantId;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.OauthAuthority] =
                        "https://login.microsoftonline.com";
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.LoginEndpoint] = `${(_l = envInfo.state[BOT_STATE_KEY]) === null || _l === void 0 ? void 0 : _l.siteEndpoint}/auth-start.html`;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ApplicationIdUri] = applicationIdUri;
                }
                if (includeBackend) {
                    backendEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBackend.ApiEndpoint] = localFuncEndpoint;
                    botEnvs.teamsfxLocalEnvs[localEnvProvider_1.EnvKeysBot.ApiEndpoint] = localFuncEndpoint;
                }
            }
            // save .env.teamsfx.local
            await localEnvProvider.saveLocalEnvs(frontendEnvs, backendEnvs, botEnvs);
        }
    }
    catch (error) {
        const systemError = error_1.ConfigLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.configLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.configLocalEnvironmentCommon = configLocalEnvironmentCommon;
async function generateLocalDebugSettingsCommon(inputs, config) {
    const isSpfx = config.hasSPFxTab === true;
    const includeFrontend = config.hasAzureTab;
    const includeBackend = config.hasApi;
    const includeBot = config.hasBot;
    const includeAAD = config.hasAAD;
    const includeSimpleAuth = config.hasSimpleAuth;
    const includeFuncHostedBot = config.hasFunctionBot;
    const botCapabilities = config.botCapabilities;
    const programmingLanguage = config.programmingLanguage;
    const isM365 = config.isM365;
    const telemetryProperties = {
        platform: inputs.platform,
        spfx: isSpfx ? "true" : "false",
        frontend: includeFrontend ? "true" : "false",
        function: includeBackend ? "true" : "false",
        bot: includeBot ? "true" : "false",
        auth: includeAAD && includeSimpleAuth ? "true" : "false",
        "bot-host-type": includeFuncHostedBot ? constants_1.BotHostTypes.AzureFunctions : constants_1.BotHostTypes.AppService,
        "bot-capabilities": JSON.stringify(botCapabilities),
        "programming-language": programmingLanguage,
    };
    telemetry_1.TelemetryUtils.init(globalVars_1.TOOLS.telemetryReporter);
    telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, telemetryProperties);
    try {
        // scaffold for both vscode and cli
        if (inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI) {
            if (isSpfx) {
                const isTransparent = await useTransparentTasks(inputs.projectPath);
                // Only generate launch.json and tasks.json for SPFX
                const launchConfigurations = isTransparent
                    ? LaunchTransparency.generateSpfxConfigurations()
                    : Launch.generateSpfxConfigurations();
                const launchCompounds = isTransparent
                    ? LaunchTransparency.generateSpfxCompounds()
                    : Launch.generateSpfxCompounds();
                await fs_extra_1.default.ensureDir(`${inputs.projectPath}/.vscode/`);
                await updateJson(`${inputs.projectPath}/.vscode/launch.json`, {
                    version: "0.2.0",
                    configurations: launchConfigurations,
                    compounds: launchCompounds,
                }, LaunchNext.mergeLaunches);
                if (isTransparent) {
                    const transparentTasksJson = TasksTransparency.generateSpfxTasksJson();
                    await updateCommentJson(`${inputs.projectPath}/.vscode/tasks.json`, transparentTasksJson, TasksTransparency.mergeTasksJson);
                }
                else {
                    const tasks = Tasks.generateSpfxTasks();
                    const tasksInputs = Tasks.generateInputs();
                    await updateJson(`${inputs.projectPath}/.vscode/tasks.json`, {
                        version: "2.0.0",
                        tasks: tasks,
                        inputs: tasksInputs,
                    }, TasksNext.mergeTasks);
                }
            }
            else {
                await fs_extra_1.default.ensureDir(`${inputs.projectPath}/.vscode/`);
                if (await useTransparentTasks(inputs.projectPath)) {
                    const launchConfigurations = isM365
                        ? LaunchTransparency.generateM365Configurations(includeFrontend, includeBackend, includeBot)
                        : LaunchTransparency.generateConfigurations(includeFrontend, includeBackend, includeBot);
                    const launchCompounds = isM365
                        ? LaunchTransparency.generateM365Compounds(includeFrontend, includeBackend, includeBot)
                        : LaunchTransparency.generateCompounds(includeFrontend, includeBackend, includeBot);
                    await updateJson(`${inputs.projectPath}/.vscode/launch.json`, {
                        version: "0.2.0",
                        configurations: launchConfigurations,
                        compounds: launchCompounds,
                    }, LaunchNext.mergeLaunches);
                    const tasksJson = isM365
                        ? TasksTransparency.generateM365TasksJson(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeAAD, programmingLanguage)
                        : TasksTransparency.generateTasksJson(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, includeAAD, programmingLanguage);
                    await updateCommentJson(`${inputs.projectPath}/.vscode/tasks.json`, tasksJson, TasksTransparency.mergeTasksJson);
                }
                else {
                    const launchConfigurations = isM365
                        ? LaunchNext.generateM365Configurations(includeFrontend, includeBackend, includeBot)
                        : (await useNewTasks(inputs.projectPath))
                            ? LaunchNext.generateConfigurations(includeFrontend, includeBackend, includeBot)
                            : Launch.generateConfigurations(includeFrontend, includeBackend, includeBot);
                    const launchCompounds = isM365
                        ? LaunchNext.generateM365Compounds(includeFrontend, includeBackend, includeBot)
                        : (await useNewTasks(inputs.projectPath))
                            ? LaunchNext.generateCompounds(includeFrontend, includeBackend, includeBot)
                            : Launch.generateCompounds(includeFrontend, includeBackend, includeBot);
                    const tasks = isM365
                        ? TasksNext.generateM365Tasks(includeFrontend, includeBackend, includeBot, programmingLanguage)
                        : (await useNewTasks(inputs.projectPath))
                            ? TasksNext.generateTasks(includeFrontend, includeBackend, includeBot, includeFuncHostedBot, programmingLanguage)
                            : Tasks.generateTasks(includeFrontend, includeBackend, includeBot, includeSimpleAuth, programmingLanguage);
                    await updateJson(`${inputs.projectPath}/.vscode/launch.json`, {
                        version: "0.2.0",
                        configurations: launchConfigurations,
                        compounds: launchCompounds,
                    }, LaunchNext.mergeLaunches);
                    await updateJson(`${inputs.projectPath}/.vscode/tasks.json`, {
                        version: "2.0.0",
                        tasks: tasks,
                    }, TasksNext.mergeTasks);
                }
            }
            await updateJson(`${inputs.projectPath}/.vscode/settings.json`, Settings.generateSettings(includeBackend || includeFuncHostedBot, isSpfx), Settings.mergeSettings);
        }
    }
    catch (error) {
        const systemError = error_1.ScaffoldLocalDebugSettingsError(error);
        telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, systemError);
        return teamsfx_api_1.err(systemError);
    }
    telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.scaffoldLocalDebugSettings, telemetryProperties);
    return teamsfx_api_1.ok(undefined);
}
exports.generateLocalDebugSettingsCommon = generateLocalDebugSettingsCommon;
async function useNewTasks(projectPath) {
    // for new project or project with "validate-local-prerequisites", use new tasks content
    const tasksJsonPath = `${projectPath}/.vscode/tasks.json`;
    if (await fs_extra_1.default.pathExists(tasksJsonPath)) {
        try {
            const tasksContent = await fs_extra_1.default.readFile(tasksJsonPath, "utf-8");
            return tasksContent.includes("fx-extension.validate-local-prerequisites");
        }
        catch (error) {
            return false;
        }
    }
    return true;
}
exports.useNewTasks = useNewTasks;
async function useTransparentTasks(projectPath) {
    // for new project or project with "debug-check-prerequisites", use transparent tasks content
    const tasksJsonPath = `${projectPath}/.vscode/tasks.json`;
    if (await fs_extra_1.default.pathExists(tasksJsonPath)) {
        try {
            const tasksContent = await fs_extra_1.default.readFile(tasksJsonPath, "utf-8");
            for (const command of Object.values(constants_4.TaskCommand)) {
                if (tasksContent.includes(command)) {
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            return false;
        }
    }
    return true;
}
exports.useTransparentTasks = useTransparentTasks;
async function updateJson(path, newData, mergeFunc) {
    let finalData;
    if (await fs_extra_1.default.pathExists(path)) {
        try {
            const existingData = await fs_extra_1.default.readJSON(path);
            finalData = mergeFunc(existingData, newData);
        }
        catch (error) {
            // If failed to parse or edit the existing file, just overwrite completely
            finalData = newData;
        }
    }
    else {
        finalData = newData;
    }
    await fs_extra_1.default.writeJSON(path, finalData, {
        spaces: 4,
        EOL: os.EOL,
    });
}
exports.updateJson = updateJson;
async function updateCommentJson(path, newData, mergeFunc) {
    let finalData;
    if (await fs_extra_1.default.pathExists(path)) {
        try {
            const content = await fs_extra_1.default.readFile(path);
            const existingData = commentJson.parse(content.toString());
            finalData = mergeFunc(existingData, newData);
        }
        catch (error) {
            // If failed to parse or edit the existing file, just overwrite completely
            finalData = newData;
        }
    }
    else {
        finalData = newData;
    }
    await fs_extra_1.default.writeFile(path, commentJson.stringify(finalData, null, 4));
}
exports.updateCommentJson = updateCommentJson;
//# sourceMappingURL=index.js.map