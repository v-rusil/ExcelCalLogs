"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionScaffold = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const error_1 = require("../error");
const templatesActions_1 = require("../../../common/template-utils/templatesActions");
const constants_1 = require("../../constants");
const error_2 = require("../../error");
const messages_1 = require("../../messages");
const constants_2 = require("../constants");
const language_strategy_1 = require("./language-strategy");
class FunctionScaffold {
    static convertTemplateLanguage(language) {
        switch (language) {
            case constants_1.ProgrammingLanguage.JS:
                return "js";
            case constants_1.ProgrammingLanguage.TS:
                return "ts";
            default:
                throw new error_2.invalidProjectSettings(messages_1.ErrorMessage.programmingLanguageInvalid);
        }
    }
    static async doesFunctionPathExist(componentPath, language, entryName) {
        const entryFileOrFolderName = language_strategy_1.LanguageStrategyFactory.getStrategy(language).getFunctionEntryFileOrFolderName(entryName);
        return fs.pathExists(path_1.default.join(componentPath, entryFileOrFolderName));
    }
    static async scaffoldFromZipPackage(componentPath, group, language, scenario, variables, nameReplaceFn, logger) {
        const _nameReplaceFn = (name, data) => {
            name = nameReplaceFn ? nameReplaceFn(name, data) : name;
            return templatesActions_1.removeTemplateExtReplaceFn(name, data);
        };
        await templatesActions_1.scaffoldFromTemplates({
            group: group,
            lang: this.convertTemplateLanguage(language),
            scenario: scenario,
            dst: componentPath,
            fileNameReplaceFn: _nameReplaceFn,
            fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    logger === null || logger === void 0 ? void 0 : logger.info(messages_1.LogMessages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : ""));
                }
            },
            onActionError: async (action, context, error) => {
                logger === null || logger === void 0 ? void 0 : logger.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        logger === null || logger === void 0 ? void 0 : logger.info(messages_1.LogMessages.getTemplateFromLocal);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new error_1.TemplateZipFallbackError("BE");
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new error_1.UnzipError("BE");
                    default:
                        throw new Error(error.message);
                }
            },
        });
    }
    static async scaffoldFunction(componentPath, language, trigger, entryName, variables, logger) {
        await this.ensureFunctionAppProject(componentPath, language, variables, logger);
        await this.scaffoldFromZipPackage(componentPath, constants_2.TemplateGroup.apiTriggers, language, trigger, variables, (name) => name.replace(constants_2.TemplatePlaceHolders.functionEntry, entryName));
    }
    /*
     * Always call ensure project before scaffold a function entry.
     */
    static async ensureFunctionAppProject(componentPath, language, variables, logger) {
        const exists = await fs.pathExists(componentPath);
        if (exists) {
            logger === null || logger === void 0 ? void 0 : logger.info(messages_1.LogMessages.projectScaffoldAt(componentPath));
            return;
        }
        await this.scaffoldFromZipPackage(componentPath, constants_2.TemplateGroup.apiBase, language, constants_2.ApiConstants.baseScenarioName, variables);
    }
}
exports.FunctionScaffold = FunctionScaffold;
//# sourceMappingURL=scaffold.js.map