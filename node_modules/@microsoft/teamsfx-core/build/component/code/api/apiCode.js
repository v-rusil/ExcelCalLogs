"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiCodeProvider = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const depsChecker_1 = require("../../../common/deps-checker/depsChecker");
const checkerFactory_1 = require("../../../common/deps-checker/checkerFactory");
const question_1 = require("../../../core/question");
const scaffold_1 = require("./scaffold");
const funcHelper_1 = require("./depsChecker/funcHelper");
const constants_1 = require("../../constants");
const error_1 = require("../../error");
const messages_1 = require("../../messages");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const workflow_1 = require("../../workflow");
const depsError_1 = require("../../../common/deps-checker/depsError");
const language_strategy_1 = require("./language-strategy");
const utils_1 = require("../utils");
const constants_2 = require("../constants");
const deps_checker_1 = require("../../../common/deps-checker");
const funcPluginTelemetry_1 = require("./depsChecker/funcPluginTelemetry");
const enums_1 = require("./enums");
const funcPluginLogger_1 = require("./depsChecker/funcPluginLogger");
/**
 * api scaffold
 */
let ApiCodeProvider = class ApiCodeProvider {
    constructor() {
        this.name = "api-code";
    }
    async generate(context, inputs, actionContext) {
        var _a;
        const projectSettings = context.projectSetting;
        const appName = projectSettings.appName;
        const language = inputs[question_1.CoreQuestionNames.ProgrammingLanguage];
        const folder = inputs.folder || constants_1.PathConstants.apiWorkingDir;
        const workingDir = path.join(inputs.projectPath, folder);
        const functionName = inputs[enums_1.QuestionKey.functionName];
        const variables = {
            appName: appName,
            functionName: functionName,
        };
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.scaffoldApi));
        await scaffold_1.FunctionScaffold.scaffoldFunction(workingDir, language, constants_2.ApiConstants.functionTriggerType, functionName, variables, context.logProvider);
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        const teamsApi = workflow_1.getComponent(context.projectSetting, constants_1.ComponentNames.TeamsApi);
        if (!teamsApi)
            return teamsfx_api_1.ok(undefined);
        if (teamsApi.folder == undefined)
            throw new error_1.BadComponent("api", this.name, "folder");
        const language = context.projectSetting.programmingLanguage;
        if (!language || !Object.values(constants_1.ProgrammingLanguage).includes(language))
            throw new error_1.invalidProjectSettings(messages_1.ErrorMessage.programmingLanguageInvalid);
        const buildPath = path.resolve(inputs.projectPath, teamsApi.folder);
        await this.handleDotnetChecker(context, inputs);
        try {
            await this.installFuncExtensions(buildPath, language, context.logProvider);
        }
        catch (error) {
            if (error instanceof Error) {
                // wrap the original error to UserError so the extensibility model will pop-up a dialog correctly
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            else {
                throw error;
            }
        }
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.buildingApi));
        for (const commandItem of language_strategy_1.LanguageStrategyFactory.getStrategy(language)
            .buildCommands) {
            const command = commandItem.command;
            const relativePath = commandItem.relativePath;
            const absolutePath = path.join(buildPath, relativePath);
            await utils_1.execute(command, absolutePath, context.logProvider);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async handleDotnetChecker(ctx, inputs) {
        const funcDepsLogger = new funcPluginLogger_1.FuncPluginLogger(ctx.logProvider);
        const dotnetChecker = checkerFactory_1.CheckerFactory.createChecker(depsChecker_1.DepsType.Dotnet, funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        try {
            if (!(await funcHelper_1.funcDepsHelper.dotnetCheckerEnabled(inputs))) {
                return;
            }
            await dotnetChecker.resolve();
        }
        catch (error) {
            if (error instanceof depsError_1.LinuxNotSupportedError) {
                return;
            }
            if (error instanceof Error) {
                funcDepsLogger.error(messages_1.LogMessages.failedToInstallDotnet(error));
                await funcDepsLogger.printDetailLog();
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            else {
                throw error;
            }
        }
        finally {
            funcDepsLogger.cleanup();
        }
    }
    async installFuncExtensions(componentPath, language, logger) {
        if (language_strategy_1.LanguageStrategyFactory.getStrategy(language).skipFuncExtensionInstall) {
            return;
        }
        const funcDepsLogger = new funcPluginLogger_1.FuncPluginLogger(logger);
        const binPath = path.join(componentPath, constants_1.PathConstants.functionExtensionsFolder);
        const depsManager = new deps_checker_1.DepsManager(funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        const dotnetStatus = (await depsManager.getStatus([depsChecker_1.DepsType.Dotnet]))[0];
        await funcHelper_1.funcDepsHelper.installFuncExtension(componentPath, dotnetStatus.command, funcDepsLogger, constants_1.PathConstants.functionExtensionsFile, binPath);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.scaffoldApi,
            progressSteps: 1,
            errorSource: "api",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ApiCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.buildingApi,
            progressSteps: 1,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ApiCodeProvider.prototype, "build", null);
ApiCodeProvider = tslib_1.__decorate([
    typedi_1.Service("api-code")
], ApiCodeProvider);
exports.ApiCodeProvider = ApiCodeProvider;
//# sourceMappingURL=apiCode.js.map