"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaffoldSPFx = exports.SPFxTabCodeProvider = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const featureFlags_1 = require("../../common/featureFlags");
const tools_1 = require("../../common/tools");
const folder_1 = require("../../folder");
const constants_1 = require("../resource/appManifest/constants");
const generatorChecker_1 = require("../resource/spfx/depsChecker/generatorChecker");
const yoChecker_1 = require("../resource/spfx/depsChecker/yoChecker");
const error_1 = require("../resource/spfx/error");
const constants_2 = require("../resource/spfx/utils/constants");
const progress_helper_1 = require("../resource/spfx/utils/progress-helper");
const questions_1 = require("../resource/spfx/utils/questions");
const utils_1 = require("../resource/spfx/utils/utils");
const cpUtils_1 = require("../utils/depsChecker/cpUtils");
const constants_3 = require("../constants");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const manifestProvider_1 = require("../resource/appManifest/manifestProvider");
const workflow_1 = require("../workflow");
/**
 * SPFx tab scaffold
 */
let SPFxTabCodeProvider = class SPFxTabCodeProvider {
    constructor() {
        this.name = constants_3.ComponentNames.SPFxTabCode;
    }
    async generate(context, inputs) {
        const projectSettings = context.projectSetting;
        const folder = inputs.folder || "SPFx";
        const teamsTab = workflow_1.getComponent(projectSettings, constants_3.ComponentNames.TeamsTab);
        if (!teamsTab)
            return teamsfx_api_1.ok(undefined);
        lodash_1.merge(teamsTab, { build: true, folder: folder });
        const workingDir = path.resolve(inputs.projectPath, folder);
        const scaffoldRes = await scaffoldSPFx(context, inputs, workingDir);
        if (scaffoldRes.isErr())
            return teamsfx_api_1.err(scaffoldRes.error);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-spfx",
            telemetryEventName: "scaffold",
            errorSource: "SPFx",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxTabCodeProvider.prototype, "generate", null);
SPFxTabCodeProvider = tslib_1.__decorate([
    typedi_1.Service(constants_3.ComponentNames.SPFxTabCode)
], SPFxTabCodeProvider);
exports.SPFxTabCodeProvider = SPFxTabCodeProvider;
async function scaffoldSPFx(context, inputs, outputFolderPath) {
    var _a, _b, _c, _d, _e;
    const ui = context.userInteraction;
    const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ui);
    try {
        const isAddSpfx = inputs.stage === teamsfx_api_1.Stage.addFeature && featureFlags_1.isSPFxMultiTabEnabled();
        const webpartName = inputs[questions_1.SPFXQuestionNames.webpart_name];
        const framework = (_a = inputs[questions_1.SPFXQuestionNames.framework_type]) !== null && _a !== void 0 ? _a : undefined;
        let solutionName = undefined;
        if (!isAddSpfx) {
            solutionName = context.projectSetting.appName;
        }
        else {
            const yorcPath = path.join(inputs.projectPath, "SPFx", ".yo-rc.json");
            if (!(await fs_extra_1.default.pathExists(yorcPath))) {
                throw error_1.NoConfigurationError();
            }
        }
        const componentName = utils_1.Utils.normalizeComponentName(webpartName);
        const componentNameCamelCase = lodash_1.camelCase(componentName);
        const templateFolder = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "spfx");
        const replaceMap = new Map();
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.ScaffoldProgressMessage.DependencyCheck));
        const yoChecker = new yoChecker_1.YoChecker(context.logProvider);
        const spGeneratorChecker = new generatorChecker_1.GeneratorChecker(context.logProvider);
        const yoInstalled = await yoChecker.isInstalled();
        const generatorInstalled = await spGeneratorChecker.isInstalled();
        if (!yoInstalled || !generatorInstalled) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.ScaffoldProgressMessage.DependencyInstall));
            if (tools_1.isYoCheckerEnabled()) {
                const yoRes = await yoChecker.ensureDependency(context);
                if (yoRes.isErr()) {
                    throw error_1.DependencyInstallError("yo");
                }
            }
            if (tools_1.isGeneratorCheckerEnabled()) {
                const spGeneratorRes = await spGeneratorChecker.ensureDependency(context);
                if (spGeneratorRes.isErr()) {
                    throw error_1.DependencyInstallError("sharepoint generator");
                }
            }
        }
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.ScaffoldProgressMessage.ScaffoldProject));
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            context.logProvider.outputChannel.show();
        }
        const yoEnv = process.env;
        yoEnv.PATH = tools_1.isYoCheckerEnabled()
            ? `${await (await yoChecker.getBinFolders()).join(path.delimiter)}${path.delimiter}${(_b = process.env.PATH) !== null && _b !== void 0 ? _b : ""}`
            : process.env.PATH;
        const args = [
            tools_1.isGeneratorCheckerEnabled()
                ? spGeneratorChecker.getSpGeneratorPath()
                : "@microsoft/sharepoint",
            "--skip-install",
            "true",
            "--component-type",
            "webpart",
            "--component-name",
            webpartName,
            "--environment",
            "spo",
            "--skip-feature-deployment",
            "true",
            "--is-domain-isolated",
            "false",
        ];
        if (framework) {
            args.push("--framework", framework);
        }
        if (solutionName) {
            args.push("--solution-name", solutionName);
        }
        await cpUtils_1.cpUtils.executeCommand(isAddSpfx ? path.join(inputs.projectPath, "SPFx") : inputs.projectPath, context.logProvider, {
            timeout: 2 * 60 * 1000,
            env: yoEnv,
        }, "yo", ...args);
        const newPath = path.join(inputs.projectPath, "SPFx");
        if (!isAddSpfx) {
            const currentPath = path.join(inputs.projectPath, solutionName);
            await fs_extra_1.default.rename(currentPath, newPath);
        }
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.ScaffoldProgressMessage.UpdateManifest));
        const manifestPath = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.manifest.json`;
        const manifest = await fs_extra_1.default.readFile(manifestPath, "utf8");
        let manifestString = manifest.toString();
        manifestString = manifestString.replace(`"supportedHosts": ["SharePointWebPart"]`, `"supportedHosts": ["SharePointWebPart", "TeamsPersonalApp", "TeamsTab"]`);
        await fs_extra_1.default.writeFile(manifestPath, manifestString);
        const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
        const manifestJson = JSON.parse(manifestString.replace(matchHashComment, "").trim());
        const componentId = manifestJson.id;
        replaceMap.set(constants_2.PlaceHolders.componentId, componentId);
        replaceMap.set(constants_2.PlaceHolders.componentNameUnescaped, webpartName);
        // remove dataVersion() function, related issue: https://github.com/SharePoint/sp-dev-docs/issues/6469
        const webpartFile = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.ts`;
        const codeFile = await fs_extra_1.default.readFile(webpartFile, "utf8");
        let codeString = codeFile.toString();
        codeString = codeString.replace(`  protected get dataVersion(): Version {\r\n    return Version.parse('1.0');\r\n  }\r\n\r\n`, ``);
        codeString = codeString.replace(`import { Version } from '@microsoft/sp-core-library';\r\n`, ``);
        await fs_extra_1.default.writeFile(webpartFile, codeString);
        // remove .vscode
        const debugPath = `${newPath}/.vscode`;
        if (await fs_extra_1.default.pathExists(debugPath)) {
            await fs_extra_1.default.remove(debugPath);
        }
        // update readme
        if (!isAddSpfx) {
            await fs_extra_1.default.copyFile(path.resolve(templateFolder, "./solution/README.md"), `${outputFolderPath}/README.md`);
        }
        const manifestProvider = context.manifestProvider || new manifestProvider_1.DefaultManifestProvider();
        const capabilitiesToAddManifest = [];
        const remoteStaticSnippet = {
            entityId: componentId,
            name: webpartName,
            contentUrl: util.format(constants_2.ManifestTemplate.REMOTE_CONTENT_URL, componentId, componentId),
            websiteUrl: constants_2.ManifestTemplate.WEBSITE_URL,
            scopes: ["personal"],
        };
        if (isAddSpfx) {
            capabilitiesToAddManifest.push({
                name: "staticTab",
                snippet: remoteStaticSnippet,
            });
            const addCapRes = await manifestProvider.addCapabilities(context, inputs, capabilitiesToAddManifest);
            if (addCapRes.isErr())
                return teamsfx_api_1.err(addCapRes.error);
        }
        else {
            const appDirectory = await tools_1.getAppDirectory(inputs.projectPath);
            await utils_1.Utils.configure(path.join(appDirectory, constants_1.MANIFEST_TEMPLATE_CONSOLIDATE), replaceMap);
            const remoteConfigurableSnippet = {
                configurationUrl: util.format(constants_2.ManifestTemplate.REMOTE_CONFIGURATION_URL, componentId, componentId),
                canUpdateConfiguration: true,
                scopes: ["team"],
            };
            capabilitiesToAddManifest.push({
                name: "staticTab",
                snippet: remoteStaticSnippet,
            }, {
                name: "configurableTab",
                snippet: remoteConfigurableSnippet,
            });
            for (const capability of capabilitiesToAddManifest) {
                const addCapRes = await manifestProvider.updateCapability(context, inputs, capability);
                if (addCapRes.isErr())
                    return teamsfx_api_1.err(addCapRes.error);
            }
        }
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
        return teamsfx_api_1.ok(undefined);
    }
    catch (error) {
        if (error.name === "DependencyInstallFailed") {
            const globalYoVersion = utils_1.Utils.getPackageVersion("yo");
            const globalGenVersion = utils_1.Utils.getPackageVersion("@microsoft/generator-sharepoint");
            const yoInfo = yoChecker_1.YoChecker.getDependencyInfo();
            const genInfo = generatorChecker_1.GeneratorChecker.getDependencyInfo();
            const yoMessage = globalYoVersion === undefined
                ? "    yo not installed"
                : `    globally installed yo@${globalYoVersion}`;
            const generatorMessage = globalGenVersion === undefined
                ? "    @microsoft/generator-sharepoint not installed"
                : `    globally installed @microsoft/generator-sharepoint@${globalYoVersion}`;
            (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.error(`We've encountered some issues when trying to install prerequisites under HOME/.fx folder.  Learn how to remediate by going to this link(aka.ms/teamsfx-spfx-help) and following the steps applicable to your system: \n ${yoMessage} \n ${generatorMessage}`);
            (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.error(`Teams Toolkit recommends using ${yoInfo.displayName} ${genInfo.displayName}`);
        }
        if (error.message &&
            error.message.includes("'yo' is not recognized as an internal or external command")) {
            (_e = context.logProvider) === null || _e === void 0 ? void 0 : _e.error("NPM v6.x with Node.js v12.13.0+ (Erbium) or Node.js v14.15.0+ (Fermium) is recommended for spfx scaffolding and later development. You can use correct version and try again.");
        }
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
        return teamsfx_api_1.err(error_1.ScaffoldError(error));
    }
}
exports.scaffoldSPFx = scaffoldSPFx;
//# sourceMappingURL=spfxTabCode.js.map