"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabCodeProvider = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../../common/template-utils/templatesActions");
const utils_1 = require("../../../common/utils");
const question_1 = require("../../../core/question");
const deploy_1 = require("./deploy");
const constants_1 = require("../../constants");
const workflow_1 = require("../../workflow");
const utils_2 = require("../utils");
const env_1 = require("./env");
const projectSettingsHelper_1 = require("../../../common/projectSettingsHelper");
const messages_1 = require("../../messages");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const error_1 = require("../../error");
const error_2 = require("../error");
const appSettingUtils_1 = require("../appSettingUtils");
const baseAppSettings_json_1 = tslib_1.__importDefault(require("../appSettings/baseAppSettings.json"));
const ssoBlazorAppSettings_json_1 = tslib_1.__importDefault(require("../appSettings/ssoBlazorAppSettings.json"));
const constants_2 = require("../constants");
const telemetry_1 = require("../../../common/telemetry");
const constants_3 = require("./constants");
/**
 * tab scaffold
 */
let TabCodeProvider = class TabCodeProvider {
    constructor() {
        this.name = "tab-code";
    }
    async generate(ctx, inputs, actionContext) {
        var _a, _b;
        inputs.folder || (inputs.folder = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === constants_1.ProgrammingLanguage.CSharp
            ? ""
            : constants_1.PathConstants.tabWorkingDir);
        const langKey = utils_2.convertToLangKey(inputs[question_1.CoreQuestionNames.ProgrammingLanguage]);
        const workingDir = path.join(inputs.projectPath, inputs.folder);
        inputs.safeProjectName =
            (_a = inputs.safeProjectName) !== null && _a !== void 0 ? _a : utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName);
        const variables = {
            ProjectName: ctx.projectSetting.appName,
            SafeProjectName: inputs.safeProjectName,
        };
        const scenario = featureToScenario.get(inputs[question_1.CoreQuestionNames.Features]);
        await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_1.ProgressMessages.scaffoldTab));
        await templatesActions_1.scaffoldFromTemplates({
            group: constants_2.TemplateGroup.tab,
            lang: langKey,
            scenario: scenario,
            dst: workingDir,
            fileNameReplaceFn: (name, data) => templatesActions_1.removeTemplateExtReplaceFn(name, data).replace(constants_2.TemplatePlaceHolders.ProjectFile, ctx.projectSetting.appName),
            fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    ctx.logProvider.info(messages_1.LogMessages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : ""));
                }
            },
            onActionError: async (action, context, error) => {
                ctx.logProvider.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        ctx.logProvider.info(messages_1.LogMessages.getTemplateFromLocal);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new error_2.TemplateZipFallbackError(constants_3.errorSource);
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new error_2.UnzipError(constants_3.errorSource, workingDir);
                    default:
                        throw new Error(error.message);
                }
            },
        });
        return teamsfx_api_1.ok(inputs.folder);
    }
    async configure(context, inputs) {
        const teamsTab = workflow_1.getComponent(context.projectSetting, constants_1.ComponentNames.TeamsTab);
        const tabDir = teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.folder;
        // Non-sso tab do not need to be configured
        if (tabDir == undefined || !(teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.sso))
            return teamsfx_api_1.ok(undefined);
        if (projectSettingsHelper_1.isVSProject(context.projectSetting) && context.envInfo.envName === "local") {
            const appSettingsPath = path.resolve(inputs.projectPath, tabDir, appSettingUtils_1.AppSettingConstants.DevelopmentFileName);
            let appSettings;
            if (!(await fs.pathExists(appSettingsPath))) {
                // if appsetting file not exist, generate a new one
                appSettings = JSON.stringify(Object.assign(Object.assign({}, baseAppSettings_json_1.default), ssoBlazorAppSettings_json_1.default), null, 2);
            }
            else {
                appSettings = await fs.readFile(appSettingsPath, "utf-8");
            }
            await fs.writeFile(appSettingsPath, appSettingUtils_1.replaceBlazorAppSettings(context, appSettings), "utf-8");
        }
        else if (context.envInfo.envName !== "local") {
            const envFile = env_1.envFilePath(context.envInfo.envName, path.join(inputs.projectPath, tabDir));
            const envs = this.collectEnvs(context);
            await env_1.saveEnvFile(envFile, { teamsfxRemoteEnvs: envs, customizedRemoteEnvs: {} }, context.logProvider);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        const ctx = context;
        const teamsTab = workflow_1.getComponent(context.projectSetting, constants_1.ComponentNames.TeamsTab);
        if (!teamsTab)
            return teamsfx_api_1.ok(undefined);
        if (teamsTab.folder == undefined)
            throw new error_1.BadComponent(constants_3.errorSource, this.name, "folder");
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.buildingTab));
        const tabPath = path.resolve(inputs.projectPath, teamsTab.folder);
        const artifactFolder = projectSettingsHelper_1.isVSProject(context.projectSetting)
            ? await this.doBlazorBuild(tabPath, context.logProvider)
            : await this.doReactBuild(tabPath, ctx.envInfo.envName, context.telemetryReporter, context.logProvider);
        lodash_1.merge(teamsTab, {
            build: true,
            artifactFolder: path.join(teamsTab.folder, artifactFolder),
        });
        return teamsfx_api_1.ok(undefined);
    }
    collectEnvs(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        const teamsTab = workflow_1.getComponent(ctx.projectSetting, constants_1.ComponentNames.TeamsTab);
        const teamsApi = workflow_1.getComponent(ctx.projectSetting, constants_1.ComponentNames.TeamsApi);
        if (teamsApi) {
            addToEnvs(env_1.EnvKeys.FuncName, teamsApi.functionNames[0]);
            addToEnvs(env_1.EnvKeys.FuncEndpoint, (_c = (_b = (_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b[constants_1.ComponentNames.TeamsApi]) === null || _c === void 0 ? void 0 : _c.functionEndpoint);
        }
        if (teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.sso) {
            addToEnvs(env_1.EnvKeys.ClientID, (_f = (_e = (_d = ctx.envInfo) === null || _d === void 0 ? void 0 : _d.state) === null || _e === void 0 ? void 0 : _e[constants_1.ComponentNames.AadApp]) === null || _f === void 0 ? void 0 : _f.clientId);
            addToEnvs(env_1.EnvKeys.StartLoginPage, constants_3.DefaultValues.authFileName);
        }
        const simpleAuth = workflow_1.getComponent(ctx.projectSetting, constants_1.ComponentNames.SimpleAuth);
        if (simpleAuth) {
            addToEnvs(env_1.EnvKeys.RuntimeEndpoint, (_j = (_h = (_g = ctx.envInfo) === null || _g === void 0 ? void 0 : _g.state) === null || _h === void 0 ? void 0 : _h[constants_1.ComponentNames.SimpleAuth]) === null || _j === void 0 ? void 0 : _j.endpoint);
        }
        return envs;
    }
    async doBlazorBuild(tabPath, logger) {
        const command = constants_2.Commands.BlazorBuild(constants_1.PathConstants.dotnetArtifactFolder, constants_3.DefaultValues.dotnetPlatform);
        try {
            await utils_2.execute(command, tabPath, logger);
        }
        catch (e) {
            throw new error_2.CommandExecutionError(constants_3.errorSource, command, tabPath, e);
        }
        return constants_1.PathConstants.dotnetArtifactFolder;
    }
    async doReactBuild(tabPath, envName, telemetryReporter, logger) {
        var _a;
        const needBuild = await deploy_1.FrontendDeployment.needBuild(tabPath, envName, telemetryReporter);
        if (!needBuild) {
            return constants_1.PathConstants.nodeArtifactFolder;
        }
        const scripts = (_a = (await fs.readJSON(path.join(tabPath, constants_1.PathConstants.nodePackageFile))).scripts) !== null && _a !== void 0 ? _a : [];
        if (!(constants_2.NpmScripts.customizedInstall in scripts)) {
            // * Track legacy projects
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.InstallScriptNotFound);
        }
        await utils_2.execute(constants_2.NpmScripts.customizedInstall in scripts
            ? constants_2.Commands.NpmRunScript(constants_2.NpmScripts.customizedInstall)
            : constants_2.Commands.NpmInstall, tabPath, logger);
        if (constants_2.NpmScripts.customizedBuild in scripts &&
            (await fs.pathExists(env_1.envFilePath(envName, tabPath)))) {
            await utils_2.execute(constants_2.Commands.NpmRunScript(constants_2.NpmScripts.customizedBuild), tabPath, logger, {
                TEAMS_FX_ENV: envName,
            });
        }
        else {
            const envs = await env_1.loadEnvFile(env_1.envFilePath(envName, tabPath));
            await utils_2.execute(constants_2.Commands.NpmBuild, tabPath, logger, Object.assign(Object.assign({}, envs.customizedRemoteEnvs), envs.teamsfxRemoteEnvs));
        }
        await deploy_1.FrontendDeployment.saveDeploymentInfo(tabPath, envName, {
            lastBuildTime: new Date().toISOString(),
        });
        return constants_1.PathConstants.nodeArtifactFolder;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: constants_3.errorSource,
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.scaffoldTab,
            progressSteps: 1,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: constants_3.errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.buildingTab,
            progressSteps: 1,
            errorSource: constants_3.errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "build", null);
TabCodeProvider = tslib_1.__decorate([
    typedi_1.Service("tab-code")
], TabCodeProvider);
exports.TabCodeProvider = TabCodeProvider;
var Scenario;
(function (Scenario) {
    Scenario["default"] = "default";
    Scenario["nonSso"] = "non-sso";
    Scenario["m365"] = "m365";
    Scenario["dashboard"] = "dashboard";
})(Scenario || (Scenario = {}));
const featureToScenario = new Map([
    [constants_1.TabOptionItem().id, Scenario.default],
    [constants_1.TabNonSsoItem().id, Scenario.nonSso],
    [constants_1.M365SsoLaunchPageOptionItem().id, Scenario.m365],
    [constants_1.DashboardOptionItem().id, Scenario.dashboard],
]);
//# sourceMappingURL=tabCode.js.map