"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendDeployment = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const constants_1 = require("../../constants");
const constants_2 = require("./constants");
const fileOperation_1 = require("../../utils/fileOperation");
const env_1 = require("./env");
const telemetry_1 = require("../../../common/telemetry");
class FrontendDeployment {
    static async needBuild(componentPath, envName, telemetryReporter) {
        const lastBuildTime = await FrontendDeployment.getLastBuildTime(componentPath, envName, telemetryReporter);
        if (!lastBuildTime) {
            return true;
        }
        return FrontendDeployment.hasUpdatedContent(componentPath, lastBuildTime, (itemPath) => !itemPath.startsWith(env_1.envFileNamePrefix) || itemPath === env_1.envFileName(envName));
    }
    static async needDeploy(componentPath, envName) {
        const lastBuildTime = await FrontendDeployment.getLastBuildTime(componentPath, envName);
        const lastDeployTime = await FrontendDeployment.getLastDeploymentTime(componentPath, envName);
        if (!lastBuildTime || !lastDeployTime) {
            return true;
        }
        return lastDeployTime < lastBuildTime;
    }
    static async hasUpdatedContent(componentPath, referenceTime, filter) {
        const folderFilter = (itemPath) => !constants_2.TabDeployIgnoreFolder.includes(path_1.default.basename(itemPath));
        let changed = false;
        await fileOperation_1.forEachFileAndDir(componentPath, (itemPath, stats) => {
            const relativePath = path_1.default.relative(componentPath, itemPath);
            if (relativePath && referenceTime < stats.mtime && (!filter || filter(relativePath))) {
                changed = true;
                return true;
            }
        }, folderFilter);
        return changed;
    }
    static async getDeploymentInfo(componentPath, envName, telemetryReporter) {
        const deploymentDir = path_1.default.join(componentPath, constants_1.PathConstants.deploymentInfoFolder);
        const deploymentInfoPath = path_1.default.join(deploymentDir, constants_1.PathConstants.deploymentInfoFile);
        try {
            const deploymentInfoJson = await fs_extra_1.default.readJSON(deploymentInfoPath);
            if (!deploymentInfoJson) {
                return undefined;
            }
            return deploymentInfoJson[envName];
        }
        catch (_a) {
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.DeploymentInfoNotFound);
            return undefined;
        }
    }
    static async getLastBuildTime(componentPath, envName, telemetryReporter) {
        const deploymentInfoJson = await FrontendDeployment.getDeploymentInfo(componentPath, envName, telemetryReporter);
        return (deploymentInfoJson === null || deploymentInfoJson === void 0 ? void 0 : deploymentInfoJson.lastBuildTime)
            ? new Date(deploymentInfoJson.lastBuildTime)
            : undefined;
    }
    static async getLastDeploymentTime(componentPath, envName) {
        const deploymentInfoJson = await FrontendDeployment.getDeploymentInfo(componentPath, envName);
        return (deploymentInfoJson === null || deploymentInfoJson === void 0 ? void 0 : deploymentInfoJson.lastDeployTime)
            ? new Date(deploymentInfoJson.lastDeployTime)
            : undefined;
    }
    static async saveDeploymentInfo(componentPath, envName, deploymentInfo) {
        var _a, _b, _c;
        const deploymentDir = path_1.default.join(componentPath, constants_1.PathConstants.deploymentInfoFolder);
        const deploymentInfoPath = path_1.default.join(deploymentDir, constants_1.PathConstants.deploymentInfoFile);
        await fs_extra_1.default.ensureDir(deploymentDir);
        let deploymentInfoJson = {};
        try {
            deploymentInfoJson = await fs_extra_1.default.readJSON(deploymentInfoPath);
        }
        catch (_d) {
            // Failed to read info file, which doesn't block deployment
        }
        (_a = deploymentInfoJson[envName]) !== null && _a !== void 0 ? _a : (deploymentInfoJson[envName] = {});
        deploymentInfoJson[envName].lastBuildTime =
            (_b = deploymentInfo.lastBuildTime) !== null && _b !== void 0 ? _b : deploymentInfoJson[envName].lastBuildTime;
        deploymentInfoJson[envName].lastDeployTime =
            (_c = deploymentInfo.lastDeployTime) !== null && _c !== void 0 ? _c : deploymentInfoJson[envName].lastDeployTime;
        try {
            await fs_extra_1.default.writeJSON(deploymentInfoPath, deploymentInfoJson);
        }
        catch (_e) {
            // Failed to write deployment info, which doesn't block deployment
        }
    }
}
exports.FrontendDeployment = FrontendDeployment;
//# sourceMappingURL=deploy.js.map