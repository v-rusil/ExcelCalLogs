"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var BotCodeProvider_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotCodeProvider = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../common/template-utils/templatesActions");
const utils_1 = require("./utils");
const utils_2 = require("../../common/utils");
const question_1 = require("../../core/question");
const constants_1 = require("./constants");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const workflow_1 = require("../workflow");
const error_1 = require("../error");
const error_2 = require("./error");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const appSettingUtils_1 = require("./appSettingUtils");
const baseAppSettings_json_1 = tslib_1.__importDefault(require("./appSettings/baseAppSettings.json"));
const botAppSettings_json_1 = tslib_1.__importDefault(require("./appSettings/botAppSettings.json"));
const ssoBotAppSettings_json_1 = tslib_1.__importDefault(require("./appSettings/ssoBotAppSettings.json"));
const errorSource = "BT";
let BotCodeProvider = BotCodeProvider_1 = class BotCodeProvider {
    constructor() {
        this.name = "bot-code";
    }
    async generate(context, inputs, actionContext) {
        var _a, _b, _c;
        const projectSettings = context.projectSetting;
        const appName = projectSettings.appName;
        const language = (inputs === null || inputs === void 0 ? void 0 : inputs[question_1.CoreQuestionNames.ProgrammingLanguage]) ||
            context.projectSetting.programmingLanguage ||
            constants_2.ProgrammingLanguage.JS;
        const botFolder = (_a = inputs.folder) !== null && _a !== void 0 ? _a : (language === constants_2.ProgrammingLanguage.CSharp ? "" : constants_2.PathConstants.botWorkingDir);
        const lang = utils_1.convertToLangKey(language);
        const workingDir = path.join(inputs.projectPath, botFolder);
        const safeProjectName = (_b = inputs[question_1.CoreQuestionNames.SafeProjectName]) !== null && _b !== void 0 ? _b : utils_2.convertToAlphanumericOnly(appName);
        await ((_c = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.scaffoldBot));
        for (const scenario of inputs.scenarios) {
            await templatesActions_1.scaffoldFromTemplates({
                group: "bot",
                lang: lang,
                scenario: scenario,
                dst: workingDir,
                fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn({
                    ProjectName: appName,
                    SafeProjectName: safeProjectName,
                }),
                fileNameReplaceFn: (name, data) => name.replace(/ProjectName/, appName).replace(/\.tpl/, ""),
                onActionError: async (action, context, error) => {
                    switch (action.name) {
                        case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                        case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                            break;
                        case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                            throw new error_2.TemplateZipFallbackError(errorSource);
                        case templatesActions_1.ScaffoldActionName.Unzip:
                            throw new error_2.UnzipError(errorSource, context.dst);
                        default:
                            throw new Error(error.message);
                    }
                },
            });
        }
        return teamsfx_api_1.ok(undefined);
    }
    async configure(context, inputs) {
        if (!projectSettingsHelper_1.isVSProject(context.projectSetting) || context.envInfo.envName !== "local") {
            return teamsfx_api_1.ok(undefined);
        }
        const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
        const botDir = teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.folder;
        if (botDir == undefined)
            return teamsfx_api_1.ok(undefined);
        const appSettingsPath = path.resolve(inputs.projectPath, botDir, appSettingUtils_1.AppSettingConstants.DevelopmentFileName);
        let appSettings;
        if (!(await fs.pathExists(appSettingsPath))) {
            // if appsetting file not exist, generate a new one
            let appSettingsJson = (teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.hosting) === constants_2.ComponentNames.Function
                ? botAppSettings_json_1.default
                : Object.assign(Object.assign({}, baseAppSettings_json_1.default), botAppSettings_json_1.default);
            appSettingsJson = (teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.sso)
                ? Object.assign(Object.assign({}, appSettingsJson), ssoBotAppSettings_json_1.default) : appSettingsJson;
            appSettings = JSON.stringify(appSettingsJson, null, 2);
        }
        else {
            appSettings = await fs.readFile(appSettingsPath, "utf-8");
        }
        await fs.writeFile(appSettingsPath, appSettingUtils_1.replaceBotAppSettings(context, appSettings, teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.sso), "utf-8");
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
        if (!teamsBot)
            return teamsfx_api_1.ok(undefined);
        if (teamsBot.folder == undefined)
            throw new error_1.BadComponent(errorSource, this.name, "folder");
        const packDir = path.resolve(inputs.projectPath, teamsBot.folder);
        const language = context.projectSetting.programmingLanguage || constants_2.ProgrammingLanguage.JS;
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.buildingBot));
        if (language === constants_2.ProgrammingLanguage.TS) {
            //Typescript needs tsc build before deploy because of windows app server. other languages don"t need it.
            try {
                await utils_1.execute(constants_1.Commands.NpmInstall, packDir, context.logProvider);
                await utils_1.execute(constants_1.Commands.NpmBuild, packDir, context.logProvider);
                lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
            }
            catch (e) {
                throw new error_2.CommandExecutionError(errorSource, `${constants_1.Commands.NpmInstall}, ${constants_1.Commands.NpmBuild}`, packDir, e);
            }
        }
        else if (language === constants_2.ProgrammingLanguage.JS) {
            try {
                // fail to npm install @microsoft/teamsfx on azure web app, so pack it locally.
                await utils_1.execute(constants_1.Commands.NpmInstall, packDir, context.logProvider);
                lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
            }
            catch (e) {
                throw new error_2.CommandExecutionError(errorSource, `${constants_1.Commands.NpmInstall}`, packDir, e);
            }
        }
        else if (language === constants_2.ProgrammingLanguage.CSharp) {
            const projectFileName = `${context.projectSetting.appName}.csproj`;
            const framework = await BotCodeProvider_1.getFrameworkVersion(path.join(packDir, projectFileName));
            await utils_1.execute(constants_1.Commands.DotNetPublish, packDir, context.logProvider);
            const artifactFolder = path.join(".", "bin", "Release", framework, "publish");
            lodash_1.merge(teamsBot, { build: true, artifactFolder: artifactFolder });
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * read dotnet framework version from project file
     * @param projectFilePath project base folder
     */
    static async getFrameworkVersion(projectFilePath) {
        try {
            const reg = /(?<=<TargetFramework>)(.*)(?=<)/gim;
            const content = await fs.readFile(projectFilePath, "utf8");
            const framework = content.match(reg);
            if (framework === null || framework === void 0 ? void 0 : framework.length) {
                return framework[0].trim();
            }
        }
        catch (_a) { }
        return constants_1.DEFAULT_DOTNET_FRAMEWORK;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.scaffoldBot,
            progressSteps: 1,
            errorSource: errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], BotCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], BotCodeProvider.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.buildingBot,
            progressSteps: 1,
            errorSource: errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], BotCodeProvider.prototype, "build", null);
BotCodeProvider = BotCodeProvider_1 = tslib_1.__decorate([
    typedi_1.Service("bot-code")
], BotCodeProvider);
exports.BotCodeProvider = BotCodeProvider;
//# sourceMappingURL=botCode.js.map