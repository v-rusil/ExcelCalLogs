"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.convertToLangKey = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const child_process_1 = require("child_process");
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case "javascript": {
            return "js";
        }
        case "typescript": {
            return "ts";
        }
        case "csharp": {
            return "csharp";
        }
        default: {
            return "js";
        }
    }
}
exports.convertToLangKey = convertToLangKey;
function capitalizeFirstLetter(raw) {
    return raw.charAt(0).toUpperCase() + raw.slice(1);
}
function execute(command, workingDir, logger, env) {
    return new Promise((resolve, reject) => {
        // Drive letter should be uppercase, otherwise when we run webpack in exec, it fails to resolve nested dependencies.
        if (os_1.default.platform() === "win32") {
            workingDir = capitalizeFirstLetter(path.resolve(workingDir !== null && workingDir !== void 0 ? workingDir : ""));
        }
        logger === null || logger === void 0 ? void 0 : logger.info(`Start to run command: "${command}" on path: "${workingDir}".`);
        child_process_1.exec(command, { cwd: workingDir, env: Object.assign(Object.assign({}, process.env), env) }, async (error, stdout, stderr) => {
            if (error) {
                await (logger === null || logger === void 0 ? void 0 : logger.error(`Failed to run command: "${command}" on path: "${workingDir}".`));
                if (stdout) {
                    await (logger === null || logger === void 0 ? void 0 : logger.error(stdout));
                }
                if (stderr) {
                    await (logger === null || logger === void 0 ? void 0 : logger.error(stderr));
                }
                reject(error);
            }
            if (stdout) {
                await (logger === null || logger === void 0 ? void 0 : logger.debug(stdout));
            }
            resolve(stdout);
        });
    });
}
exports.execute = execute;
//# sourceMappingURL=utils.js.map