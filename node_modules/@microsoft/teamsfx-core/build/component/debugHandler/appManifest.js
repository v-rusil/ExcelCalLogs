// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppManifestDebugHandler = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const util = tslib_1.__importStar(require("util"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../common/tools");
const crypto_1 = require("../../core/crypto");
const environment_1 = require("../../core/environment");
const projectSettingsLoader_1 = require("../../core/middleware/projectSettingsLoader");
const appStudioClient_1 = require("../resource/appManifest/appStudioClient");
const constants_1 = require("../constants");
const appStudio_1 = require("../resource/appManifest/appStudio");
const error_1 = require("./error");
const utils_1 = require("./utils");
const uuid_1 = require("uuid");
const appManifestDebugMessages = {
    buildingAndSavingAppManifest: "Resolving manifest template and generating the Teams app package ...",
    uploadingAppPackage: "Uploading Teams app package via Teams Developer Portal ...",
    savingStates: "Saving the states of Teams app ...",
    appManifestSaved: "Teams app manifest is resolved and app package is saved in %s",
    useExistingAppManifest: "Skip building Teams app manifest but use the existing Teams app package from args",
    statesSaved: "The states of Teams app manifest are saved in %s",
    skipSavingStates: "Skip saving the states for Teams app manifest",
    appPackageUploaded: "Teams app package is uploaded",
};
class AppManifestDebugHandler {
    constructor(projectPath, args, m365TokenProvider, logger, telemetry, ui) {
        this.existing = false;
        this.projectPath = projectPath;
        this.args = args;
        this.m365TokenProvider = m365TokenProvider;
        this.logger = logger;
        this.telemetry = telemetry;
        this.ui = ui;
    }
    getActions() {
        const actions = [];
        actions.push({
            startMessage: appManifestDebugMessages.buildingAndSavingAppManifest,
            run: this.buildAndSaveAppManifest.bind(this),
        });
        actions.push({
            startMessage: appManifestDebugMessages.uploadingAppPackage,
            run: this.uploadAppManifestPackage.bind(this),
        });
        actions.push({
            startMessage: appManifestDebugMessages.savingStates,
            run: this.saveStates.bind(this),
        });
        return actions;
    }
    async validateArgs() {
        if (this.args.appPackagePath !== undefined && this.args.appPackagePath.trim().length === 0) {
            return teamsfx_api_1.err(error_1.DebugArgumentEmptyError("appPackagePath"));
        }
        if (this.args.appPackagePath) {
            this.args.appPackagePath = this.args.appPackagePath.trim();
            if (this.args.appPackagePath.length > 0) {
                if (!(await fs_extra_1.default.pathExists(this.args.appPackagePath))) {
                    return teamsfx_api_1.err(error_1.AppManifestPackageNotExistError(this.args.appPackagePath));
                }
                if (path.extname(this.args.appPackagePath) != ".zip") {
                    return teamsfx_api_1.err(error_1.InvalidAppManifestPackageFileFormatError());
                }
                this.existing = true;
            }
        }
        return teamsfx_api_1.ok([]);
    }
    async buildAndSaveAppManifest() {
        try {
            const result = await this.validateArgs();
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            if (this.args.appPackagePath) {
                return teamsfx_api_1.ok([appManifestDebugMessages.useExistingAppManifest]);
            }
            const projectSettingsResult = await projectSettingsLoader_1.loadProjectSettingsByProjectPath(this.projectPath, true);
            if (projectSettingsResult.isErr()) {
                return teamsfx_api_1.err(projectSettingsResult.error);
            }
            // save project settings as the project id may be updated
            const projectSettingsPath = projectSettingsLoader_1.getProjectSettingsPath(this.projectPath);
            await fs_extra_1.default.writeFile(projectSettingsPath, JSON.stringify(projectSettingsResult.value, null, 4));
            this.projectSettingsV3 = projectSettingsResult.value;
            this.cryptoProvider = new crypto_1.LocalCrypto(this.projectSettingsV3.projectId);
            const envInfoResult = await environment_1.environmentManager.loadEnvInfo(this.projectPath, this.cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (envInfoResult.isErr()) {
                return teamsfx_api_1.err(envInfoResult.error);
            }
            this.envInfoV3 = envInfoResult.value;
            if (this.envInfoV3.state[constants_1.ComponentNames.AppManifest]) {
                const checkResult = await utils_1.checkM365Tenant(this.projectPath, this.projectSettingsV3, this.envInfoV3, this.m365TokenProvider, this.logger, this.telemetry, this.ui, this.cryptoProvider);
                if (checkResult.isErr()) {
                    return teamsfx_api_1.err(checkResult.error);
                }
            }
            this.envInfoV3.state[constants_1.ComponentNames.AppManifest] =
                this.envInfoV3.state[constants_1.ComponentNames.AppManifest] || {};
            // For SPFx manifest
            this.envInfoV3.config.isLocalDebug = true;
            // Local debug if switching to a different account in same tenant
            if (!!this.envInfoV3.state[constants_1.ComponentNames.AppManifest].teamsAppId) {
                const checkAppInDifferentAccount = await appStudio_1.checkIfAppInDifferentAcountSameTenant(this.envInfoV3.state[constants_1.ComponentNames.AppManifest].teamsAppId, this.m365TokenProvider, this.logger);
                if (checkAppInDifferentAccount.isOk() && checkAppInDifferentAccount.value) {
                    this.envInfoV3.state[constants_1.ComponentNames.AppManifest].teamsAppId = uuid_1.v4();
                }
            }
            // build
            const packagePathResult = await appStudio_1.buildTeamsAppPackage(this.projectSettingsV3, this.projectPath, this.envInfoV3);
            if (packagePathResult.isErr()) {
                return teamsfx_api_1.err(packagePathResult.error);
            }
            this.args.appPackagePath = packagePathResult.value;
            return teamsfx_api_1.ok([
                util.format(appManifestDebugMessages.appManifestSaved, path.normalize(packagePathResult.value)),
            ]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async uploadAppManifestPackage() {
        try {
            // upload
            const tokenResult = await this.m365TokenProvider.getAccessToken({
                scopes: tools_1.AppStudioScopes,
            });
            if (tokenResult.isErr()) {
                return teamsfx_api_1.err(tokenResult.error);
            }
            const archivedFile = await fs_extra_1.default.readFile(this.args.appPackagePath);
            const appdefinition = await appStudioClient_1.AppStudioClient.importApp(archivedFile, tokenResult.value, this.logger, true);
            if (!this.existing) {
                // set teamsAppId, tenantId to state
                this.envInfoV3.state[constants_1.ComponentNames.AppManifest].teamsAppId = appdefinition.teamsAppId;
                this.envInfoV3.state[constants_1.ComponentNames.AppManifest].tenantId = appdefinition.tenantId;
            }
            return teamsfx_api_1.ok([appManifestDebugMessages.appPackageUploaded]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async saveStates() {
        try {
            if (this.existing) {
                return teamsfx_api_1.ok([appManifestDebugMessages.skipSavingStates]);
            }
            const statePath = await environment_1.environmentManager.writeEnvState(lodash_1.cloneDeep(this.envInfoV3.state), this.projectPath, this.cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (statePath.isErr()) {
                return teamsfx_api_1.err(statePath.error);
            }
            return teamsfx_api_1.ok([
                util.format(appManifestDebugMessages.statesSaved, path.normalize(statePath.value)),
            ]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
}
exports.AppManifestDebugHandler = AppManifestDebugHandler;
//# sourceMappingURL=appManifest.js.map