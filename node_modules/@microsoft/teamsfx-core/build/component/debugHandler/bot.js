// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotDebugHandler = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const util = tslib_1.__importStar(require("util"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../common/tools");
const utils_1 = require("../../common/utils");
const crypto_1 = require("../../core/crypto");
const environment_1 = require("../../core/environment");
const projectSettingsLoader_1 = require("../../core/middleware/projectSettingsLoader");
const IBotRegistration_1 = require("../resource/botService/appStudio/interfaces/IBotRegistration");
const constants_1 = require("../resource/botService/constants");
const strings_1 = require("../resource/botService/strings");
const common_1 = require("../resource/botService/common");
const resourceNameFactory_1 = require("../resource/botService/resourceNameFactory");
const constants_2 = require("../constants");
const error_1 = require("./error");
const localEnvProvider_1 = require("./localEnvProvider");
const appStudioClient_1 = require("../resource/botService/appStudio/appStudioClient");
const graphClient_1 = require("../resource/botService/botRegistration/graphClient");
const utils_2 = require("./utils");
const errors_1 = require("../resource/botService/errors");
const botDebugMessages = {
    registeringAAD: "Registering the AAD app which is required to create the bot ...",
    registeringBot: "Registering the bot in Bot Framework Portal ...",
    updatingBotMessagingEndpoint: "Updating the bot messaging endpoint ...",
    savingStates: "Saving the states of bot ...",
    settingEnvs: "Saving the environment variables of bot ...",
    AADRegistered: "AAD app is registered (%s)",
    useExistingAAD: "Skip registering AAD app but use the existing AAD app from args: %s",
    AADAlreadyRegistered: "Skip registering AAD app (%s) as it has already been registered before",
    botRegistered: "Bot is registered (%s)",
    botAlreadyRegistered: "Skip registering bot as it has already been registered before (%s)",
    botMessagingEndpointUpdated: "Bot messaging endpoint is updated to %s",
    statesSaved: "The states of bot are saved in %s",
    envsSet: "The environment variables of bot are saved in %s",
};
const botUrl = "https://dev.botframework.com/bots?id=";
class BotDebugHandler {
    constructor(projectPath, args, m365TokenProvider, logger, telemetry, ui) {
        this.projectPath = projectPath;
        this.args = args;
        this.m365TokenProvider = m365TokenProvider;
        this.logger = logger;
        this.telemetry = telemetry;
        this.ui = ui;
    }
    getActions() {
        const actions = [];
        actions.push({
            startMessage: botDebugMessages.registeringAAD,
            run: this.registerAAD.bind(this),
        });
        actions.push({
            startMessage: botDebugMessages.registeringBot,
            run: this.registerBot.bind(this),
        });
        actions.push({
            startMessage: botDebugMessages.updatingBotMessagingEndpoint,
            run: this.updateBotMessagingEndpoint.bind(this),
        });
        actions.push({
            startMessage: botDebugMessages.savingStates,
            run: this.saveStates.bind(this),
        });
        actions.push({
            startMessage: botDebugMessages.settingEnvs,
            run: this.setEnvs.bind(this),
        });
        return actions;
    }
    async validateArgs() {
        if (this.args.botId !== undefined && this.args.botId.trim().length === 0) {
            return teamsfx_api_1.err(error_1.DebugArgumentEmptyError("botId"));
        }
        if (this.args.botPassword !== undefined && this.args.botPassword.trim().length === 0) {
            return teamsfx_api_1.err(error_1.DebugArgumentEmptyError("botPassword"));
        }
        const existing = this.args.botId || this.args.botPassword;
        const missing = !this.args.botId || !this.args.botPassword;
        if (existing && missing) {
            return teamsfx_api_1.err(error_1.InvalidExistingBotArgsError());
        }
        return teamsfx_api_1.ok([]);
    }
    async registerAAD() {
        var _a, _b;
        try {
            const result = await this.validateArgs();
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            const projectSettingsResult = await projectSettingsLoader_1.loadProjectSettingsByProjectPath(this.projectPath, true);
            if (projectSettingsResult.isErr()) {
                return teamsfx_api_1.err(projectSettingsResult.error);
            }
            // save project settings as the project id may be updated
            const projectSettingsPath = projectSettingsLoader_1.getProjectSettingsPath(this.projectPath);
            await fs_extra_1.default.writeFile(projectSettingsPath, JSON.stringify(projectSettingsResult.value, null, 4));
            this.projectSettingsV3 = projectSettingsResult.value;
            this.cryptoProvider = new crypto_1.LocalCrypto(this.projectSettingsV3.projectId);
            const envInfoResult = await environment_1.environmentManager.loadEnvInfo(this.projectPath, this.cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (envInfoResult.isErr()) {
                return teamsfx_api_1.err(envInfoResult.error);
            }
            this.envInfoV3 = envInfoResult.value;
            if (this.envInfoV3.state[constants_2.ComponentNames.TeamsBot]) {
                const checkResult = await utils_2.checkM365Tenant(this.projectPath, this.projectSettingsV3, this.envInfoV3, this.m365TokenProvider, this.logger, this.telemetry, this.ui, this.cryptoProvider);
                this.hasBotIdInEnvBefore = !!((_b = (_a = this.envInfoV3) === null || _a === void 0 ? void 0 : _a.state[constants_2.ComponentNames.TeamsBot]) === null || _b === void 0 ? void 0 : _b.botId);
                if (checkResult.isErr()) {
                    return teamsfx_api_1.err(checkResult.error);
                }
            }
            this.envInfoV3.state[constants_2.ComponentNames.TeamsBot] =
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot] || {};
            if (this.args.botId) {
                // use existing bot
                // set botId, botPassword from args to state
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId = this.args.botId;
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword = this.args.botPassword;
                return teamsfx_api_1.ok([util.format(botDebugMessages.useExistingAAD, this.args.botId)]);
            }
            else if (this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId &&
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword) {
                // AAD already registered
                return teamsfx_api_1.ok([
                    util.format(botDebugMessages.AADAlreadyRegistered, this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId),
                ]);
            }
            else {
                // not using existing bot and AAD not yet registered
                const tokenResult = await this.m365TokenProvider.getAccessToken({
                    scopes: tools_1.GraphScopes,
                });
                if (tokenResult.isErr()) {
                    return teamsfx_api_1.err(tokenResult.error);
                }
                const displayName = resourceNameFactory_1.ResourceNameFactory.createCommonName(common_1.genUUID(), this.projectSettingsV3.appName, constants_1.MaxLengths.AAD_DISPLAY_NAME);
                const botAuthCredential = await graphClient_1.GraphClient.registerAadApp(tokenResult.value, displayName);
                // set botId, botPassword to state
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId = botAuthCredential.clientId;
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword = botAuthCredential.clientSecret;
                return teamsfx_api_1.ok([util.format(botDebugMessages.AADRegistered, botAuthCredential.clientId)]);
            }
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async registerBot() {
        try {
            const tokenResult = await this.m365TokenProvider.getAccessToken({
                scopes: tools_1.AppStudioScopes,
            });
            if (tokenResult.isErr()) {
                return teamsfx_api_1.err(tokenResult.error);
            }
            const result = await appStudioClient_1.AppStudioClient.getBotRegistration(tokenResult.value, this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId);
            if (result) {
                return teamsfx_api_1.ok([
                    util.format(botDebugMessages.botAlreadyRegistered, `${botUrl}${this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId}`),
                ]);
            }
            const botReg = {
                botId: this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId,
                name: utils_1.convertToAlphanumericOnly(this.projectSettingsV3.appName) +
                    strings_1.PluginLocalDebug.LOCAL_DEBUG_SUFFIX,
                description: "",
                iconUrl: "",
                messagingEndpoint: "",
                callingEndpoint: "",
                configuredChannels: [IBotRegistration_1.BotChannelType.MicrosoftTeams],
            };
            try {
                await appStudioClient_1.AppStudioClient.createBotRegistration(tokenResult.value, botReg);
            }
            catch (e) {
                if (e.name == constants_1.ErrorNames.CREATE_BOT_REGISTRATION_API_ERROR && this.hasBotIdInEnvBefore) {
                    const botId = this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId;
                    return teamsfx_api_1.err(errors_1.AlreadyCreatedBotNotExist(botId, e.innerError));
                }
                else {
                    throw e;
                }
            }
            return teamsfx_api_1.ok([
                util.format(botDebugMessages.botRegistered, `${botUrl}${this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId}`),
            ]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async updateBotMessagingEndpoint() {
        try {
            // set validDomain, domain, siteEndpoint from args to state
            const url = new URL(this.args.botMessagingEndpoint);
            this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].validDomain = url.hostname;
            this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].domain = url.hostname;
            this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].siteEndpoint = url.origin;
            const tokenResult = await this.m365TokenProvider.getAccessToken({
                scopes: tools_1.AppStudioScopes,
            });
            if (tokenResult.isErr()) {
                return teamsfx_api_1.err(tokenResult.error);
            }
            await appStudioClient_1.AppStudioClient.updateMessageEndpoint(tokenResult.value, this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId, this.args.botMessagingEndpoint);
            return teamsfx_api_1.ok([
                util.format(botDebugMessages.botMessagingEndpointUpdated, this.args.botMessagingEndpoint),
            ]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async saveStates() {
        try {
            const statePath = await environment_1.environmentManager.writeEnvState(lodash_1.cloneDeep(this.envInfoV3.state), this.projectPath, this.cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (statePath.isErr()) {
                return teamsfx_api_1.err(statePath.error);
            }
            return teamsfx_api_1.ok([util.format(botDebugMessages.statesSaved, path.normalize(statePath.value))]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async setEnvs() {
        try {
            const localEnvProvider = new localEnvProvider_1.LocalEnvProvider(this.projectPath);
            const botEnvs = await localEnvProvider.loadBotLocalEnvs();
            botEnvs.template[localEnvProvider_1.LocalEnvKeys.bot.template.BotId] =
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId;
            botEnvs.template[localEnvProvider_1.LocalEnvKeys.bot.template.BotPassword] =
                this.envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword;
            const envPath = await localEnvProvider.saveBotLocalEnvs(botEnvs);
            return teamsfx_api_1.ok([util.format(botDebugMessages.envsSet, path.normalize(envPath))]);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
}
exports.BotDebugHandler = BotDebugHandler;
//# sourceMappingURL=bot.js.map