"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resourceGroupHelper = exports.ResourceGroupHelper = exports.ResourceGroupApiError = exports.ResourceGroupErrorHandlerMW = exports.DefaultResourceGroupLocation = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_resources_1 = require("@azure/arm-resources");
const arm_subscriptions_1 = require("@azure/arm-subscriptions");
const ms_rest_js_1 = require("@azure/ms-rest-js");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../common/constants");
const localizeUtils_1 = require("../../common/localizeUtils");
const globalVars_1 = require("../../core/globalVars");
const question_1 = require("../../core/question");
const constants_2 = require("../constants");
const MsResources = "Microsoft.Resources";
const ResourceGroups = "resourceGroups";
exports.DefaultResourceGroupLocation = "East US";
// TODO: use the emoji plus sign like Azure Functions extension
const newResourceGroupOption = "+ New resource group";
function ResourceGroupErrorHandlerMW(operation) {
    return async (ctx, next) => {
        const resourceGroupName = ctx.arguments.length > 0 && typeof ctx.arguments[0] === "string"
            ? ctx.arguments[0]
            : undefined;
        try {
            await next();
        }
        catch (e) {
            const fxError = new ResourceGroupApiError(operation, resourceGroupName, e);
            ctx.result = teamsfx_api_1.err(fxError);
        }
    };
}
exports.ResourceGroupErrorHandlerMW = ResourceGroupErrorHandlerMW;
class ResourceGroupApiError extends teamsfx_api_1.UserError {
    constructor(operation, resourceGroupName, error) {
        const baseErrorMessage = `${operation} failed ${resourceGroupName ? "resource group:" + resourceGroupName : ""}`;
        const errorName = new.target.name;
        if (!error)
            super(constants_2.SolutionSource, new.target.name, baseErrorMessage);
        else if (error instanceof ms_rest_js_1.RestError) {
            const restError = error;
            // Avoid sensitive information like request headers in the error message.
            const rawErrorString = JSON.stringify({
                code: restError.code,
                statusCode: restError.statusCode,
                body: restError.body,
                name: restError.name,
                message: restError.message,
            });
            super(constants_2.SolutionSource, errorName, `${baseErrorMessage}, error: '${rawErrorString}'`);
        }
        else if (error instanceof Error) {
            super({ name: errorName, error: error, source: constants_2.SolutionSource });
        }
        else {
            super(constants_2.SolutionSource, errorName, `${baseErrorMessage}, error: '${JSON.stringify(error)}'`);
        }
    }
}
exports.ResourceGroupApiError = ResourceGroupApiError;
class ResourceGroupHelper {
    async createNewResourceGroup(resourceGroupName, azureAccountProvider, subscriptionId, location) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken)
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToGetAzureCredential, localizeUtils_1.getLocalizedString("error.FailedToGetAzureCredential")));
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
        const maybeExist = await this.checkResourceGroupExistence(resourceGroupName, rmClient);
        if (maybeExist.isErr()) {
            return teamsfx_api_1.err(maybeExist.error);
        }
        if (maybeExist.value) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.CoordinatorSource, "ResourceGroupExists", localizeUtils_1.getLocalizedString("core.error.FailedToCreateResourceGroup.exist", resourceGroupName)));
        }
        const response = await rmClient.resourceGroups.createOrUpdate(resourceGroupName, {
            location: location,
            tags: { "created-by": "teamsfx" },
        });
        if (response.name === undefined) {
            return teamsfx_api_1.err(new ResourceGroupApiError("create", resourceGroupName));
        }
        return teamsfx_api_1.ok(response.name);
    }
    async checkResourceGroupExistence(resourceGroupName, rmClient) {
        const checkRes = await rmClient.resourceGroups.checkExistence(resourceGroupName);
        return teamsfx_api_1.ok(!!checkRes.body);
    }
    async getResourceGroupInfo(resourceGroupName, rmClient) {
        const getRes = await rmClient.resourceGroups.get(resourceGroupName);
        if (getRes.name) {
            return teamsfx_api_1.ok({
                createNewResourceGroup: false,
                name: getRes.name,
                location: getRes.location,
            });
        }
        else
            return teamsfx_api_1.ok(undefined);
    }
    async listResourceGroups(rmClient) {
        var e_1, _a;
        const resourceGroupResults = [];
        try {
            for (var _b = tslib_1.__asyncValues(rmClient.resourceGroups.list().byPage({ maxPageSize: 100 })), _c; _c = await _b.next(), !_c.done;) {
                const page = _c.value;
                for (const resourceGroup of page) {
                    resourceGroupResults.push(resourceGroup);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const resourceGroupNameLocations = resourceGroupResults
            .filter((item) => item.name)
            .map((item) => [item.name, item.location]);
        return teamsfx_api_1.ok(resourceGroupNameLocations);
    }
    async getLocations(azureAccountProvider, rmClient) {
        var e_2, _a;
        var _b;
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken)
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToGetAzureCredential, localizeUtils_1.getDefaultString("error.FailedToGetAzureCredential"), localizeUtils_1.getLocalizedString("error.FailedToGetAzureCredential")));
        const subscriptionClient = new arm_subscriptions_1.SubscriptionClient(azureToken);
        const askSubRes = await azureAccountProvider.getSelectedSubscription(true);
        const locations = [];
        try {
            for (var _c = tslib_1.__asyncValues(subscriptionClient.subscriptions
                .listLocations(askSubRes.subscriptionId)
                .byPage({ maxPageSize: 100 })), _d; _d = await _c.next(), !_d.done;) {
                const page = _d.value;
                for (const location of page) {
                    if (location.displayName) {
                        locations.push(location.displayName);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        const providerData = await rmClient.providers.get(MsResources);
        const resourceTypeData = (_b = providerData.resourceTypes) === null || _b === void 0 ? void 0 : _b.find((rt) => { var _a; return ((_a = rt.resourceType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ResourceGroups.toLowerCase(); });
        const resourceLocations = resourceTypeData === null || resourceTypeData === void 0 ? void 0 : resourceTypeData.locations;
        const rgLocations = resourceLocations === null || resourceLocations === void 0 ? void 0 : resourceLocations.filter((item) => locations.includes(item));
        if (!rgLocations || rgLocations.length == 0) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToListResourceGroupLocation, localizeUtils_1.getDefaultString("error.FailedToListResourceGroupLocation"), localizeUtils_1.getLocalizedString("error.FailedToListResourceGroupLocation")));
        }
        return teamsfx_api_1.ok(rgLocations);
    }
    async getQuestionsForResourceGroup(defaultResourceGroupName, existingResourceGroupNameLocations, availableLocations, rmClient) {
        const selectResourceGroup = question_1.QuestionSelectResourceGroup();
        const staticOptions = [
            { id: newResourceGroupOption, label: newResourceGroupOption },
        ];
        selectResourceGroup.staticOptions = staticOptions.concat(existingResourceGroupNameLocations.map((item) => {
            return {
                id: item[0],
                label: item[0],
                description: item[1],
            };
        }));
        const node = new teamsfx_api_1.QTreeNode(selectResourceGroup);
        const existingResourceGroupNames = existingResourceGroupNameLocations.map((item) => item[0]);
        const inputNewResourceGroupName = question_1.newResourceGroupNameQuestion(existingResourceGroupNames);
        inputNewResourceGroupName.default = defaultResourceGroupName;
        const newResourceGroupNameNode = new teamsfx_api_1.QTreeNode(inputNewResourceGroupName);
        newResourceGroupNameNode.condition = { equals: newResourceGroupOption };
        node.addChild(newResourceGroupNameNode);
        const selectLocation = question_1.QuestionNewResourceGroupLocation();
        // TODO: maybe lazily load locations
        selectLocation.staticOptions = availableLocations;
        selectLocation.default = "East US";
        const newResourceGroupLocationNode = new teamsfx_api_1.QTreeNode(selectLocation);
        newResourceGroupNameNode.addChild(newResourceGroupLocationNode);
        return node.trim();
    }
    /**
     * Ask user to create a new resource group or use an existing resource group
     */
    async askResourceGroupInfo(ctx, inputs, azureAccountProvider, rmClient, defaultResourceGroupName) {
        return this.askResourceGroupInfoV3(azureAccountProvider, rmClient, defaultResourceGroupName);
    }
    /**
     * Ask user to create a new resource group or use an existing resource group  V3
     */
    async askResourceGroupInfoV3(azureAccountProvider, rmClient, defaultResourceGroupName) {
        var _a;
        const listRgRes = await this.listResourceGroups(rmClient);
        if (listRgRes.isErr())
            return teamsfx_api_1.err(listRgRes.error);
        const getLocationsRes = await this.getLocations(azureAccountProvider, rmClient);
        if (getLocationsRes.isErr()) {
            return teamsfx_api_1.err(getLocationsRes.error);
        }
        const node = await this.getQuestionsForResourceGroup(defaultResourceGroupName, listRgRes.value, getLocationsRes.value, rmClient);
        const inputs = {
            platform: teamsfx_api_1.Platform.VSCode,
        };
        if (node) {
            const res = await teamsfx_api_1.traverse(node, inputs, globalVars_1.TOOLS.ui);
            if (res.isErr()) {
                (_a = globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`[${constants_1.PluginDisplayName.Solution}] failed to run question model for target resource group.`);
                return teamsfx_api_1.err(res.error);
            }
        }
        const targetResourceGroupName = inputs.targetResourceGroupName;
        if (!targetResourceGroupName || typeof targetResourceGroupName !== "string") {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "InvalidInputError", "Invalid targetResourceGroupName"));
        }
        const resourceGroupName = inputs.targetResourceGroupName;
        if (resourceGroupName === newResourceGroupOption) {
            return teamsfx_api_1.ok({
                name: inputs[question_1.CoreQuestionNames.NewResourceGroupName],
                location: inputs[question_1.CoreQuestionNames.NewResourceGroupLocation],
                createNewResourceGroup: true,
            });
        }
        else {
            const target = listRgRes.value.find((item) => item[0] == targetResourceGroupName);
            const location = target[1]; // location must exist because the user can only select from this list.
            return teamsfx_api_1.ok({
                createNewResourceGroup: false,
                name: targetResourceGroupName,
                location: location,
            });
        }
    }
}
tslib_1.__decorate([
    hooks_1.hooks([ResourceGroupErrorHandlerMW("create")]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], ResourceGroupHelper.prototype, "createNewResourceGroup", null);
tslib_1.__decorate([
    hooks_1.hooks([ResourceGroupErrorHandlerMW("checkExistence")]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, arm_resources_1.ResourceManagementClient]),
    tslib_1.__metadata("design:returntype", Promise)
], ResourceGroupHelper.prototype, "checkResourceGroupExistence", null);
tslib_1.__decorate([
    hooks_1.hooks([ResourceGroupErrorHandlerMW("get")]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, arm_resources_1.ResourceManagementClient]),
    tslib_1.__metadata("design:returntype", Promise)
], ResourceGroupHelper.prototype, "getResourceGroupInfo", null);
tslib_1.__decorate([
    hooks_1.hooks([ResourceGroupErrorHandlerMW("list")]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [arm_resources_1.ResourceManagementClient]),
    tslib_1.__metadata("design:returntype", Promise)
], ResourceGroupHelper.prototype, "listResourceGroups", null);
exports.ResourceGroupHelper = ResourceGroupHelper;
exports.resourceGroupHelper = new ResourceGroupHelper();
//# sourceMappingURL=ResourceGroupHelper.js.map