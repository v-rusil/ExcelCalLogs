"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbsolutePath = exports.isKvPairEqual = exports.getEnvironmentVariables = exports.expandEnvironmentVariable = exports.wrapSummaryWithArgs = exports.wrapSummary = exports.wrapRun = exports.asFactory = exports.asString = exports.asBoolean = exports.asOptional = exports.checkMissingArgs = void 0;
const tslib_1 = require("tslib");
const componentError_1 = require("../error/componentError");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const localizeUtils_1 = require("../../common/localizeUtils");
/**
 * check parameter, throw error if value is null or undefined
 * @param name parameter name
 * @param value parameter value
 */
function checkMissingArgs(name, value) {
    if (!value) {
        throw componentError_1.PrerequisiteError.somethingMissing("Deploy", name);
    }
    return value;
}
exports.checkMissingArgs = checkMissingArgs;
function asOptional(as) {
    return function (s, key, helpLink) {
        if (s === undefined || s === null) {
            return undefined;
        }
        return as(s, key, helpLink);
    };
}
exports.asOptional = asOptional;
function asBoolean(s, key, helpLink) {
    if (typeof s === "boolean") {
        return s;
    }
    else if (typeof s === "string") {
        return s === "true";
    }
    throw componentError_1.PrerequisiteError.somethingMissing("Deploy", key, helpLink);
}
exports.asBoolean = asBoolean;
function asString(s, key, helpLink) {
    if (typeof s === "string") {
        return s;
    }
    throw componentError_1.PrerequisiteError.somethingMissing("Deploy", key, helpLink);
}
exports.asString = asString;
function asFactory(keyValidators) {
    return function (data, helpLink) {
        if (typeof data === "object" && data !== null) {
            const maybeT = data;
            for (const key of Object.keys(keyValidators)) {
                keyValidators[key](maybeT[key], `${key}`, helpLink);
            }
            return maybeT;
        }
        throw componentError_1.PrerequisiteError.somethingIllegal("Deploy", "data", "plugins.bot.InvalidData", undefined, helpLink);
    };
}
exports.asFactory = asFactory;
async function wrapRun(exec, errorHandler, logProvider) {
    try {
        return teamsfx_api_1.ok(await exec());
    }
    catch (error) {
        if (errorHandler) {
            await errorHandler();
        }
        if (error instanceof componentError_1.BaseComponentInnerError) {
            if (error.detail) {
                await (logProvider === null || logProvider === void 0 ? void 0 : logProvider.debug(`Error occurred: ${error.detail}`));
            }
            return teamsfx_api_1.err(error.toFxError());
        }
        else if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
            return teamsfx_api_1.err(error);
        }
        // always return error as SystemError
        return teamsfx_api_1.err(componentError_1.BaseComponentInnerError.unknownError("Deploy", error).toFxError());
    }
}
exports.wrapRun = wrapRun;
async function wrapSummary(exec, summary) {
    const result = await exec();
    if (result.isOk()) {
        const summaries = summary.map((s) => localizeUtils_1.getLocalizedString(s));
        return { result, summaries };
    }
    else {
        const summaries = [];
        return { result, summaries };
    }
}
exports.wrapSummary = wrapSummary;
async function wrapSummaryWithArgs(exec, summary) {
    const result = await exec();
    if (result.isOk()) {
        const summaries = summary.map((s) => localizeUtils_1.getLocalizedString(s[0], ...s.splice(1)));
        return { result, summaries };
    }
    else {
        const summaries = [];
        return { result, summaries };
    }
}
exports.wrapSummaryWithArgs = wrapSummaryWithArgs;
// Expand environment variables in content. The format of referencing environment variable is: ${{ENV_NAME}}
function expandEnvironmentVariable(content) {
    const placeholderRegex = /\${{ *[a-zA-Z_][a-zA-Z0-9_]* *}}/g;
    const placeholders = content.match(placeholderRegex);
    if (placeholders) {
        for (const placeholder of placeholders) {
            const envName = placeholder.slice(3, -2).trim(); // removes `${{` and `}}`
            const envValue = process.env[envName];
            if (envValue) {
                content = content.replace(placeholder, envValue);
            }
        }
    }
    return content;
}
exports.expandEnvironmentVariable = expandEnvironmentVariable;
/**
 * Expand environment variables in content. The format of referencing environment variable is: ${{ENV_NAME}}
 * @return An array of environment variables
 */
function getEnvironmentVariables(content) {
    const placeholderRegex = /\${{ *[a-zA-Z_][a-zA-Z0-9_]* *}}/g;
    const placeholders = content.match(placeholderRegex);
    if (placeholders) {
        const variables = placeholders.map((placeholder) => placeholder.slice(3, -2).trim()); // removes `${{` and `}}`)
        // remove duplicates
        return [...new Set(variables)];
    }
    return [];
}
exports.getEnvironmentVariables = getEnvironmentVariables;
/**
 * compare two key-value pairs, return true if they are exactly same
 * @param kv1 parameter the first key-value pair
 * @param kv2 parameter the first key-value pair
 */
function isKvPairEqual(kv1, kv2) {
    const _compare = (l, r) => !Object.keys(l).some((key) => r[key] !== l[key]);
    return _compare(kv1, kv2) && _compare(kv2, kv1);
}
exports.isKvPairEqual = isKvPairEqual;
function getAbsolutePath(relativeOrAbsolutePath, projectPath) {
    relativeOrAbsolutePath = relativeOrAbsolutePath || "";
    projectPath = projectPath || "";
    return path_1.default.isAbsolute(relativeOrAbsolutePath)
        ? relativeOrAbsolutePath
        : path_1.default.join(projectPath, relativeOrAbsolutePath);
}
exports.getAbsolutePath = getAbsolutePath;
//# sourceMappingURL=common.js.map