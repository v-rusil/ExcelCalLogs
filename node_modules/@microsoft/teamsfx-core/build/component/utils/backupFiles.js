"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.backupFiles = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const constants_1 = require("../constants");
const localizeUtils_1 = require("../../common/localizeUtils");
const folder_1 = require("../../folder");
const projectMigrator_1 = require("../../core/middleware/projectMigrator");
const globalVars_1 = require("../../core/globalVars");
const windowsPathLengthLimit = 260;
const fileNameLengthLimit = 255;
const configFolder = `.${teamsfx_api_1.ConfigFolderName}/configs`;
const azureParameterFileNameTemplate = `azure.parameters.${teamsfx_api_1.EnvNamePlaceholder}.json`;
const stateFolder = `.${teamsfx_api_1.ConfigFolderName}/states`;
const stateFileNameTemplate = `state.${teamsfx_api_1.EnvNamePlaceholder}.json`;
const userDateFileNameTemplate = `${teamsfx_api_1.EnvNamePlaceholder}.userdata`;
const jsonSuffix = ".json";
const userDataSuffix = ".userdata";
const appSettingsFileName = "appsettings.Development.json";
const reportName = "backup-config-change-logs.md";
async function doesBackupFolderCreatedByTTK(backupPath) {
    return ((await fs_extra_1.default.readdir(backupPath)).length === 0 ||
        (await fs_extra_1.default.pathExists(path_1.default.join(backupPath, ".fx"))) ||
        (await fs_extra_1.default.pathExists(path_1.default.join(backupPath, "aad-manifest-change-logs.md"))) ||
        (await fs_extra_1.default.pathExists(path_1.default.join(backupPath, "upgrade-change-logs.md"))));
}
async function getBackupFolder(projectPath) {
    const backupName = ".backup";
    const backupPath = path_1.default.join(projectPath, backupName);
    const teamsfxBackupPath = path_1.default.join(projectPath, `.teamsfx${backupName}`);
    if (!(await fs_extra_1.default.pathExists(backupPath)) || (await doesBackupFolderCreatedByTTK(backupPath))) {
        return backupPath;
    }
    return teamsfxBackupPath;
}
async function backupFiles(env, projectPath, isCSharpProject, isVSPlatform, ctx) {
    const time = formatDate();
    const backupFolder = await getBackupFolder(projectPath);
    // state file
    const stateFileBackupRes = await backupFxFile(projectPath, env, stateFileNameTemplate, stateFolder, backupFolder, time, jsonSuffix);
    if (stateFileBackupRes.isErr()) {
        return teamsfx_api_1.err(stateFileBackupRes.error);
    }
    // user data file
    const userDataFileBackupRes = await backupFxFile(projectPath, env, userDateFileNameTemplate, stateFolder, backupFolder, time, userDataSuffix);
    if (userDataFileBackupRes.isErr()) {
        return teamsfx_api_1.err(userDataFileBackupRes.error);
    }
    // Azure parameter file
    if (env !== "local") {
        const azureParameterFileBackupRes = await backupFxFile(projectPath, env, azureParameterFileNameTemplate, configFolder, backupFolder, time, jsonSuffix);
        if (azureParameterFileBackupRes.isErr()) {
            return teamsfx_api_1.err(azureParameterFileBackupRes.error);
        }
    }
    // Back up appsettings.Development.json
    if (env === "local" && isCSharpProject) {
        const sourceFilePath = path_1.default.join(projectPath, appSettingsFileName);
        const appSettingsBackupRes = await backupSrcFile(sourceFilePath, appSettingsFileName, backupFolder, time, jsonSuffix);
        if (appSettingsBackupRes.isErr()) {
            return teamsfx_api_1.err(appSettingsBackupRes.error);
        }
    }
    // generate readme.
    await generateReport(backupFolder, isVSPlatform, ctx);
    // update .gitignore
    if (await fs_extra_1.default.pathExists(backupFolder)) {
        await projectMigrator_1.addPathToGitignore(projectPath, backupFolder, globalVars_1.TOOLS.logProvider);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.backupFiles = backupFiles;
async function backupSrcFile(sourceFilePath, sourceFileName, backupFileParentPath, time, suffix) {
    try {
        const backupFileName = generateBackupFileName(sourceFileName, backupFileParentPath, suffix, time);
        const backupFile = path_1.default.join(backupFileParentPath, backupFileName);
        await copyFileToBackupFolderIfExists(sourceFilePath, backupFile, backupFileParentPath);
        return teamsfx_api_1.ok(undefined);
    }
    catch (exception) {
        const error = new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToBackupFiles, localizeUtils_1.getDefaultString("core.backupFiles.FailedToBackupFiles", sourceFilePath), localizeUtils_1.getLocalizedString("core.backupFiles.FailedToBackupFiles", sourceFilePath));
        return teamsfx_api_1.err(error);
    }
}
async function backupFxFile(projectPath, env, fileNameTemplate, folder, backupFolder, time, suffix) {
    const sourceFileName = fileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, env);
    const sourceFilePath = path_1.default.join(path_1.default.join(projectPath, folder), sourceFileName);
    const backupFileParentPath = path_1.default.join(backupFolder, folder);
    const res = await backupSrcFile(sourceFilePath, sourceFileName, backupFileParentPath, time, suffix);
    return res;
}
function generateBackupFileName(sourceFileName, backupFileFolder, suffix, time) {
    let fileNamePrefix = sourceFileName.substring(0, sourceFileName.length - suffix.length) + "." + time;
    if (os.type() === "Windows_NT" &&
        backupFileFolder.length + suffix.length + fileNamePrefix.length + 1 > windowsPathLengthLimit) {
        fileNamePrefix = fileNamePrefix.substring(0, windowsPathLengthLimit - 1 - backupFileFolder.length - suffix.length);
    }
    else if (fileNamePrefix.length + suffix.length > fileNameLengthLimit) {
        fileNamePrefix = fileNamePrefix.substring(0, fileNameLengthLimit - suffix.length);
    }
    return fileNamePrefix + suffix;
}
async function copyFileToBackupFolderIfExists(sourceFile, targetFile, targetFolder) {
    if (await fs_extra_1.default.pathExists(sourceFile)) {
        await fs_extra_1.default.ensureDir(targetFolder);
        await fs_extra_1.default.copyFile(sourceFile, targetFile, fs_extra_1.default.constants.COPYFILE_EXCL);
    }
}
function formatDate() {
    const date = new Date();
    return [
        date.getFullYear(),
        convertTo2Digits(date.getMonth() + 1),
        convertTo2Digits(date.getDate()),
        convertTo2Digits(date.getHours()),
        convertTo2Digits(date.getMinutes()),
        convertTo2Digits(date.getSeconds()),
    ].join("");
}
function convertTo2Digits(num) {
    return num.toString().padStart(2, "0");
}
async function generateReport(backupFolder, isVSPlatform, ctx) {
    try {
        const target = path_1.default.join(backupFolder, reportName);
        const source = path_1.default.resolve(path_1.default.join(folder_1.getResourceFolder(), reportName));
        if (!(await fs_extra_1.default.pathExists(target))) {
            await fs_extra_1.default.copyFile(source, target);
            if ((await fs_extra_1.default.pathExists(target)) && !!ctx.userInteraction.openFile && isVSPlatform) {
                await ctx.userInteraction.openFile(target);
            }
        }
    }
    catch (error) {
        // do nothing
    }
}
//# sourceMappingURL=backupFiles.js.map