"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.listFilePaths = exports.forEachFileAndDir = exports.zipFolderAsync = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const klaw_1 = tslib_1.__importDefault(require("klaw"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const path_1 = tslib_1.__importDefault(require("path"));
const glob_1 = tslib_1.__importDefault(require("glob"));
const deployConstant_1 = require("../constant/deployConstant");
const deployError_1 = require("../error/deployError");
/**
 * Asynchronously zip a folder and return buffer
 * @param sourceDir base dir
 * @param notIncluded block list
 * @param cache zip cache file location
 */
async function zipFolderAsync(sourceDir, cache, notIncluded) {
    const normalizeTime = (t) => Math.floor(t / deployConstant_1.DeployConstant.ZIP_TIME_MS_GRANULARITY);
    const tasks = [];
    const zipFiles = new Set();
    const ig = notIncluded !== null && notIncluded !== void 0 ? notIncluded : ignore_1.default();
    const cacheFile = await readZip(cache);
    const zip = cacheFile !== null && cacheFile !== void 0 ? cacheFile : new adm_zip_1.default();
    const addFileIntoZip = async (zp, filePath, zipPath, stats) => {
        var _a;
        const content = await fs.readFile(filePath);
        zp.addFile(zipPath, content);
        if (stats) {
            ((_a = zp.getEntry(zipPath)) === null || _a === void 0 ? void 0 : _a.header).time = stats.mtime;
        }
    };
    await forEachFileAndDir(sourceDir, (itemPath, stats) => {
        const relativePath = path_1.default.relative(sourceDir, itemPath);
        if (relativePath && !stats.isDirectory()) {
            zipFiles.add(relativePath);
            const entry = zip.getEntry(relativePath);
            if (entry) {
                // The header is an object, the ts declare of adm-zip is wrong.
                const header = entry.header;
                const mtime = header ? header.time : new Date(0);
                // Some files' mtime in node_modules are too old, which may be invalid,
                // so we arbitrarily add a limitation to update this kind of files.
                // If mtime is valid and the two mtime is same in two-seconds, we think the two are same file.
                if (mtime >= deployConstant_1.DeployConstant.LATEST_TRUST_MS_TIME &&
                    normalizeTime(mtime.getTime()) === normalizeTime(stats.mtime.getTime())) {
                    return;
                }
                // Delete the entry because the file has been updated.
                zip.deleteFile(relativePath);
            }
            // If fail to reuse cached entry, load it from disk.
            const fullPath = path_1.default.join(sourceDir, relativePath);
            const task = addFileIntoZip(zip, fullPath, relativePath, stats);
            tasks.push(task);
        }
    }, (itemPath) => {
        return !ig.test(path_1.default.relative(sourceDir, itemPath)).ignored;
    });
    if (!tasks && !cacheFile) {
        throw deployError_1.DeployUserInputError.noFilesFindInDistFolder();
    }
    await Promise.all(tasks);
    removeLegacyFileInZip(zip, zipFiles);
    // save to cache if exists
    const buffer = zip.toBuffer();
    if (cache && tasks) {
        await fs.mkdirs(path_1.default.dirname(cache));
        await fs.writeFile(cache, buffer);
    }
    return buffer;
}
exports.zipFolderAsync = zipFolderAsync;
async function forEachFileAndDir(root, callback, filter) {
    await new Promise((resolve, reject) => {
        const stream = klaw_1.default(root, { filter: filter });
        stream
            .on("data", (item) => {
            if (callback(item.path, item.stats)) {
                stream.emit("close");
            }
        })
            .on("end", () => resolve({}))
            .on("error", (err) => reject(err))
            .on("close", () => resolve({}));
    });
}
exports.forEachFileAndDir = forEachFileAndDir;
function removeLegacyFileInZip(zip, existenceFiles) {
    zip
        .getEntries()
        .filter((entry) => !existenceFiles.has(entry.name))
        .forEach((entry) => {
        zip.deleteFile(entry.name);
    });
}
async function readZip(cache) {
    try {
        const content = await fs.readFile(cache);
        return new adm_zip_1.default(content);
    }
    catch (_a) {
        // Failed to load cache, it doesn't block deployment.
    }
    return undefined;
}
/**
 * Recursively list all files that match a naming pattern in a specified directory
 * @param directoryPath base dir
 * @param matchPattern filename pattern
 * @param ignorePattern filename ignore pattern
 */
async function listFilePaths(directoryPath, matchPattern = "**", ignorePattern) {
    return new Promise((resolve, reject) => {
        const ignore = ignorePattern ? path_1.default.join(directoryPath, ignorePattern) : "";
        glob_1.default(path_1.default.join(directoryPath, matchPattern), {
            dot: true,
            nodir: true,
            ignore,
        }, (error, filePaths) => {
            if (error) {
                reject(error);
            }
            else {
                resolve(filePaths);
            }
        });
    });
}
exports.listFilePaths = listFilePaths;
//# sourceMappingURL=fileOperation.js.map