"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dotenvUtil = exports.DotenvUtil = exports.envUtil = exports.EnvUtil = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const settingsUtil_1 = require("./settingsUtil");
const crypto_1 = require("../../core/crypto");
const localizeUtils_1 = require("../../common/localizeUtils");
const pathUtils_1 = require("./pathUtils");
const globalVars_1 = require("../../core/globalVars");
const path = tslib_1.__importStar(require("path"));
const os_1 = require("os");
class EnvUtil {
    /**
     * read .env file and set to process.env (if loadToProcessEnv = true)
     * if silent = true, no error will return if .env file is not available, this function returns ok({ TEAMSFX_ENV: env })
     * if silent = false, this function will return error if .env file is not available.
     * @param projectPath
     * @param env
     * @param loadToProcessEnv
     * @param silent
     * @returns
     */
    async readEnv(projectPath, env, loadToProcessEnv = true, silent = true) {
        // read
        const dotEnvFilePathRes = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, env);
        if (dotEnvFilePathRes.isErr())
            return teamsfx_api_1.err(dotEnvFilePathRes.error);
        const dotEnvFilePath = dotEnvFilePathRes.value;
        if (!dotEnvFilePath || !(await fs_extra_1.default.pathExists(dotEnvFilePath))) {
            if (silent) {
                // .env file does not exist, just ignore
                process.env.TEAMSFX_ENV = env;
                return teamsfx_api_1.ok({ TEAMSFX_ENV: env });
            }
            else {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    source: "core",
                    name: "DotEnvFileNotExistError",
                    displayMessage: localizeUtils_1.getLocalizedString("error.DotEnvFileNotExistError", env, env),
                    message: localizeUtils_1.getDefaultString("error.DotEnvFileNotExistError", env, env),
                }));
            }
        }
        // deserialize
        const parseResult = exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath, { encoding: "utf8" }));
        // decrypt
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        for (const key of Object.keys(parseResult.obj)) {
            if (key.startsWith("SECRET_")) {
                const raw = parseResult.obj[key];
                if (raw.startsWith("crypto_")) {
                    const decryptRes = await cryptoProvider.decrypt(raw);
                    if (decryptRes.isErr())
                        return teamsfx_api_1.err(decryptRes.error);
                    parseResult.obj[key] = decryptRes.value;
                }
            }
        }
        parseResult.obj.TEAMSFX_ENV = env;
        if (loadToProcessEnv) {
            lodash_1.merge(process.env, parseResult.obj);
        }
        return teamsfx_api_1.ok(parseResult.obj);
    }
    /**
     * write env variables into .env file,
     * if .env file does not exist, this function will create a default one
     * if .env fila path is not available, the default path is `./env/.env.{env}`
     * @param projectPath
     * @param env
     * @param envs
     * @returns
     */
    async writeEnv(projectPath, env, envs) {
        envs.TEAMSFX_ENV = env;
        //encrypt
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return teamsfx_api_1.err(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        for (const key of Object.keys(envs)) {
            let value = envs[key];
            if (value && key.startsWith("SECRET_")) {
                const res = await cryptoProvider.encrypt(value);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                value = res.value;
                envs[key] = value;
            }
        }
        //replace existing, if env file not exist, create a default one
        const dotEnvFilePathRes = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, env);
        if (dotEnvFilePathRes.isErr())
            return teamsfx_api_1.err(dotEnvFilePathRes.error);
        const dotEnvFilePath = dotEnvFilePathRes.value || path.resolve(projectPath, "env", `.env.${env ? env : "dev"}`);
        const envFileExists = await fs_extra_1.default.pathExists(dotEnvFilePath);
        const parsedDotenv = envFileExists
            ? exports.dotenvUtil.deserialize(await fs_extra_1.default.readFile(dotEnvFilePath))
            : { obj: {} };
        lodash_1.merge(parsedDotenv.obj, envs);
        //serialize
        const content = exports.dotenvUtil.serialize(parsedDotenv);
        //persist
        globalVars_1.TOOLS.logProvider.info(`  Env output:\n${content}\n`);
        if (!envFileExists)
            await fs_extra_1.default.ensureFile(dotEnvFilePath);
        await fs_extra_1.default.writeFile(dotEnvFilePath, content, { encoding: "utf8" });
        if (!envFileExists) {
            globalVars_1.TOOLS.logProvider.info("  Created environment file at " + dotEnvFilePath + os_1.EOL + os_1.EOL);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async listEnv(projectPath) {
        const folderRes = await pathUtils_1.pathUtils.getEnvFolderPath(projectPath);
        if (folderRes.isErr())
            return teamsfx_api_1.err(folderRes.error);
        const envFolderPath = folderRes.value;
        if (!envFolderPath)
            return teamsfx_api_1.ok([]);
        const list = await fs_extra_1.default.readdir(envFolderPath);
        const envs = list
            .filter((fileName) => fileName.startsWith(".env."))
            .map((fileName) => fileName.substring(5));
        return teamsfx_api_1.ok(envs);
    }
    object2map(obj) {
        const map = new Map();
        for (const key of Object.keys(obj)) {
            map.set(key, obj[key]);
        }
        return map;
    }
    map2object(map) {
        const obj = {};
        for (const key of map.keys()) {
            obj[key] = map.get(key) || "";
        }
        return obj;
    }
}
exports.EnvUtil = EnvUtil;
exports.envUtil = new EnvUtil();
const KEY_VALUE_PAIR_RE = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
const NEW_LINE_RE = /\\n/g;
const NEW_LINE_SPLITTER = /\r?\n/;
const NEW_LINE = "\n";
class DotenvUtil {
    deserialize(src) {
        const lines = [];
        const obj = {};
        const stringLines = src.toString().split(NEW_LINE_SPLITTER);
        for (const line of stringLines) {
            const kvMatchArray = line.match(KEY_VALUE_PAIR_RE);
            if (kvMatchArray !== null) {
                // match key-value pair
                const key = kvMatchArray[1];
                let value = kvMatchArray[2] || "";
                let inlineComment;
                const dQuoted = value[0] === '"' && value[value.length - 1] === '"';
                const sQuoted = value[0] === "'" && value[value.length - 1] === "'";
                let quote = undefined;
                if (sQuoted || dQuoted) {
                    quote = dQuoted ? '"' : "'";
                    value = value.substring(1, value.length - 1);
                    if (dQuoted) {
                        value = value.replace(NEW_LINE_RE, NEW_LINE);
                    }
                }
                else {
                    value = value.trim();
                    //try to match comment starter
                    const index = value.indexOf("#");
                    if (index >= 0) {
                        inlineComment = value.substring(index);
                        value = value.substring(0, index).trim();
                    }
                }
                if (value)
                    obj[key] = value;
                const parsedLine = { key: key, value: value };
                if (inlineComment)
                    parsedLine.comment = inlineComment;
                if (quote)
                    parsedLine.quote = quote;
                lines.push(parsedLine);
            }
            else {
                lines.push(line);
            }
        }
        return { lines: lines, obj: obj };
    }
    serialize(parsed) {
        const array = [];
        const obj = lodash_1.cloneDeep(parsed.obj);
        //append lines
        if (parsed.lines) {
            parsed.lines.forEach((line) => {
                if (typeof line === "string") {
                    // keep comment line or empty line
                    array.push(line);
                }
                else {
                    if (obj[line.key] !== undefined) {
                        // use kv in obj
                        line.value = obj[line.key];
                        delete obj[line.key];
                    }
                    if (line.value.includes("#")) {
                        // if value contains '#', need add quote
                        line.quote = '"';
                    }
                    array.push(`${line.key}=${line.quote ? line.quote + line.value + line.quote : line.value}${line.comment ? " " + line.comment : ""}`);
                }
            });
        }
        //append additional kvs in object
        for (const key of Object.keys(obj)) {
            let value = parsed.obj[key];
            if (value.includes("#"))
                value = `"${value}"`; // if value contains '#', need add quote
            array.push(`${key}=${value}`);
        }
        return array.join("\n").trim();
    }
}
exports.DotenvUtil = DotenvUtil;
exports.dotenvUtil = new DotenvUtil();
// const original = `# Built-in environment variables
// TEAMSFX_ENV=dev2
// AZURE_SUBSCRIPTION_ID=
// AZURE_RESOURCE_GROUP_NAME=
// RESOURCE_SUFFIX=
// # Generated during provision, you can also add your own variables. If you're adding a secret value, add SECRET_ prefix to the name so Teams Toolkit can handle them properly
// BOT_ID=
// SECRET_BOT_PASSWORD=
// TEAMS_APP_ID=
// BOT_AZURE_FUNCTION_APP_RESOURCE_ID=
// BOT_DOMAIN=
// BOT_FUNCTION_ENDPOINT=
// TEAMS_APP_TENANT_ID=
// `;
// const parsed = dotenvUtil.deserialize(original);
// console.log(parsed)
//# sourceMappingURL=envUtil.js.map