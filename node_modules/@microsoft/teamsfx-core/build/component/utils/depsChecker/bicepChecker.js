"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureBicepForDriver = exports.getAvailableBicepVersions = exports.ensureBicep = exports.supportedVersions = exports.fallbackInstallVersion = exports.installVersionPattern = exports.installVersion = exports.BicepName = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const semver = tslib_1.__importStar(require("semver"));
const cpUtils_1 = require("./cpUtils");
const stream_1 = require("stream");
const common_1 = require("./common");
const constants_1 = require("../../constants");
const perf_hooks_1 = require("perf_hooks");
const utils_1 = require("../../utils");
const tools_1 = require("../../../common/tools");
exports.BicepName = "Bicep";
exports.installVersion = "v0.4";
exports.installVersionPattern = "^v0.4";
exports.fallbackInstallVersion = "v0.4.1008";
exports.supportedVersions = [exports.installVersion];
const timeout = 5 * 60 * 1000;
const source = "bicep-envchecker";
const bicepReleaseApiUrl = "https://api.github.com/repos/Azure/bicep/releases";
async function ensureBicep(ctx, inputs) {
    var _a;
    const bicepChecker = new BicepChecker(ctx.logProvider, ctx.telemetryReporter);
    try {
        if ((await bicepChecker.isEnabled()) && !(await bicepChecker.isInstalled())) {
            await bicepChecker.install();
        }
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`Failed to check or install bicep, error = '${err}'`);
        if (!(await bicepChecker.isGlobalBicepInstalled())) {
            await displayLearnMore(common_1.Messages.failToInstallBicepDialog()
                .split("@NameVersion")
                .join(bicepChecker.getBicepDisplayBicepName()), common_1.bicepHelpLink, ctx.ui || ctx.userInteraction, ctx.telemetryReporter);
            outputErrorMessage(ctx, bicepChecker, inputs);
            throw err;
        }
    }
    return bicepChecker.getBicepCommand();
}
exports.ensureBicep = ensureBicep;
async function getAvailableBicepVersions() {
    const bicepChecker = new BicepChecker();
    return await bicepChecker.getVersions();
}
exports.getAvailableBicepVersions = getAvailableBicepVersions;
async function ensureBicepForDriver(ctx, version, platform) {
    var _a;
    const bicepChecker = new BicepChecker(ctx.logProvider, ctx.telemetryReporter, version);
    try {
        const isPrivateBicepInstalled = await bicepChecker.isPrivateBicepInstalled();
        if (!isPrivateBicepInstalled) {
            await bicepChecker.install();
        }
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`Failed to check or install bicep, error = '${err}'`);
        await displayLearnMore(common_1.Messages.failToInstallBicepDialog()
            .split("@NameVersion")
            .join(bicepChecker.getBicepDisplayBicepName()), common_1.bicepHelpLink, ctx.ui, ctx.telemetryReporter);
        outputErrorMessage(ctx, bicepChecker, platform ? { platform: platform } : undefined);
        throw err;
    }
    return bicepChecker.getBicepCommand();
}
exports.ensureBicepForDriver = ensureBicepForDriver;
function outputErrorMessage(ctx, bicepChecker, inputs) {
    var _a;
    const message = (inputs === null || inputs === void 0 ? void 0 : inputs.platform) === teamsfx_api_1.Platform.VSCode
        ? common_1.Messages.failToInstallBicepOutputVSC()
        : common_1.Messages.failToInstallBicepOutputCLI();
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.warning(message
        .split("@NameVersion")
        .join(bicepChecker.getBicepDisplayBicepName())
        .split("@HelpLink")
        .join(common_1.bicepHelpLink));
}
class BicepChecker {
    constructor(logger, telemetry, version) {
        this._logger = logger;
        this._telemetry = telemetry;
        this._version = version;
        this._axios = axios_1.default.create({
            headers: { "content-type": "application/json" },
        });
    }
    async isEnabled() {
        var _a;
        const isBicepEnabled = tools_1.isBicepEnvCheckerEnabled();
        if (!isBicepEnabled) {
            (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepCheckSkipped, getCommonProps());
        }
        return isBicepEnabled;
    }
    async isInstalled() {
        var _a, _b;
        const isGlobalBicepInstalled = await this.isGlobalBicepInstalled();
        const isPrivateBicepInstalled = await this.isPrivateBicepInstalled();
        if (isGlobalBicepInstalled) {
            (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepAlreadyInstalled, getCommonProps());
        }
        if (isPrivateBicepInstalled) {
            // always install private bicep even if global bicep exists.
            (_b = this._telemetry) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepInstallCompleted, getCommonProps());
            return true;
        }
        return false;
    }
    async install() {
        await this.cleanup();
        await this.installBicep();
        if (!this._version && !(await this.validate())) {
            await this.handleInstallFailed();
        }
        await this.handleInstallCompleted();
    }
    async getVersions() {
        const response = await this._axios.get(bicepReleaseApiUrl, {
            headers: { Accept: "application/vnd.github.v3+json" },
        });
        const versions = response.data.map((item) => item.tag_name);
        return versions;
    }
    async cleanup() {
        var _a;
        try {
            await fs.emptyDir(this.getBicepInstallDir());
        }
        catch (err) {
            await ((_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`Failed to clean up path: ${this.getBicepInstallDir()}, error: ${err}`));
        }
    }
    async installBicep() {
        var _a, _b;
        try {
            const start = perf_hooks_1.performance.now();
            await this.doInstallBicep();
            (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepInstallScriptCompleted, getCommonProps(), {
                [common_1.TelemetryMeasurement.completionTime]: Number(((perf_hooks_1.performance.now() - start) / 1000).toFixed(2)),
            });
        }
        catch (err) {
            sendSystemErrorEvent(common_1.DepsCheckerEvent.bicepInstallScriptError, common_1.TelemtryMessages.failedToInstallBicep, err, this._telemetry);
            await ((_b = this._logger) === null || _b === void 0 ? void 0 : _b.error(`${common_1.Messages.failToInstallBicep()
                .split("@NameVersion")
                .join(this.getBicepDisplayBicepName())}, error = '${err}'`));
        }
    }
    getBicepDisplayBicepName() {
        return `${exports.BicepName} (${this._version || exports.installVersion})`;
    }
    async doInstallBicep() {
        var _a, _b;
        let selectedVersion;
        if (this._version) {
            selectedVersion = this._version;
        }
        else {
            try {
                const response = await this._axios.get(bicepReleaseApiUrl, {
                    headers: { Accept: "application/vnd.github.v3+json" },
                });
                const versions = response.data.map((item) => item.tag_name);
                const maxSatisfying = semver.maxSatisfying(versions, exports.installVersionPattern);
                selectedVersion = maxSatisfying || exports.fallbackInstallVersion;
            }
            catch (e) {
                // GitHub public API has a limit of 60 requests per hour per IP
                // If it fails to retrieve the latest version, just use a known version.
                selectedVersion = exports.fallbackInstallVersion;
                (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepFailedToRetrieveGithubReleaseVersions, { [common_1.TelemetryMeasurement.ErrorMessage]: `${e}` });
            }
        }
        const installDir = this.getBicepExecPath();
        await ((_b = this._logger) === null || _b === void 0 ? void 0 : _b.info(common_1.Messages.downloadBicep()
            .replace("@NameVersion", `Bicep ${selectedVersion}`)
            .replace("@InstallDir", installDir)));
        const axiosResponse = await this._axios.get(`https://github.com/Azure/bicep/releases/download/${selectedVersion}/${this.getBicepBitSuffixName()}`, {
            timeout: timeout,
            timeoutErrorMessage: "Failed to download bicep by http request timeout",
            responseType: "stream",
        });
        const bicepReader = axiosResponse.data;
        const bicepWriter = fs.createWriteStream(installDir);
        // https://nodejs.org/api/fs.html#fscreatewritestreampath-options
        // on 'error' or 'finish' the file descriptor will be closed automatically
        // calling writer.end() again will hang
        await this.writeBicepBits(bicepWriter, bicepReader);
        fs.chmodSync(installDir, 0o755);
    }
    async writeBicepBits(writer, reader) {
        return new Promise((resolve, reject) => {
            reader.pipe(writer);
            stream_1.finished(writer, (err) => {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    async validate() {
        var _a, _b;
        let isVersionSupported = false;
        let privateVersion = "";
        try {
            privateVersion = await this.queryVersion(this.getBicepExecPath());
            isVersionSupported = this.isVersionSupported(privateVersion);
        }
        catch (err) {
            sendSystemErrorEvent(common_1.DepsCheckerEvent.bicepValidationError, common_1.TelemtryMessages.failedToValidateBicep, err, this._telemetry);
            await ((_a = this._logger) === null || _a === void 0 ? void 0 : _a.error(`${common_1.TelemtryMessages.failedToValidateBicep}, error = ${err}`));
        }
        if (!isVersionSupported) {
            (_b = this._telemetry) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepValidationError, Object.assign({ "bicep-private-version": privateVersion }, getCommonProps()));
        }
        return isVersionSupported;
    }
    async handleInstallCompleted() {
        var _a, _b;
        (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(common_1.DepsCheckerEvent.bicepInstallCompleted);
        await ((_b = this._logger) === null || _b === void 0 ? void 0 : _b.info(common_1.Messages.finishInstallBicep().replace("@NameVersion", this.getBicepDisplayBicepName())));
    }
    async handleInstallFailed() {
        var _a;
        await this.cleanup();
        (_a = this._telemetry) === null || _a === void 0 ? void 0 : _a.sendTelemetryErrorEvent(common_1.DepsCheckerEvent.bicepInstallError);
        throw new teamsfx_api_1.SystemError(source, common_1.DepsCheckerEvent.bicepInstallError, common_1.Messages.failToInstallBicep().split("@NameVersion").join(this.getBicepDisplayBicepName()));
    }
    isVersionSupported(version) {
        if (this._version) {
            return this._version === version;
        }
        return exports.supportedVersions.some((supported) => version.includes(supported));
    }
    async isGlobalBicepInstalled() {
        try {
            const version = await this.queryVersion("bicep");
            // not limit bicep versions of user
            return version.includes("v");
        }
        catch (e) {
            // do nothing
            return false;
        }
    }
    async isPrivateBicepInstalled() {
        try {
            const version = await this.queryVersion(this.getBicepExecPath());
            return this.isVersionSupported(version);
        }
        catch (e) {
            // do nothing
            return false;
        }
    }
    async getBicepCommand() {
        if (await this.isInstalled()) {
            return this.getBicepExecPath();
        }
        return "bicep";
    }
    getBicepExecPath() {
        return path.join(this.getBicepInstallDir(), this.getBicepFileName());
    }
    getBicepFileName() {
        if (common_1.isWindows()) {
            return "bicep.exe";
        }
        return "bicep";
    }
    getBicepBitSuffixName() {
        if (common_1.isWindows()) {
            return "bicep-win-x64.exe";
        }
        if (common_1.isMacOS()) {
            return "bicep-osx-x64";
        }
        if (fs.pathExistsSync("/lib/ld-musl-x86_64.so.1")) {
            return "bicep-linux-musl-x64";
        }
        return "bicep-linux-x64";
    }
    getBicepInstallDir() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "bicep", this._version || "");
    }
    async queryVersion(path) {
        var _a, _b, _c;
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: false }, path, "--version");
        const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
        const match = regex.exec(output);
        if (!match) {
            return "";
        }
        return `v${(_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version}.${(_b = match.groups) === null || _b === void 0 ? void 0 : _b.minor_version}.${(_c = match.groups) === null || _c === void 0 ? void 0 : _c.patch_version}`;
    }
}
function sendSystemErrorEvent(eventName, errorMessage, errorStack, telemetry) {
    const error = new teamsfx_api_1.SystemError(source, eventName, `errorMsg=${errorMessage},errorStack=${errorStack}`);
    error.stack = errorStack;
    utils_1.sendErrorTelemetryThenReturnError(eventName, error, telemetry, getCommonProps());
}
function getCommonProps() {
    const properties = {};
    properties[common_1.TelemetryMeasurement.OSArch] = os.arch();
    properties[common_1.TelemetryMeasurement.OSRelease] = os.release();
    properties[constants_1.SolutionTelemetryProperty.Component] = constants_1.SolutionTelemetryComponentName;
    properties[constants_1.SolutionTelemetryProperty.Success] = constants_1.SolutionTelemetrySuccess.Yes;
    return properties;
}
async function displayLearnMore(message, link, ui, telemetryReporter) {
    if (!ui) {
        // no dialog, always continue
        return true;
    }
    const res = await (ui === null || ui === void 0 ? void 0 : ui.showMessage("info", message, true, common_1.Messages.learnMoreButtonText()));
    const userSelected = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
    if (userSelected === common_1.Messages.learnMoreButtonText()) {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(common_1.DepsCheckerEvent.clickLearnMore, getCommonProps());
        ui === null || ui === void 0 ? void 0 : ui.openUrl(link);
        return true;
    }
    telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(common_1.DepsCheckerEvent.clickCancel);
    return false;
}
//# sourceMappingURL=bicepChecker.js.map