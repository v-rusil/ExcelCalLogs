// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendErrorTelemetryThenReturnError = exports.scaffoldRootReadme = exports.isCSharpProject = exports.addFeatureNotify = exports.resetEnvInfoWhenSwitchM365 = exports.ensureComponentConnections = exports.ComponentConnections = exports.generateConfigBiceps = exports.isLocalEnv = exports.getHostingComponent = exports.isInComponentConnection = exports.generateResourceBaseName = exports.normalizeName = exports.createDriverContext = exports.createContextV3 = exports.newProjectSettingsV3 = exports.fileEffectPlanString = exports.appendFileEffect = exports.createFileEffect = exports.createFilesEffects = exports.serviceEffectPlanString = exports.fileEffectPlanStrings = exports.persistBicepPlans = exports.persistBicep = exports.bicepUtils = exports.BicepUtils = exports.persistParams = exports.writeParametersJson = exports.readParametersJson = exports.persistParamsBicepPlans = exports.persistConfigBicepPlans = exports.persistConfigBicep = exports.persistProvisionBicepPlans = exports.persistProvisionBicep = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const os_1 = tslib_1.__importDefault(require("os"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const util_1 = require("util");
const uuid = tslib_1.__importStar(require("uuid"));
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const utils_1 = require("../common/utils");
const crypto_1 = require("../core/crypto");
const environment_1 = require("../core/environment");
const globalVars_1 = require("../core/globalVars");
const folder_1 = require("../folder");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const manifestProvider_1 = require("./resource/appManifest/manifestProvider");
const workflow_1 = require("./workflow");
async function persistProvisionBicep(projectPath, provisionBicep) {
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "provision", `${module}.bicep`);
                await fs_extra_1.default.appendFile(filePath, value.replace(/\r?\n/g, os_1.default.EOL).trim());
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        await fs_extra_1.default.appendFile(filePath, os_1.default.EOL + os_1.default.EOL + provisionBicep.Orchestration.trim().replace(/\r?\n/g, os_1.default.EOL));
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistProvisionBicep = persistProvisionBicep;
async function persistProvisionBicepPlans(projectPath, provisionBicep) {
    const plans = [];
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "provision", `${module}.bicep`);
                const effect = appendFileEffect(filePath, `provision module bicep for ${module}`);
                const plan = fileEffectPlanString(effect);
                if (plan) {
                    plans.push(plan);
                }
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        const effect = appendFileEffect(filePath, "provision orchestration bicep");
        const plan = fileEffectPlanString(effect);
        if (plan) {
            plans.push(plan);
        }
    }
    return plans;
}
exports.persistProvisionBicepPlans = persistProvisionBicepPlans;
async function persistConfigBicep(projectPath, configBicep) {
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (configBicep.Modules) {
        for (const module of Object.keys(configBicep.Modules)) {
            const value = configBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "teamsFx", `${module}.bicep`);
                fs_extra_1.default.outputFileSync(filePath, value.replace(/\r?\n/g, os_1.default.EOL).trim(), { encoding: "utf-8" });
            }
        }
    }
    if (configBicep.Orchestration) {
        const filePath = path.join(templateFolder, "config.bicep");
        fs_extra_1.default.appendFileSync(filePath, os_1.default.EOL + os_1.default.EOL + configBicep.Orchestration.trim().replace(/\r?\n/g, os_1.default.EOL));
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistConfigBicep = persistConfigBicep;
async function persistConfigBicepPlans(projectPath, provisionBicep) {
    const plans = [];
    const templateRoot = await utils_1.getProjectTemplatesFolderPath(projectPath);
    const templateFolder = path.join(templateRoot, "azure");
    if (provisionBicep.Modules) {
        for (const module of Object.keys(provisionBicep.Modules)) {
            const value = provisionBicep.Modules[module];
            if (value) {
                const filePath = path.join(templateFolder, "teamsFx", `${module}.bicep`);
                const effect = createFileEffect(filePath, "replace", `configuration module bicep for ${module}`);
                const plan = fileEffectPlanString(effect);
                if (plan) {
                    plans.push(plan);
                }
            }
        }
    }
    if (provisionBicep.Orchestration) {
        const filePath = path.join(templateFolder, "provision.bicep");
        const effect = appendFileEffect(filePath, "configuration orchestration bicep");
        const plan = fileEffectPlanString(effect);
        if (plan) {
            plans.push(plan);
        }
    }
    return plans;
}
exports.persistConfigBicepPlans = persistConfigBicepPlans;
function persistParamsBicepPlans(projectPath, params) {
    const plans = [];
    if (Object.keys(params).length === 0)
        return [];
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    fs_extra_1.default.ensureDirSync(parameterEnvFolderPath);
    const configFiles = fs_extra_1.default.readdirSync(parameterEnvFolderPath);
    const remoteEnvNames = configFiles
        .map((file) => {
        const match = /^config\.(?<envName>[\w\d-_]+)\.json$/i.exec(file);
        if (match != null && match.groups != null) {
            const envName = match.groups.envName;
            if (envName !== "local")
                return envName;
        }
        return null;
    })
        .filter((env) => env !== null);
    for (const env of remoteEnvNames) {
        const parameterFileName = `azure.parameters.${env}.json`;
        const parameterEnvFilePath = path.join(parameterEnvFolderPath, parameterFileName);
        const effect = createFileEffect(parameterEnvFilePath, "replace");
        const plan = fileEffectPlanString(effect);
        if (plan)
            plans.push(plan);
    }
    return plans;
}
exports.persistParamsBicepPlans = persistParamsBicepPlans;
async function readParametersJson(projectPath, env) {
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    const parameterFileName = `azure.parameters.${env}.json`;
    const parameterEnvFilePath = path.join(parameterEnvFolderPath, parameterFileName);
    if (await fs_extra_1.default.pathExists(parameterEnvFilePath)) {
        const json = await fs_extra_1.default.readJson(parameterEnvFilePath);
        return json;
    }
    return undefined;
}
exports.readParametersJson = readParametersJson;
async function writeParametersJson(projectPath, env, json) {
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    const parameterFileName = `azure.parameters.${env}.json`;
    const parameterEnvFilePath = path.join(parameterEnvFolderPath, parameterFileName);
    let parameterFileContent = JSON.stringify(json, undefined, 2);
    parameterFileContent = parameterFileContent.replace(/\r?\n/g, os_1.default.EOL);
    await fs_extra_1.default.writeFile(parameterEnvFilePath, parameterFileContent);
}
exports.writeParametersJson = writeParametersJson;
async function persistParams(projectPath, appName, params) {
    const envListResult = await environment_1.environmentManager.listRemoteEnvConfigs(projectPath);
    if (envListResult.isErr()) {
        return teamsfx_api_1.err(envListResult.error);
    }
    const parameterEnvFolderPath = path.join(projectPath, ".fx", "configs");
    await fs_extra_1.default.ensureDir(parameterEnvFolderPath);
    for (const env of envListResult.value) {
        let json = await readParametersJson(projectPath, env);
        if (json) {
            json.parameters = json.parameters || {};
            json.parameters.provisionParameters = json.parameters.provisionParameters || {};
            json.parameters.provisionParameters.value = json.parameters.provisionParameters.value || {};
            const existingParams = json.parameters.provisionParameters.value;
            Object.assign(existingParams, params);
            if (!existingParams.resourceBaseName) {
                existingParams.resourceBaseName = generateResourceBaseName(appName, "");
            }
            json.parameters.provisionParameters.value = existingParams;
        }
        else {
            params = params || {};
            if (!params.resourceBaseName) {
                params.resourceBaseName = generateResourceBaseName(appName, "");
            }
            json = {
                $schema: "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
                contentVersion: "1.0.0.0",
                parameters: { provisionParameters: { value: params } },
            };
        }
        await writeParametersJson(projectPath, env, json);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.persistParams = persistParams;
class BicepUtils {
    async persistBiceps(projectPath, appName, biceps) {
        for (const bicep of biceps) {
            const res = await persistBicep(projectPath, appName, bicep);
            if (res.isErr())
                return res;
        }
        return teamsfx_api_1.ok(undefined);
    }
}
exports.BicepUtils = BicepUtils;
exports.bicepUtils = new BicepUtils();
async function persistBicep(projectPath, appName, bicep) {
    if (bicep.Provision) {
        const res = await persistProvisionBicep(projectPath, bicep.Provision);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
    }
    if (bicep.Configuration) {
        const res = await persistConfigBicep(projectPath, bicep.Configuration);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
    }
    // if (bicep.Parameters) {
    const res = await persistParams(projectPath, appName, bicep.Parameters);
    if (res.isErr())
        return teamsfx_api_1.err(res.error);
    // }
    return teamsfx_api_1.ok(undefined);
}
exports.persistBicep = persistBicep;
async function persistBicepPlans(projectPath, bicep) {
    let plans = [];
    if (bicep.Provision) {
        const res = await persistProvisionBicepPlans(projectPath, bicep.Provision);
        plans = plans.concat(res);
    }
    if (bicep.Configuration) {
        const res = await persistConfigBicepPlans(projectPath, bicep.Configuration);
        plans = plans.concat(res);
    }
    if (bicep.Parameters) {
        const res = persistParamsBicepPlans(projectPath, bicep.Parameters);
        plans = plans.concat(res);
    }
    return plans.filter(Boolean);
}
exports.persistBicepPlans = persistBicepPlans;
function fileEffectPlanStrings(fileEffect) {
    const plans = [];
    if (typeof fileEffect.filePath === "string") {
        plans.push(fileEffectPlanString(fileEffect));
    }
    else {
        for (const file of fileEffect.filePath) {
            plans.push(fileEffectPlanString(Object.assign(Object.assign({}, fileEffect), { filePath: file, remarks: undefined })));
        }
    }
    return plans.filter((p) => p !== undefined);
}
exports.fileEffectPlanStrings = fileEffectPlanStrings;
function serviceEffectPlanString(serviceEffect) {
    return `call cloud service: ${serviceEffect.name} (${serviceEffect.remarks})`;
}
exports.serviceEffectPlanString = serviceEffectPlanString;
function createFilesEffects(files, operateIfExists = "replace", remarks) {
    const effects = [];
    for (const file of files) {
        if (fs_extra_1.default.pathExistsSync(file)) {
            if (operateIfExists === "replace") {
                effects.push({
                    type: "file",
                    filePath: file,
                    operate: "replace",
                    remarks: remarks,
                });
            }
            else {
                effects.push({
                    type: "file",
                    filePath: file,
                    operate: "skipCreate",
                    remarks: remarks,
                });
            }
        }
        else {
            effects.push({
                type: "file",
                filePath: file,
                operate: "create",
                remarks: remarks,
            });
        }
    }
    return effects;
}
exports.createFilesEffects = createFilesEffects;
function createFileEffect(file, operateIfExists = "replace", remarks) {
    if (fs_extra_1.default.pathExistsSync(file)) {
        if (operateIfExists === "replace") {
            return {
                type: "file",
                filePath: file,
                operate: "replace",
                remarks: remarks,
            };
        }
        else if (operateIfExists === "skip") {
            return {
                type: "file",
                filePath: file,
                operate: "skipCreate",
                remarks: remarks,
            };
        }
        else {
            return {
                type: "file",
                filePath: file,
                operate: "append",
                remarks: remarks,
            };
        }
    }
    else {
        return {
            type: "file",
            filePath: file,
            operate: "create",
            remarks: remarks,
        };
    }
}
exports.createFileEffect = createFileEffect;
function appendFileEffect(file, remarks) {
    if (fs_extra_1.default.pathExistsSync(file)) {
        return {
            type: "file",
            filePath: file,
            operate: "append",
            remarks: remarks,
        };
    }
    else {
        return {
            type: "file",
            filePath: file,
            operate: "create",
            remarks: remarks,
        };
    }
}
exports.appendFileEffect = appendFileEffect;
function fileEffectPlanString(effect) {
    if (effect.operate.startsWith("skip"))
        return undefined;
    return effect.remarks
        ? `${effect.operate} file: '${effect.filePath}' (${effect.remarks})`
        : `${effect.operate} file: '${effect.filePath}'`;
}
exports.fileEffectPlanString = fileEffectPlanString;
function newProjectSettingsV3() {
    const projectSettings = {
        appName: "test",
        projectId: uuid.v4(),
        version: projectSettingsHelper_1.getProjectSettingsVersion(),
        components: [],
    };
    return projectSettings;
}
exports.newProjectSettingsV3 = newProjectSettingsV3;
function createContextV3(projectSettings) {
    if (!projectSettings)
        projectSettings = newProjectSettingsV3();
    const context = {
        userInteraction: globalVars_1.TOOLS.ui,
        logProvider: globalVars_1.TOOLS.logProvider,
        telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
        cryptoProvider: new crypto_1.LocalCrypto(projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.projectId),
        permissionRequestProvider: globalVars_1.TOOLS.permissionRequest,
        projectSetting: projectSettings,
        manifestProvider: new manifestProvider_1.DefaultManifestProvider(),
        tokenProvider: globalVars_1.TOOLS.tokenProvider,
    };
    return context;
}
exports.createContextV3 = createContextV3;
function createDriverContext(inputs) {
    const driverContext = {
        azureAccountProvider: globalVars_1.TOOLS.tokenProvider.azureAccountProvider,
        m365TokenProvider: globalVars_1.TOOLS.tokenProvider.m365TokenProvider,
        ui: globalVars_1.TOOLS.ui,
        logProvider: globalVars_1.TOOLS.logProvider,
        telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
        projectPath: inputs.projectPath,
        platform: inputs.platform,
    };
    return driverContext;
}
exports.createDriverContext = createDriverContext;
function normalizeName(appName) {
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return normalizedAppName;
}
exports.normalizeName = normalizeName;
function generateResourceBaseName(appName, envName) {
    const maxAppNameLength = 10;
    const maxEnvNameLength = 4;
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    const normalizedEnvName = envName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return (normalizedAppName.substr(0, maxAppNameLength) +
        normalizedEnvName.substr(0, maxEnvNameLength) +
        uuid.v4().substr(0, 6));
}
exports.generateResourceBaseName = generateResourceBaseName;
function isInComponentConnection(component, item) {
    var _a;
    if ((_a = component.connections) === null || _a === void 0 ? void 0 : _a.includes(item)) {
        return true;
    }
    return false;
}
exports.isInComponentConnection = isInComponentConnection;
function getHostingComponent(component, projectSettings) {
    if (component.hosting) {
        return workflow_1.getComponent(projectSettings, component.hosting);
    }
    return undefined;
}
exports.getHostingComponent = getHostingComponent;
function isLocalEnv(context) {
    var _a;
    return ((_a = context.envInfo) === null || _a === void 0 ? void 0 : _a.envName) === "local";
}
exports.isLocalEnv = isLocalEnv;
async function generateConfigBiceps(context, inputs) {
    ensureComponentConnections(context.projectSetting);
    for (const config of context.projectSetting.components) {
        if (config.name === constants_2.ComponentNames.AzureWebApp ||
            config.name === constants_2.ComponentNames.Function ||
            config.name === constants_2.ComponentNames.APIM) {
            const scenario = config.scenario;
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                componentId: config.name === constants_2.ComponentNames.APIM ? "" : constants_2.scenarioToComponent.get(scenario),
                scenario: config.name === constants_2.ComponentNames.APIM ? "" : scenario,
            });
            const component = typedi_1.Container.get(config.name + "-config");
            const res = await component.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            const persistRes = await exports.bicepUtils.persistBiceps(inputs.projectPath, utils_1.convertToAlphanumericOnly(context.projectSetting.appName), res.value);
            if (persistRes.isErr())
                return persistRes;
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.generateConfigBiceps = generateConfigBiceps;
exports.ComponentConnections = {
    [constants_2.ComponentNames.AzureWebApp]: [
        constants_2.ComponentNames.Identity,
        constants_2.ComponentNames.AzureSQL,
        constants_2.ComponentNames.KeyVault,
        constants_2.ComponentNames.AadApp,
        constants_2.ComponentNames.TeamsTab,
        constants_2.ComponentNames.TeamsBot,
        constants_2.ComponentNames.TeamsApi,
    ],
    [constants_2.ComponentNames.Function]: [
        constants_2.ComponentNames.Identity,
        constants_2.ComponentNames.AzureSQL,
        constants_2.ComponentNames.KeyVault,
        constants_2.ComponentNames.AadApp,
        constants_2.ComponentNames.TeamsTab,
        constants_2.ComponentNames.TeamsBot,
        constants_2.ComponentNames.TeamsApi,
    ],
    [constants_2.ComponentNames.APIM]: [constants_2.ComponentNames.TeamsTab, constants_2.ComponentNames.TeamsBot],
};
function ensureComponentConnections(settingsV3) {
    var _a;
    const exists = (c) => workflow_1.getComponent(settingsV3, c) !== undefined;
    const existingConfigNames = Object.keys(exports.ComponentConnections).filter(exists);
    for (const configName of existingConfigNames) {
        const existingResources = exports.ComponentConnections[configName].filter(exists);
        const configs = settingsV3.components.filter((c) => c.name === configName);
        for (const config of configs) {
            config.connections = lodash_1.cloneDeep(existingResources);
        }
    }
    if (workflow_1.getComponent(settingsV3, constants_2.ComponentNames.TeamsApi) &&
        workflow_1.getComponent(settingsV3, constants_2.ComponentNames.APIM)) {
        const functionConfig = workflow_1.getComponentByScenario(settingsV3, constants_2.ComponentNames.Function, constants_2.Scenarios.Api);
        (_a = functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.connections) === null || _a === void 0 ? void 0 : _a.push(constants_2.ComponentNames.APIM);
    }
}
exports.ensureComponentConnections = ensureComponentConnections;
// clear resources related info in envInfo so that we could provision successfully using new M365 tenant.
function resetEnvInfoWhenSwitchM365(envInfo) {
    const keysToClear = [
        constants_1.BuiltInFeaturePluginNames.appStudio,
        constants_1.BuiltInFeaturePluginNames.aad,
        constants_2.ComponentNames.AppManifest,
        constants_2.ComponentNames.AadApp,
    ];
    const apimKeys = [constants_1.BuiltInFeaturePluginNames.apim, constants_2.ComponentNames.APIM];
    const botKeys = [constants_1.BuiltInFeaturePluginNames.bot, constants_2.ComponentNames.TeamsBot];
    const keys = Object.keys(envInfo.state);
    for (const key of keys) {
        if (keysToClear.includes(key)) {
            delete envInfo.state[key];
        }
        if (apimKeys.includes(key)) {
            delete envInfo.state[key]["apimClientAADObjectId"];
            delete envInfo.state[key]["apimClientAADClientId"];
            delete envInfo.state[key]["apimClientAADClientSecret"];
        }
        if (botKeys.includes(key)) {
            delete envInfo.state[key]["resourceId"];
            delete envInfo.state[key]["botId"];
            delete envInfo.state[key]["botPassword"];
            delete envInfo.state[key]["objectId"];
        }
    }
}
exports.resetEnvInfoWhenSwitchM365 = resetEnvInfoWhenSwitchM365;
function addFeatureNotify(inputs, ui, type, features) {
    const addNames = features.map((c) => `'${c}'`).join(" and ");
    const single = features.length === 1;
    const template = inputs.platform === teamsfx_api_1.Platform.CLI
        ? single
            ? type === "Capability"
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilityNoticeForCli")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourceNoticeForCli")
            : type === "Capability"
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilitiesNoticeForCli")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourcesNoticeForCli")
        : single
            ? type === "Capability"
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilityNotice")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourceNotice")
            : type === "Capability"
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilitiesNotice")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourcesNotice");
    const msg = util_1.format(template, addNames);
    ui.showMessage("info", msg, false);
}
exports.addFeatureNotify = addFeatureNotify;
function isCSharpProject(programmingLanguage) {
    return programmingLanguage === constants_2.ProgrammingLanguage.CSharp;
}
exports.isCSharpProject = isCSharpProject;
async function scaffoldRootReadme(projectSettings, projectPath) {
    if (!projectSettingsHelper_1.isVSProject(projectSettings)) {
        const bot = projectSettingsHelperV3_1.hasBot(projectSettings);
        const tab = projectSettingsHelperV3_1.hasTab(projectSettings);
        const spfxTab = projectSettingsHelperV3_1.hasSPFxTab(projectSettings);
        let sourcePath = "";
        if (tab && bot) {
            sourcePath = path.join(folder_1.getTemplatesFolder(), "plugins", "solution", "README.md");
        }
        else if (spfxTab) {
            sourcePath = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "SPFx", "solution", "rootREADME.md");
        }
        const targetPath = path.join(projectPath, teamsfx_api_1.AutoGeneratedReadme);
        if ((await fs_extra_1.default.pathExists(sourcePath)) && !(await fs_extra_1.default.pathExists(targetPath))) {
            await fs_extra_1.default.copy(sourcePath, targetPath);
        }
    }
}
exports.scaffoldRootReadme = scaffoldRootReadme;
function sendErrorTelemetryThenReturnError(eventName, error, reporter, properties, measurements, errorProps) {
    if (!properties) {
        properties = {};
    }
    if (constants_1.SolutionTelemetryProperty.Component in properties === false) {
        properties[constants_1.SolutionTelemetryProperty.Component] = constants_1.SolutionTelemetryComponentName;
    }
    properties[constants_1.SolutionTelemetryProperty.Success] = "no";
    if (error instanceof teamsfx_api_1.UserError) {
        properties["error-type"] = "user";
    }
    else {
        properties["error-type"] = "system";
    }
    properties["error-code"] = `${error.source}.${error.name}`;
    properties["error-message"] = error.message;
    reporter === null || reporter === void 0 ? void 0 : reporter.sendTelemetryErrorEvent(eventName, properties, measurements, errorProps);
    return error;
}
exports.sendErrorTelemetryThenReturnError = sendErrorTelemetryThenReturnError;
//# sourceMappingURL=utils.js.map