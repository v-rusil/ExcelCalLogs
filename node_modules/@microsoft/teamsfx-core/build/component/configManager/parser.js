"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.yamlParser = exports.YamlParser = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const js_yaml_1 = require("js-yaml");
const error_1 = require("./error");
const interface_1 = require("./interface");
const lifecycle_1 = require("./lifecycle");
const environmentFolderPath = "environmentFolderPath";
function parseRawProjectModel(obj) {
    const result = {};
    if (environmentFolderPath in obj) {
        if (typeof obj[environmentFolderPath] !== "string") {
            return teamsfx_api_1.err(new error_1.InvalidEnvFolderPath());
        }
        result.environmentFolderPath = obj[environmentFolderPath];
    }
    for (const name of interface_1.LifecycleNames) {
        if (name in obj) {
            const value = obj[name];
            if (!Array.isArray(value)) {
                return teamsfx_api_1.err(new error_1.InvalidLifecycleError(name));
            }
            for (const elem of value) {
                if (!("uses" in elem &&
                    "with" in elem &&
                    typeof elem["uses"] === "string" &&
                    typeof elem["with"] === "object")) {
                    return teamsfx_api_1.err(new error_1.InvalidLifecycleError(name));
                }
                if (elem["env"]) {
                    if (typeof elem["env"] !== "object" || Array.isArray(elem["env"])) {
                        return teamsfx_api_1.err(new error_1.InvalidEnvFieldError(elem["uses"], name));
                    }
                    for (const envVar in elem["env"]) {
                        if (typeof elem["env"][envVar] !== "string") {
                            return teamsfx_api_1.err(new error_1.InvalidEnvFieldError(elem["uses"], name));
                        }
                    }
                }
            }
            result[name] = value;
        }
    }
    return teamsfx_api_1.ok(result);
}
class YamlParser {
    async parse(path) {
        const raw = await this.parseRaw(path);
        if (raw.isErr()) {
            return teamsfx_api_1.err(raw.error);
        }
        const result = {};
        for (const name of interface_1.LifecycleNames) {
            if (name in raw.value) {
                const definitions = raw.value[name];
                if (definitions) {
                    result[name] = new lifecycle_1.Lifecycle(name, definitions);
                }
            }
        }
        if (raw.value.environmentFolderPath) {
            result.environmentFolderPath = raw.value.environmentFolderPath;
        }
        return teamsfx_api_1.ok(result);
    }
    async parseRaw(path) {
        try {
            const str = await fs_extra_1.default.readFile(path, "utf8");
            const content = js_yaml_1.load(str);
            // note: typeof null === "object" typeof undefined === "undefined" in js
            if (typeof content !== "object" || Array.isArray(content) || content === null) {
                return teamsfx_api_1.err(new error_1.YamlParsingError(path, new Error(`Invalid yaml format: ${str}`)));
            }
            const value = content;
            return parseRawProjectModel(value);
        }
        catch (error) {
            if (error instanceof Error) {
                return teamsfx_api_1.err(new error_1.YamlParsingError(path, error));
            }
            else {
                return teamsfx_api_1.err(new error_1.YamlParsingError(path, new Error(`Unknown error: ${JSON.stringify(error)}`)));
            }
        }
    }
}
exports.YamlParser = YamlParser;
exports.yamlParser = new YamlParser();
//# sourceMappingURL=parser.js.map