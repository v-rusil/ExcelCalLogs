"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lifecycle = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const typedi_1 = require("typedi");
const teamsFxTelemetryReporter_1 = require("../utils/teamsFxTelemetryReporter");
const constant_1 = require("./constant");
const error_1 = require("./error");
function resolveDriverDef(def, resolved, unresolved) {
    const args = def.with;
    for (const k in args) {
        const val = args[k];
        args[k] = resolve(val, resolved, unresolved);
    }
    if (def.env) {
        for (const k in def.env) {
            const val = def.env[k];
            def.env[k] = resolveString(val, resolved, unresolved);
        }
    }
}
// Replace placeholders in the driver definitions' `with` field inplace
// and returns resolved and unresolved placeholders
function resolvePlaceHolders(defs) {
    const resolvedVars = [];
    const unresolvedVars = [];
    for (const def of defs) {
        resolveDriverDef(def, resolvedVars, unresolvedVars);
    }
    return [resolvedVars, unresolvedVars];
}
function resolve(input, resolved, unresolved) {
    if (input === undefined || input === null) {
        return input;
    }
    else if (typeof input === "string") {
        return resolveString(input, resolved, unresolved);
    }
    else if (Array.isArray(input)) {
        const newArray = [];
        for (const e of input) {
            newArray.push(resolve(e, resolved, unresolved));
        }
        return newArray;
    }
    else if (input !== null && typeof input === "object") {
        const newObj = lodash_1.default.cloneDeep(input);
        Object.keys(newObj).forEach((key) => {
            newObj[key] = resolve(newObj[key], resolved, unresolved);
        });
        return newObj;
    }
    else {
        return input;
    }
}
function resolveString(val, resolved, unresolved) {
    const placeHolderReg = /\${{\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*}}/g;
    let matches = placeHolderReg.exec(val);
    let newVal = val;
    while (matches != null) {
        const envVar = matches[1];
        const envVal = process.env[envVar];
        if (!envVal) {
            unresolved.push(envVar);
        }
        else {
            resolved.push(envVar);
            newVal = newVal.replace(matches[0], envVal);
        }
        matches = placeHolderReg.exec(val);
    }
    return newVal;
}
class Lifecycle {
    constructor(name, driverDefs) {
        this.driverDefs = driverDefs;
        this.name = name;
    }
    resolvePlaceholders() {
        const result = resolvePlaceHolders(this.driverDefs);
        return result[1];
    }
    static stringifyOutput(output) {
        const obj = {};
        for (const [k, v] of output) {
            if (k.startsWith("SECRET_")) {
                obj[k] = "******";
            }
            else {
                obj[k] = v;
            }
        }
        return JSON.stringify(obj);
    }
    async execute(ctx) {
        const actions = JSON.stringify(this.driverDefs.map((def) => this.stringifyDriverDef(def)));
        const telemetryReporter = new teamsFxTelemetryReporter_1.TeamsFxTelemetryReporter(ctx.telemetryReporter, {
            componentName: constant_1.component,
        });
        telemetryReporter.sendStartEvent({
            eventName: constant_1.lifecycleExecutionEvent,
            properties: {
                [constant_1.TelemetryProperty.Lifecycle]: this.name,
                [constant_1.TelemetryProperty.Actions]: actions,
            },
        });
        ctx.logProvider.info(`Executing lifecycle ${this.name}`);
        const resolved = [];
        const unresolved = [];
        const { result, summaries } = await this.executeImpl(ctx, resolved, unresolved);
        let e;
        let failedAction;
        if (result.isOk()) {
            ctx.logProvider.info(`Finished Executing lifecycle ${this.name}. Result: ${Lifecycle.stringifyOutput(result.value)}`);
        }
        else {
            if (result.error.kind === "Failure") {
                e = result.error.error;
                ctx.logProvider.info(`Failed to Execute lifecycle ${this.name}. ${e.name}:${e.message}`);
            }
            else if (result.error.kind === "PartialSuccess") {
                failedAction = this.stringifyDriverDef(result.error.reason.failedDriver);
                const output = Lifecycle.stringifyOutput(result.error.env);
                if (result.error.reason.kind === "DriverError") {
                    e = result.error.reason.error;
                    ctx.logProvider.info(`Failed to Execute lifecycle ${this.name} due to failed action: ${failedAction}. ${e.name}:${e.message}. Env output: ${output}`);
                }
                else if (result.error.reason.kind === "UnresolvedPlaceholders") {
                    // This error is just for telemetry because sendEndEvent() needs an error as parameter.
                    e = new teamsfx_api_1.UserError(constant_1.component, "UnresolvedPlaceHolders", "UnresolvedPlaceHolders");
                    ctx.logProvider.info(`Failed to Execute lifecycle ${this.name} because there are unresolved placeholders ${JSON.stringify(unresolved)} for action: ${failedAction}. Env output: ${output}`);
                }
            }
        }
        telemetryReporter.sendEndEvent({
            eventName: constant_1.lifecycleExecutionEvent,
            properties: {
                [constant_1.TelemetryProperty.Lifecycle]: this.name,
                [constant_1.TelemetryProperty.Actions]: actions,
                [constant_1.TelemetryProperty.ResolvedPlaceholders]: JSON.stringify(resolved),
                [constant_1.TelemetryProperty.UnresolvedPlaceholders]: JSON.stringify(unresolved),
                [constant_1.TelemetryProperty.FailedAction]: failedAction !== null && failedAction !== void 0 ? failedAction : "",
            },
        }, e);
        return { result, summaries };
    }
    async executeImpl(ctx, resolved, unresolved) {
        const maybeDrivers = this.resolveDriverInstances(ctx.logProvider);
        if (maybeDrivers.isErr()) {
            return { result: teamsfx_api_1.err({ kind: "Failure", error: maybeDrivers.error }), summaries: [] };
        }
        const drivers = maybeDrivers.value;
        const envOutput = new Map();
        const summaries = [];
        for (const driver of drivers) {
            ctx.logProvider.info(`Executing action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name}`);
            resolveDriverDef(driver, resolved, unresolved);
            if (unresolved.length > 0) {
                ctx.logProvider.info(`Unresolved placeholders(${unresolved}) found for Action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name}`);
                summaries.push([
                    `${constant_1.SummaryConstant.Failed} Unresolved placeholders: ${unresolved.join(",")}`,
                ]);
                return {
                    result: teamsfx_api_1.err({
                        kind: "PartialSuccess",
                        env: envOutput,
                        reason: {
                            kind: "UnresolvedPlaceholders",
                            failedDriver: driver,
                            unresolvedPlaceHolders: unresolved,
                        },
                    }),
                    summaries,
                };
            }
            if (driver.env) {
                for (const [envVar, value] of Object.entries(driver.env)) {
                    process.env[envVar] = value;
                }
            }
            let result;
            let summary;
            if (driver.instance.execute) {
                const r = await driver.instance.execute(driver.with, ctx);
                result = r.result;
                summary = r.summaries.map((s) => `${constant_1.SummaryConstant.Succeeded} ${s}`);
            }
            else {
                result = await driver.instance.run(driver.with, ctx);
                // if execute is not implemented, treat it as if no summaries was returned.
                summary = [];
            }
            summaries.push(summary);
            if (result.isErr()) {
                summary.push(`${constant_1.SummaryConstant.Failed} ${result.error.message}`);
                return {
                    result: teamsfx_api_1.err({
                        kind: "PartialSuccess",
                        env: envOutput,
                        reason: {
                            kind: "DriverError",
                            failedDriver: driver,
                            error: result.error,
                        },
                    }),
                    summaries,
                };
            }
            for (const [envVar, value] of result.value) {
                envOutput.set(envVar, value);
                process.env[envVar] = value;
            }
            ctx.logProvider.info(`Action ${this.stringifyDriverDef(driver)} in lifecycle ${this.name} succeeded with output ${Lifecycle.stringifyOutput(result.value)}`);
        }
        return { result: teamsfx_api_1.ok(envOutput), summaries };
    }
    async run(ctx) {
        const maybeDrivers = this.resolveDriverInstances(ctx.logProvider);
        if (maybeDrivers.isErr()) {
            return teamsfx_api_1.err(maybeDrivers.error);
        }
        const drivers = maybeDrivers.value;
        return Lifecycle.runDrivers(drivers, ctx);
    }
    static async runDrivers(drivers, ctx) {
        const envOutput = new Map();
        const unresolvedPlaceHolders = resolvePlaceHolders(drivers)[1];
        if (unresolvedPlaceHolders.length > 0) {
            return teamsfx_api_1.ok({ env: envOutput, unresolvedPlaceHolders });
        }
        for (const driver of drivers) {
            const result = await driver.instance.run(driver.with, ctx);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            for (const [envVar, value] of result.value) {
                envOutput.set(envVar, value);
                process.env[envVar] = value;
            }
        }
        return teamsfx_api_1.ok({ env: envOutput, unresolvedPlaceHolders });
    }
    stringifyDriverDef(def) {
        if (def.name) {
            return JSON.stringify({ name: def.name, uses: def.uses });
        }
        return def.uses;
    }
    resolveDriverInstances(log) {
        var _a;
        log.debug(`Trying to resolve actions for lifecycle ${this.name}`);
        const drivers = [];
        for (const def of this.driverDefs) {
            if (!typedi_1.Container.has(def.uses)) {
                return teamsfx_api_1.err(new error_1.DriverNotFoundError((_a = def.name) !== null && _a !== void 0 ? _a : "", def.uses));
            }
            const driver = typedi_1.Container.get(def.uses);
            drivers.push(Object.assign({ instance: driver }, def));
            log.debug(`Action ${this.stringifyDriverDef(def)} found for lifecycle ${this.name}`);
        }
        return teamsfx_api_1.ok(drivers);
    }
}
exports.Lifecycle = Lifecycle;
//# sourceMappingURL=lifecycle.js.map