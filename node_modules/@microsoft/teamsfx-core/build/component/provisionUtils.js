"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionUtils = exports.handleConfigFilesWhenSwitchAccount = exports.hasBotServiceCreated = exports.parseUserName = exports.parseTeamsAppTenantId = exports.checkWhetherLocalDebugM365TenantMatches = exports.findSubscriptionFromList = exports.getTeamsAppTenantId = exports.getSubscriptionId = exports.ProvisionUtils = void 0;
const tslib_1 = require("tslib");
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const uuid_1 = require("uuid");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const telemetry_1 = require("../common/telemetry");
const tools_1 = require("../common/tools");
const utils_1 = require("../common/utils");
const globalVars_1 = require("../core/globalVars");
const constants_2 = require("./constants");
const backupFiles_1 = require("./utils/backupFiles");
const ResourceGroupHelper_1 = require("./utils/ResourceGroupHelper");
const appSettingUtils_1 = require("./code/appSettingUtils");
const constants_3 = require("./resource/appManifest/constants");
const utils_2 = require("./utils");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const arm_1 = require("./arm");
const path_1 = tslib_1.__importDefault(require("path"));
const hostingConstant_1 = require("../common/azure-hosting/hostingConstant");
class ProvisionUtils {
    async preProvision(context, inputs) {
        const ctx = context;
        const envInfo = ctx.envInfo;
        const hasBotServiceCreatedBefore = hasBotServiceCreated(envInfo);
        // 1. check M365 tenant
        envInfo.state[constants_2.ComponentNames.AppManifest] = envInfo.state[constants_2.ComponentNames.AppManifest] || {};
        envInfo.state.solution = envInfo.state.solution || {};
        const appManifest = envInfo.state[constants_2.ComponentNames.AppManifest];
        const solutionConfig = envInfo.state.solution;
        solutionConfig.provisionSucceeded = false;
        const tenantIdInConfig = appManifest.tenantId;
        const isLocalDebug = envInfo.envName === "local";
        const tenantInfoInTokenRes = await this.getM365TenantId(ctx.tokenProvider.m365TokenProvider);
        if (tenantInfoInTokenRes.isErr()) {
            addShouldSkipWriteEnvInfo(tenantInfoInTokenRes.error);
            return teamsfx_api_1.err(tenantInfoInTokenRes.error);
        }
        const tenantIdInToken = tenantInfoInTokenRes.value.tenantIdInToken;
        const hasSwitchedM365Tenant = !!tenantIdInConfig && !!tenantIdInToken && tenantIdInToken !== tenantIdInConfig;
        if (!isLocalDebug) {
            if (hasSwitchedM365Tenant) {
                utils_2.resetEnvInfoWhenSwitchM365(envInfo);
            }
        }
        else {
            const res = await checkWhetherLocalDebugM365TenantMatches(envInfo, ctx, utils_2.isCSharpProject(ctx.projectSetting.programmingLanguage), tenantIdInConfig, ctx.tokenProvider.m365TokenProvider, inputs);
            if (res.isErr()) {
                addShouldSkipWriteEnvInfo(res.error);
                return teamsfx_api_1.err(res.error);
            }
        }
        envInfo.state[constants_2.ComponentNames.AppManifest] = envInfo.state[constants_2.ComponentNames.AppManifest] || {};
        envInfo.state[constants_2.ComponentNames.AppManifest].tenantId = tenantIdInToken;
        envInfo.state.solution.teamsAppTenantId = tenantIdInToken;
        globalVars_1.globalVars.m365TenantId = tenantIdInToken;
        // 3. check Azure configs
        if (projectSettingsHelperV3_1.hasAzureResourceV3(ctx.projectSetting) && envInfo.envName !== "local") {
            // ask common question and fill in solution config
            const subscriptionIdInState = envInfo.state.solution.subscriptionId;
            const solutionConfigRes = await this.fillInAzureConfigs(ctx, inputs, envInfo, ctx.tokenProvider);
            if (solutionConfigRes.isErr()) {
                addShouldSkipWriteEnvInfo(solutionConfigRes.error);
                return teamsfx_api_1.err(solutionConfigRes.error);
            }
            const consentResult = await this.askForProvisionConsent(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, tenantInfoInTokenRes.value.tenantUserName, true, tenantIdInConfig, subscriptionIdInState);
            if (consentResult.isErr()) {
                addShouldSkipWriteEnvInfo(consentResult.error);
                return teamsfx_api_1.err(consentResult.error);
            }
            if (solutionConfigRes.value.hasSwitchedSubscription || hasSwitchedM365Tenant) {
                const handleConfigFilesWhenSwitchAccountsRes = await handleConfigFilesWhenSwitchAccount(envInfo, ctx, inputs, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, hasBotServiceCreatedBefore, utils_2.isCSharpProject(ctx.projectSetting.programmingLanguage));
                if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                    addShouldSkipWriteEnvInfo(handleConfigFilesWhenSwitchAccountsRes.error);
                    return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
                }
            }
            // create resource group if needed
            if (solutionConfig.needCreateResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(solutionConfig.resourceGroupName, ctx.tokenProvider.azureAccountProvider, solutionConfig.subscriptionId, solutionConfig.location);
                if (createRgRes.isErr()) {
                    return teamsfx_api_1.err(createRgRes.error);
                }
            }
        }
        else if (hasSwitchedM365Tenant && !isLocalDebug) {
            const consentResult = await this.askForProvisionConsent(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, false, tenantInfoInTokenRes.value.tenantUserName, false, tenantIdInConfig);
            if (consentResult.isErr()) {
                addShouldSkipWriteEnvInfo(consentResult.error);
                return teamsfx_api_1.err(consentResult.error);
            }
            const handleConfigFilesWhenSwitchAccountsRes = await handleConfigFilesWhenSwitchAccount(envInfo, ctx, inputs, hasSwitchedM365Tenant, false, false, utils_2.isCSharpProject(ctx.projectSetting.programmingLanguage));
            if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                addShouldSkipWriteEnvInfo(handleConfigFilesWhenSwitchAccountsRes.error);
                return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * make sure subscription is correct before provision for V3
     * subscriptionId is provided from .env.xxx file
     */
    async ensureSubscription(azureAccountProvider, givenSubscriptionId) {
        globalVars_1.TOOLS.logProvider.info("check whether azure account is signed in.");
        // make sure the user is logged in
        await azureAccountProvider.getIdentityCredentialAsync(true);
        if (!givenSubscriptionId) {
            globalVars_1.TOOLS.logProvider.info("subscription is not selected, try to select.");
            try {
                const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
                if (!subscriptionInAccount) {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.CoordinatorSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.failToSelect")));
                }
                else {
                    globalVars_1.TOOLS.logProvider.info(`successful to select subscription: ${subscriptionInAccount.subscriptionId}`);
                    return teamsfx_api_1.ok(subscriptionInAccount);
                }
            }
            catch (e) {
                return teamsfx_api_1.err(teamsfx_api_1.assembleError(e));
            }
        }
        // verify valid subscription (permission)
        globalVars_1.TOOLS.logProvider.info("subscription is given, try to validate");
        const subscriptions = await azureAccountProvider.listSubscriptions();
        const foundSubscriptionInfo = findSubscriptionFromList(givenSubscriptionId, subscriptions);
        if (!foundSubscriptionInfo) {
            globalVars_1.TOOLS.logProvider.info("subscription validate fail");
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.CoordinatorSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.NotFound", givenSubscriptionId)));
        }
        globalVars_1.TOOLS.logProvider.info("subscription validate success");
        return teamsfx_api_1.ok(foundSubscriptionInfo);
    }
    /**
     * make sure subscription is correct before provision
     *
     */
    async checkProvisionSubscription(ctx, envInfo, azureAccountProvider, targetSubscriptionIdFromCLI, envName, isResourceGroupOnlyFromCLI) {
        var _a, _b, _c, _d;
        const subscriptionIdInConfig = (_a = envInfo.config.azure) === null || _a === void 0 ? void 0 : _a.subscriptionId;
        const subscriptionNameInConfig = ((_b = envInfo.config.azure) === null || _b === void 0 ? void 0 : _b.subscriptionName) || subscriptionIdInConfig;
        const subscriptionIdInState = envInfo.state.solution.subscriptionId;
        const subscriptionNameInState = envInfo.state.solution.subscriptionName || subscriptionIdInState;
        (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscriptionStart, envName ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(envName) } : {});
        if (!subscriptionIdInState && !subscriptionIdInConfig && !targetSubscriptionIdFromCLI) {
            const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
            if (!subscriptionInAccount) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.failToSelect")));
            }
            else {
                this.updateEnvInfoSubscription(envInfo, subscriptionInAccount);
                ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                (_d = ctx.telemetryReporter) === null || _d === void 0 ? void 0 : _d.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscription, {
                    [telemetry_1.TelemetryProperty.Env]: !envName ? "" : tools_1.getHashedEnv(envName),
                    [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: "false",
                    [telemetry_1.TelemetryProperty.CustomizeSubscriptionType]: telemetry_1.CustomizeSubscriptionType.Default,
                });
                return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
            }
        }
        // make sure the user is logged in
        await azureAccountProvider.getIdentityCredentialAsync(true);
        // verify valid subscription (permission)
        const subscriptions = await azureAccountProvider.listSubscriptions();
        if (targetSubscriptionIdFromCLI) {
            const targetSubscriptionInfo = findSubscriptionFromList(targetSubscriptionIdFromCLI, subscriptions);
            if (!targetSubscriptionInfo) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.NotFoundParam", targetSubscriptionIdFromCLI, envInfo.envName)));
            }
            else {
                this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
                ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                return this.compareWithStateSubscription(ctx, envInfo, targetSubscriptionInfo, subscriptionIdInState, envName, telemetry_1.CustomizeSubscriptionType.CommandLine);
            }
        }
        if (subscriptionIdInConfig && !isResourceGroupOnlyFromCLI) {
            const targetConfigSubInfo = findSubscriptionFromList(subscriptionIdInConfig, subscriptions);
            if (!targetConfigSubInfo) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.NotFoundConfig", subscriptionIdInConfig, envInfo.envName, teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName))));
            }
            else {
                return this.compareWithStateSubscription(ctx, envInfo, targetConfigSubInfo, subscriptionIdInState, envName, telemetry_1.CustomizeSubscriptionType.EnvConfig);
            }
        }
        else {
            const targetStateSubInfo = subscriptions.find((item) => item.subscriptionId === subscriptionIdInState);
            const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
            if (!subscriptionInAccount) {
                if (targetStateSubInfo) {
                    this.updateEnvInfoSubscription(envInfo, targetStateSubInfo);
                    ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                    return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
                }
                else {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, localizeUtils_1.getLocalizedString("core.provision.subscription.NotFoundState", subscriptionIdInState, envInfo.envName)));
                }
            }
            else {
                return this.compareWithStateSubscription(ctx, envInfo, subscriptionInAccount, subscriptionIdInState, envName, telemetry_1.CustomizeSubscriptionType.EnvState);
            }
        }
    }
    updateEnvInfoSubscription(envInfo, subscriptionInfo) {
        envInfo.state.solution.subscriptionId = subscriptionInfo.subscriptionId;
        envInfo.state.solution.subscriptionName = subscriptionInfo.subscriptionName;
        envInfo.state.solution.tenantId = subscriptionInfo.tenantId;
    }
    async compareWithStateSubscription(ctx, envInfo, targetSubscriptionInfo, subscriptionInStateId, envName, customizeSubscriptionType) {
        var _a, _b;
        const hasSwitchedSubscription = !!subscriptionInStateId && targetSubscriptionInfo.subscriptionId !== subscriptionInStateId;
        if (hasSwitchedSubscription) {
            this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
            this.clearEnvInfoStateResource(envInfo);
            ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
            (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscription, {
                [telemetry_1.TelemetryProperty.Env]: !envName ? "" : tools_1.getHashedEnv(envName),
                [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: "true",
                [telemetry_1.TelemetryProperty.CustomizeSubscriptionType]: customizeSubscriptionType,
            });
            return teamsfx_api_1.ok({ hasSwitchedSubscription: true });
        }
        else {
            this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
            ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscription, {
                [telemetry_1.TelemetryProperty.Env]: !envName ? "" : tools_1.getHashedEnv(envName),
                [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: "false",
                [telemetry_1.TelemetryProperty.CustomizeSubscriptionType]: customizeSubscriptionType,
            });
            return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
        }
    }
    // clear resources related info in envInfo so that we could provision successfully using new sub.
    clearEnvInfoStateResource(envInfo) {
        envInfo.state.solution.resourceGroupName = "";
        envInfo.state.solution.resourceNameSuffix = "";
        const keysToClear = [
            constants_2.BuiltInFeaturePluginNames.bot,
            constants_2.BuiltInFeaturePluginNames.frontend,
            constants_2.BuiltInFeaturePluginNames.function,
            constants_2.BuiltInFeaturePluginNames.identity,
            constants_2.BuiltInFeaturePluginNames.keyVault,
            constants_2.BuiltInFeaturePluginNames.sql,
            constants_2.BuiltInFeaturePluginNames.simpleAuth,
            constants_2.ComponentNames.TeamsBot,
            constants_2.ComponentNames.TeamsTab,
            constants_2.ComponentNames.TeamsApi,
            constants_2.ComponentNames.Identity,
            constants_2.ComponentNames.KeyVault,
            constants_2.ComponentNames.AzureSQL,
        ];
        const keysToModify = [constants_2.BuiltInFeaturePluginNames.apim, constants_2.ComponentNames.APIM];
        const keys = Object.keys(envInfo.state);
        for (const key of keys) {
            if (keysToClear.includes(key)) {
                delete envInfo.state[key];
            }
            if (keysToModify.includes(key)) {
                delete envInfo.state[key]["serviceResourceId"];
            }
        }
    }
    async ensureResourceGroup(azureAccountProvider, subscriptionId, givenResourceGroupName, defaultResourceGroupName) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (azureToken === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.CoordinatorSource, constants_2.SolutionError.NotLoginToAzure, localizeUtils_1.getLocalizedString("core.error.notLoginToAzure")));
        }
        await azureAccountProvider.setSubscription(subscriptionId);
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
        let resourceGroupInfo;
        if (givenResourceGroupName) {
            const getResourceGroupRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(givenResourceGroupName, rmClient);
            if (getResourceGroupRes.isErr()) {
                return teamsfx_api_1.err(getResourceGroupRes.error);
            }
            else {
                if (!getResourceGroupRes.value) {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, localizeUtils_1.getLocalizedString("core.error.resourceGroupNotFound", givenResourceGroupName)));
                }
                else {
                    resourceGroupInfo = getResourceGroupRes.value;
                }
            }
        }
        else {
            const defaultRG = defaultResourceGroupName || "teams-app-rg";
            const rgRes = await ResourceGroupHelper_1.resourceGroupHelper.askResourceGroupInfoV3(azureAccountProvider, rmClient, defaultRG);
            if (rgRes.isErr())
                return teamsfx_api_1.err(rgRes.error);
            resourceGroupInfo = rgRes.value;
        }
        return teamsfx_api_1.ok(resourceGroupInfo);
    }
    /**
     * Asks common questions and puts the answers in the global namespace of SolutionConfig
     *
     */
    async fillInAzureConfigs(ctx, inputs, envInfo, tokenProvider) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        //1. check subscriptionId
        const targetSubscriptionIdFromCLI = inputs.targetSubscriptionId;
        const subscriptionResult = await this.checkProvisionSubscription(ctx, envInfo, tokenProvider.azureAccountProvider, targetSubscriptionIdFromCLI, inputs.env, !!inputs.targetResourceGroupName &&
            !targetSubscriptionIdFromCLI &&
            inputs.platform === teamsfx_api_1.Platform.CLI);
        if (subscriptionResult.isErr()) {
            return teamsfx_api_1.err(subscriptionResult.error);
        }
        // Note setSubscription here will change the token returned by getAccountCredentialAsync according to the subscription selected.
        // So getting azureToken needs to precede setSubscription.
        const azureToken = await tokenProvider.azureAccountProvider.getIdentityCredentialAsync();
        if (azureToken === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.NotLoginToAzure, localizeUtils_1.getLocalizedString("core.error.notLoginToAzure")));
        }
        //2. check resource group
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroupStart, inputs.env ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(inputs.env) } : {});
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, envInfo.state.solution.subscriptionId);
        // Resource group info precedence are:
        //   0. ctx.answers, for VS targetResourceGroupName and targetResourceLocationName to create a new rg
        //   1. ctx.answers, for CLI --resource-group argument, only support existing resource group
        //   2. env config (config.{envName}.json), for user customization, only support existing resource group
        //   3. states (state.{envName}.json), for re-provision
        //   4. asking user with a popup
        const resourceGroupNameFromEnvConfig = (_b = envInfo.config.azure) === null || _b === void 0 ? void 0 : _b.resourceGroupName;
        const resourceGroupNameFromState = envInfo.state.solution.resourceGroupName;
        const resourceGroupLocationFromState = envInfo.state.solution.location;
        const appName = utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName);
        const defaultResourceGroupName = `${appName.replace(" ", "_")}${"-" + envInfo.envName}-rg`;
        let resourceGroupInfo;
        const telemetryProperties = {};
        if (inputs.env) {
            telemetryProperties[telemetry_1.TelemetryProperty.Env] = tools_1.getHashedEnv(inputs.env);
        }
        if (inputs.targetResourceGroupName) {
            const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(inputs.targetResourceGroupName, rmClient);
            if (getRes.isErr()) {
                // support vs to create a new resource group
                if (inputs.platform === teamsfx_api_1.Platform.VS && inputs.targetResourceLocationName) {
                    resourceGroupInfo = {
                        createNewResourceGroup: true,
                        name: inputs.targetResourceGroupName,
                        location: inputs.targetResourceLocationName,
                    };
                }
                else
                    return teamsfx_api_1.err(getRes.error);
            }
            else {
                if (!getRes.value) {
                    // Currently we do not support creating resource group from command line arguments
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, localizeUtils_1.getLocalizedString("core.error.resourceGroupNotFound", inputs.targetResourceGroupName)));
                }
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.CommandLine;
                resourceGroupInfo = getRes.value;
            }
        }
        else if (resourceGroupNameFromEnvConfig && !targetSubscriptionIdFromCLI) {
            const resourceGroupName = resourceGroupNameFromEnvConfig;
            const envFile = teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName);
            if (!((_c = envInfo.config.azure) === null || _c === void 0 ? void 0 : _c.subscriptionId)) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.MissingSubscriptionIdInConfig, localizeUtils_1.getDefaultString("error.MissingSubscriptionInConfig", resourceGroupName, envFile), localizeUtils_1.getLocalizedString("error.MissingSubscriptionInConfig", resourceGroupName, envFile)));
            }
            const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(resourceGroupName, rmClient);
            if (getRes.isErr())
                return teamsfx_api_1.err(getRes.error);
            if (!getRes.value) {
                // Currently we do not support creating resource group by input config, so just throw an error.
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, localizeUtils_1.getLocalizedString("core.error.resourceGroupNotFound2", resourceGroupName, envFile)));
            }
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.EnvConfig;
            resourceGroupInfo = getRes.value;
        }
        else if (resourceGroupNameFromState &&
            resourceGroupLocationFromState &&
            !targetSubscriptionIdFromCLI) {
            const checkRes = await ResourceGroupHelper_1.resourceGroupHelper.checkResourceGroupExistence(resourceGroupNameFromState, rmClient);
            if (checkRes.isErr()) {
                return teamsfx_api_1.err(checkRes.error);
            }
            const exist = checkRes.value;
            resourceGroupInfo = {
                createNewResourceGroup: !exist,
                name: resourceGroupNameFromState,
                location: resourceGroupLocationFromState,
            };
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.EnvState;
        }
        else {
            const resourceGroupInfoResult = await ResourceGroupHelper_1.resourceGroupHelper.askResourceGroupInfo(ctx, inputs, tokenProvider.azureAccountProvider, rmClient, defaultResourceGroupName);
            if (resourceGroupInfoResult.isErr()) {
                return teamsfx_api_1.err(resourceGroupInfoResult.error);
            }
            resourceGroupInfo = resourceGroupInfoResult.value;
            if (resourceGroupInfo.createNewResourceGroup) {
                if (resourceGroupInfo.name === defaultResourceGroupName) {
                    telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                        telemetry_1.CustomizeResourceGroupType.InteractiveCreateDefault;
                }
                else {
                    telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                        telemetry_1.CustomizeResourceGroupType.InteractiveCreateCustomized;
                }
            }
            else {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveUseExisting;
            }
        }
        (_d = ctx.telemetryReporter) === null || _d === void 0 ? void 0 : _d.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroup, telemetryProperties);
        envInfo.state.solution.needCreateResourceGroup = resourceGroupInfo.createNewResourceGroup;
        envInfo.state.solution.resourceGroupName = resourceGroupInfo.name;
        envInfo.state.solution.location = resourceGroupInfo.location;
        (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(`[${constants_1.PluginDisplayName.Solution}] check resource group pass!`);
        (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.info(`[${constants_1.PluginDisplayName.Solution}] check teamsAppTenantId pass!`);
        //resourceNameSuffix
        const resourceNameSuffix = ((_g = envInfo.config.azure) === null || _g === void 0 ? void 0 : _g.resourceNameSuffix) ||
            envInfo.state.solution.resourceNameSuffix ||
            uuid_1.v4().substr(0, 6);
        envInfo.state.solution.resourceNameSuffix = resourceNameSuffix;
        (_h = ctx.logProvider) === null || _h === void 0 ? void 0 : _h.info(`[${constants_1.PluginDisplayName.Solution}] check resourceNameSuffix pass!`);
        return teamsfx_api_1.ok({ hasSwitchedSubscription: subscriptionResult.value.hasSwitchedSubscription });
    }
    async getM365TenantId(m365TokenProvider) {
        // Just to trigger M365 login before the concurrent execution of localDebug.
        // Because concurrent execution of localDebug may getAccessToken() concurrently, which
        // causes 2 M365 logins before the token caching in common lib takes effect.
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: constants_3.AppStudioScopes });
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioTokenJsonRes = await m365TokenProvider.getJsonObject({
            scopes: constants_3.AppStudioScopes,
        });
        const appStudioTokenJson = appStudioTokenJsonRes.isOk()
            ? appStudioTokenJsonRes.value
            : undefined;
        if (appStudioTokenJson === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoAppStudioToken, localizeUtils_1.getDefaultString("error.NoAppStudioToken"), localizeUtils_1.getLocalizedString("error.NoAppStudioToken")));
        }
        const tenantIdInToken = appStudioTokenJson.tid;
        const tenantUserName = appStudioTokenJson.upn;
        if (!tenantIdInToken || !(typeof tenantIdInToken === "string")) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
        }
        return teamsfx_api_1.ok({ tenantIdInToken, tenantUserName });
    }
    async askForProvisionConsentV3(ctx, m365tenant, azureSubInfo, envName) {
        var _a, _b, _c;
        const azureTokenJson = await ctx.azureAccountProvider.getJsonObject();
        const username = azureTokenJson.unique_name || "";
        const azureAccountInfo = localizeUtils_1.getLocalizedString("core.provision.azureAccount", username);
        const azureSubscriptionInfo = localizeUtils_1.getLocalizedString("core.provision.azureSubscription", azureSubInfo.subscriptionName);
        const accountsInfo = [azureAccountInfo, azureSubscriptionInfo];
        if (m365tenant) {
            const m365AccountInfo = localizeUtils_1.getLocalizedString("core.provision.m365Account", m365tenant === null || m365tenant === void 0 ? void 0 : m365tenant.tenantUserName);
            accountsInfo.push(m365AccountInfo);
        }
        const confirmMsg = localizeUtils_1.getLocalizedString("core.provision.confirmEnvAndCostNotice", envName);
        const provisionText = localizeUtils_1.getLocalizedString("core.provision.provision");
        const confirmRes = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", accountsInfo.join("\n") + "\n\n" + confirmMsg, true, provisionText));
        const confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
        (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.ConfirmProvision, envName
            ? {
                [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(envName),
                [constants_2.SolutionTelemetryProperty.SubscriptionId]: azureSubInfo.subscriptionId,
                [constants_2.SolutionTelemetryProperty.M365TenantId]: (_c = m365tenant === null || m365tenant === void 0 ? void 0 : m365tenant.tenantIdInToken) !== null && _c !== void 0 ? _c : "",
                [constants_2.SolutionTelemetryProperty.ConfirmRes]: !confirm ? "Cancel" : "Provision",
            }
            : {});
        if (confirm !== provisionText) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError("coordinator", "CancelProvision", "CancelProvision"));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async ensureM365TenantMatchesV3(actions, tenantId, env, source) {
        if (actions.length === 0 || !tenantId) {
            return teamsfx_api_1.ok(undefined);
        }
        const hasSwitched = !!process.env.TEAMS_APP_TENANT_ID && process.env.TEAMS_APP_TENANT_ID !== tenantId;
        const keysNeedToUpdate = ["TEAMS_APP_TENANT_ID"];
        if (actions.includes("aadApp/create")) {
            if (process.env.AAD_APP_CLIENT_ID) {
                keysNeedToUpdate.push("AAD_APP_CLIENT_ID");
            }
        }
        if (actions.includes("botAadApp/create") || actions.includes("botFramework/create")) {
            if (process.env.BOT_ID) {
                keysNeedToUpdate.push("BOT_ID");
            }
        }
        const msg = localizeUtils_1.getLocalizedString("error.m365tenantcheck.tenantNotMatch", keysNeedToUpdate.join(", "), env, constants_1.HelpLinks.SwitchTenant);
        const error = new teamsfx_api_1.UserError(source, "M365TenantNotMatch", msg, msg);
        error.helpLink = constants_1.HelpLinks.SwitchTenant;
        return !hasSwitched ? teamsfx_api_1.ok(undefined) : teamsfx_api_1.err(error);
    }
    async askForProvisionConsent(ctx, azureAccountProvider, envInfo, hasSwitchedM365Tenant, hasSwitchedSubscription, m365AccountName, hasAzureResource, previousM365TenantId, previousSubscriptionId) {
        var _a, _b, _c, _d, _e;
        const azureTokenJson = await azureAccountProvider.getJsonObject();
        const username = azureTokenJson.unique_name || "";
        const subscriptionId = ((_a = envInfo.state.solution) === null || _a === void 0 ? void 0 : _a.subscriptionId) || "";
        const subscriptionName = ((_b = envInfo.state.solution) === null || _b === void 0 ? void 0 : _b.subscriptionName) || "";
        const m365TenantId = ((_c = envInfo.state.solution) === null || _c === void 0 ? void 0 : _c.teamsAppTenantId) || "";
        let switchedNotice = "";
        if (hasSwitchedM365Tenant && hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedM365AccountAndAzureSubscriptionNotice");
        }
        else if (hasSwitchedM365Tenant && !hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedM365AccountNotice");
        }
        else if (!hasSwitchedM365Tenant && hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedAzureSubscriptionNotice");
            const botResource = (_d = envInfo.state[constants_2.BuiltInFeaturePluginNames.bot]) !== null && _d !== void 0 ? _d : envInfo.state[constants_2.ComponentNames.TeamsBot];
            const newBotNotice = !!botResource && !!botResource["resourceId"]
                ? localizeUtils_1.getLocalizedString("core.provision.createNewAzureBotNotice")
                : "";
            switchedNotice = switchedNotice + newBotNotice;
        }
        const azureAccountInfo = localizeUtils_1.getLocalizedString("core.provision.azureAccount", username);
        const azureSubscriptionInfo = localizeUtils_1.getLocalizedString("core.provision.azureSubscription", subscriptionName ? subscriptionName : subscriptionId);
        const m365AccountInfo = localizeUtils_1.getLocalizedString("core.provision.m365Account", m365AccountName ? m365AccountName : m365TenantId);
        let accountsInfo = "";
        if (!switchedNotice && !hasAzureResource) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else if (!switchedNotice && hasAzureResource) {
            accountsInfo = [azureAccountInfo, azureSubscriptionInfo, m365AccountInfo].join("\n");
        }
        else {
            // switchedNotice
            accountsInfo = hasAzureResource
                ? [switchedNotice, azureAccountInfo, azureSubscriptionInfo, m365AccountInfo].join("\n")
                : [switchedNotice, m365AccountInfo].join("\n");
        }
        const confirmMsg = hasAzureResource
            ? localizeUtils_1.getLocalizedString("core.provision.confirmEnvAndCostNotice", envInfo.envName)
            : hasSwitchedM365Tenant
                ? localizeUtils_1.getLocalizedString("core.provision.confirmEnvOnlyNotice", envInfo.envName)
                : "";
        const provisionText = localizeUtils_1.getLocalizedString("core.provision.provision");
        const learnMoreText = localizeUtils_1.getLocalizedString("core.provision.learnMore");
        const items = hasSwitchedM365Tenant || hasSwitchedSubscription
            ? [provisionText, learnMoreText]
            : [provisionText];
        let confirm;
        do {
            const confirmRes = await ctx.userInteraction.showMessage("warn", accountsInfo + "\n\n" + confirmMsg, true, ...items);
            confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
            (_e = ctx.telemetryReporter) === null || _e === void 0 ? void 0 : _e.sendTelemetryEvent(telemetry_1.TelemetryEvent.ConfirmProvision, envInfo.envName
                ? {
                    [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(envInfo.envName),
                    [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: hasSwitchedM365Tenant.toString(),
                    [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: hasSwitchedSubscription.toString(),
                    [constants_2.SolutionTelemetryProperty.SubscriptionId]: getSubscriptionId(envInfo.state),
                    [constants_2.SolutionTelemetryProperty.M365TenantId]: getTeamsAppTenantId(envInfo.state),
                    [constants_2.SolutionTelemetryProperty.PreviousM365TenantId]: previousM365TenantId,
                    [constants_2.SolutionTelemetryProperty.PreviousSubsriptionId]: previousSubscriptionId !== null && previousSubscriptionId !== void 0 ? previousSubscriptionId : "",
                    [constants_2.SolutionTelemetryProperty.ConfirmRes]: !confirm
                        ? "Error"
                        : confirm === learnMoreText
                            ? "Learn more"
                            : confirm === provisionText
                                ? "Provision"
                                : "",
                }
                : {});
            if (confirm !== provisionText) {
                if (confirm === learnMoreText) {
                    ctx.userInteraction.openUrl("https://aka.ms/teamsfx-switch-tenant-or-subscription-help");
                }
                else {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "CancelProvision", "CancelProvision"));
                }
            }
        } while (confirm === learnMoreText);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
exports.ProvisionUtils = ProvisionUtils;
function getSubscriptionId(state) {
    if (state && state[constants_2.GLOBAL_CONFIG] && state[constants_2.GLOBAL_CONFIG][constants_2.SUBSCRIPTION_ID]) {
        return state[constants_2.GLOBAL_CONFIG][constants_2.SUBSCRIPTION_ID];
    }
    return "";
}
exports.getSubscriptionId = getSubscriptionId;
function getTeamsAppTenantId(state) {
    if (state && state[constants_2.GLOBAL_CONFIG] && state[constants_2.GLOBAL_CONFIG][constants_2.REMOTE_TEAMS_APP_TENANT_ID]) {
        return state[constants_2.GLOBAL_CONFIG][constants_2.REMOTE_TEAMS_APP_TENANT_ID];
    }
    return "";
}
exports.getTeamsAppTenantId = getTeamsAppTenantId;
function findSubscriptionFromList(subscriptionId, subscriptions) {
    return subscriptions.find((item) => item.subscriptionId === subscriptionId);
}
exports.findSubscriptionFromList = findSubscriptionFromList;
function addShouldSkipWriteEnvInfo(error) {
    if (!error.userData) {
        error.userData = { shouldSkipWriteEnvInfo: true };
    }
}
async function checkWhetherLocalDebugM365TenantMatches(envInfo, ctx, isCSharpProject, localDebugTenantId, m365TokenProvider, inputs) {
    var _a, _b;
    if (localDebugTenantId) {
        const projectPath = inputs.projectPath;
        const appStudioTokenJsonRes = await m365TokenProvider.getJsonObject({
            scopes: constants_3.AppStudioScopes,
        });
        const appStudioTokenJson = (appStudioTokenJsonRes === null || appStudioTokenJsonRes === void 0 ? void 0 : appStudioTokenJsonRes.isOk())
            ? appStudioTokenJsonRes.value
            : undefined;
        const maybeM365TenantId = parseTeamsAppTenantId(appStudioTokenJson);
        if (maybeM365TenantId.isErr()) {
            return maybeM365TenantId;
        }
        const maybeM365UserAccount = parseUserName(appStudioTokenJson);
        if (maybeM365UserAccount.isErr()) {
            return maybeM365UserAccount;
        }
        if (maybeM365TenantId.value !== localDebugTenantId) {
            if (projectPath !== undefined &&
                (await fs_extra_1.default.pathExists(`${projectPath}/bot/.notification.localstore.json`))) {
                const errorMessage = localizeUtils_1.getLocalizedString("core.localDebug.tenantConfirmNoticeWhenAllowSwitchAccount", localDebugTenantId, maybeM365UserAccount.value, "bot/.notification.localstore.json");
                return teamsfx_api_1.err(new teamsfx_api_1.UserError("Solution", constants_2.SolutionError.CannotLocalDebugInDifferentTenant, errorMessage));
            }
            else if (envInfo) {
                (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckLocalDebugTenant, {
                    [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: "true",
                    [constants_2.SolutionTelemetryProperty.M365TenantId]: maybeM365TenantId.value,
                    [constants_2.SolutionTelemetryProperty.PreviousM365TenantId]: localDebugTenantId,
                });
                const keys = Object.keys(envInfo.state);
                for (const key of keys) {
                    if (key !== "solution") {
                        delete envInfo.state[key];
                    }
                }
                if (projectPath !== undefined) {
                    const backupFilesRes = await backupFiles_1.backupFiles(envInfo.envName, projectPath, isCSharpProject, (inputs === null || inputs === void 0 ? void 0 : inputs.platform) === teamsfx_api_1.Platform.VS, ctx);
                    if (backupFilesRes.isErr()) {
                        return teamsfx_api_1.err(backupFilesRes.error);
                    }
                    if (isCSharpProject) {
                        await appSettingUtils_1.resetAppSettingsDevelopment(projectPath);
                    }
                }
            }
        }
        else {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckLocalDebugTenant, {
                [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: "false",
                [constants_2.SolutionTelemetryProperty.M365TenantId]: maybeM365TenantId.value,
                [constants_2.SolutionTelemetryProperty.PreviousM365TenantId]: localDebugTenantId,
            });
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.checkWhetherLocalDebugM365TenantMatches = checkWhetherLocalDebugM365TenantMatches;
function parseTeamsAppTenantId(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoAppStudioToken, "Graph token json is undefined"));
    }
    const teamsAppTenantId = appStudioToken["tid"];
    if (teamsAppTenantId === undefined ||
        !(typeof teamsAppTenantId === "string") ||
        teamsAppTenantId.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
    }
    return teamsfx_api_1.ok(teamsAppTenantId);
}
exports.parseTeamsAppTenantId = parseTeamsAppTenantId;
function parseUserName(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", constants_2.SolutionError.NoAppStudioToken, "Graph token json is undefined"));
    }
    const userName = appStudioToken["upn"];
    if (userName === undefined || !(typeof userName === "string") || userName.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", constants_2.SolutionError.NoUserName, "Cannot find user name from App Studio token."));
    }
    return teamsfx_api_1.ok(userName);
}
exports.parseUserName = parseUserName;
function hasBotServiceCreated(envInfo) {
    if (!envInfo || !envInfo.state) {
        return false;
    }
    return ((!!envInfo.state[constants_2.BuiltInFeaturePluginNames.bot] &&
        !!envInfo.state[constants_2.BuiltInFeaturePluginNames.bot]["resourceId"]) ||
        (!!envInfo.state[constants_2.ComponentNames.TeamsBot] &&
            !!envInfo.state[constants_2.ComponentNames.TeamsBot]["resourceId"]));
}
exports.hasBotServiceCreated = hasBotServiceCreated;
async function handleConfigFilesWhenSwitchAccount(envInfo, context, inputs, hasSwitchedM365Tenant, hasSwitchedSubscription, hasBotServiceCreatedBefore, isCSharpProject) {
    var _a, _b;
    if (!hasSwitchedM365Tenant && !hasSwitchedSubscription) {
        return teamsfx_api_1.ok(undefined);
    }
    const backupFilesRes = await backupFiles_1.backupFiles(envInfo.envName, inputs.projectPath, isCSharpProject, inputs.platform === teamsfx_api_1.Platform.VS, context);
    if (backupFilesRes.isErr()) {
        return teamsfx_api_1.err(backupFilesRes.error);
    }
    const updateAzureParametersRes = await arm_1.updateAzureParameters(inputs.projectPath, context.projectSetting.appName, envInfo.envName, hasSwitchedM365Tenant, hasSwitchedSubscription, hasBotServiceCreatedBefore);
    if (updateAzureParametersRes.isErr()) {
        return teamsfx_api_1.err(updateAzureParametersRes.error);
    }
    if (hasSwitchedSubscription) {
        const envName = envInfo.envName;
        const maybeBotFolder = path_1.default.join(inputs.projectPath, constants_2.PathConstants.botWorkingDir);
        const maybeBotDeploymentFile = path_1.default.join(maybeBotFolder, path_1.default.join(hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_FOLDER, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_INFO_FILE));
        if (await fs_extra_1.default.pathExists(maybeBotDeploymentFile)) {
            try {
                const botDeployJson = await fs_extra_1.default.readJSON(maybeBotDeploymentFile);
                const lastTime = Math.max((_b = (_a = botDeployJson[envInfo.envName]) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : 0, 0);
                if (lastTime !== 0) {
                    botDeployJson[envName] = {
                        time: 0,
                    };
                    await fs_extra_1.default.writeJSON(maybeBotDeploymentFile, botDeployJson);
                }
            }
            catch (exception) {
                // do nothing
            }
        }
        const maybeTabFolder = path_1.default.join(inputs.projectPath, constants_2.PathConstants.tabWorkingDir);
        const maybeTabDeploymentFile = path_1.default.join(maybeTabFolder, path_1.default.join(hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_FOLDER, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_INFO_FILE));
        if (await fs_extra_1.default.pathExists(maybeTabDeploymentFile)) {
            try {
                const deploymentInfoJson = await fs_extra_1.default.readJSON(maybeTabDeploymentFile);
                if (!!deploymentInfoJson[envName] && !!deploymentInfoJson[envName].lastDeployTime) {
                    delete deploymentInfoJson[envName].lastDeployTime;
                    await fs_extra_1.default.writeJSON(maybeTabDeploymentFile, deploymentInfoJson);
                }
            }
            catch (exception) {
                // do nothing
            }
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.handleConfigFilesWhenSwitchAccount = handleConfigFilesWhenSwitchAccount;
exports.provisionUtils = new ProvisionUtils();
//# sourceMappingURL=provisionUtils.js.map