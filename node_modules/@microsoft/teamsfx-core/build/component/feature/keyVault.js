"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyVaultFeature = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const utils_1 = require("../../common/utils");
const constants_1 = require("../constants");
require("../connection/azureWebAppConfig");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
require("../resource/azureSql");
require("../resource/identity");
const utils_2 = require("../utils");
const workflow_1 = require("../workflow");
let KeyVaultFeature = class KeyVaultFeature {
    constructor() {
        this.name = "key-vault-feature";
    }
    /**
     * 1. config keyVault
     * 2. add keyVault provision bicep
     * 3. re-generate resources that connect to key-vault
     * 4. persist bicep
     */
    async add(context, inputs) {
        const projectSettings = context.projectSetting;
        const keyVaultComponent = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.KeyVault);
        if (keyVaultComponent)
            return teamsfx_api_1.ok(undefined);
        const effects = [];
        // config
        projectSettings.components.push({
            name: constants_2.ComponentNames.KeyVault,
            connections: [constants_2.ComponentNames.Identity],
            provision: true,
        });
        effects.push(messages_1.Plans.addFeature("key-vault"));
        // bicep.init
        {
            const bicepComponent = typedi_1.Container.get("bicep");
            const res = await bicepComponent.init(inputs.projectPath);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // key-vault provision bicep
        {
            const keyVaultComponent = typedi_1.Container.get(constants_2.ComponentNames.KeyVault);
            const res = await keyVaultComponent.generateBicep(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate key-vault provision bicep");
            const persistRes = await utils_2.bicepUtils.persistBiceps(inputs.projectPath, utils_1.convertToAlphanumericOnly(context.projectSetting.appName), res.value);
            if (persistRes.isErr())
                return persistRes;
        }
        // generate config bicep
        {
            const res = await utils_2.generateConfigBiceps(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("update config biceps");
        }
        utils_2.addFeatureNotify(inputs, context.userInteraction, "Resource", [constants_1.AzureResourceKeyVault.id]);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: "kv",
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-key-vault",
            telemetryEventName: "generate-arm-templates",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], KeyVaultFeature.prototype, "add", null);
KeyVaultFeature = tslib_1.__decorate([
    typedi_1.Service("key-vault-feature")
], KeyVaultFeature);
exports.KeyVaultFeature = KeyVaultFeature;
//# sourceMappingURL=keyVault.js.map