"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsApi = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = tslib_1.__importStar(require("typedi"));
const projectSettingsHelper_1 = require("../../../common/projectSettingsHelper");
const telemetry_1 = require("../../../common/telemetry");
const utils_1 = require("../../../common/utils");
const globalVars_1 = require("../../../core/globalVars");
const question_1 = require("../../../core/question");
const constants_1 = require("../../constants");
const enums_1 = require("../../code/api/enums");
const scaffold_1 = require("../../code/api/scaffold");
const constants_2 = require("../../constants");
const debug_1 = require("../../debug");
const messages_1 = require("../../messages");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const utils_2 = require("../../utils");
const workflow_1 = require("../../workflow");
const constants_3 = require("./constants");
const question_2 = require("./question");
let TeamsApi = class TeamsApi {
    constructor() {
        this.name = constants_2.ComponentNames.TeamsApi;
    }
    async add(context, inputs, actionContext) {
        var _a;
        const projectSettings = context.projectSetting;
        const effects = [];
        inputs[question_1.CoreQuestionNames.ProgrammingLanguage] =
            context.projectSetting.programmingLanguage ||
                inputs[question_1.CoreQuestionNames.ProgrammingLanguage] ||
                constants_2.ProgrammingLanguage.JS;
        const addedComponents = [];
        // 1. scaffold function
        {
            inputs[_a = enums_1.QuestionKey.functionName] || (inputs[_a] = constants_3.DefaultValues.functionName);
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                folder: inputs.folder || constants_2.PathConstants.apiWorkingDir,
            });
            const apiCodeComponent = typedi_1.default.get(constants_2.ComponentNames.ApiCode);
            const res = await apiCodeComponent.generate(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate api code");
        }
        const apiConfig = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.TeamsApi);
        if (apiConfig) {
            apiConfig.functionNames = apiConfig.functionNames || [];
            apiConfig.functionNames.push(inputs[enums_1.QuestionKey.functionName]);
            utils_2.addFeatureNotify(inputs, context.userInteraction, "Resource", [constants_1.AzureResourceFunction.id]);
            return teamsfx_api_1.ok(undefined);
        }
        // 2. config teams-api
        projectSettings.components.push({
            name: constants_2.ComponentNames.TeamsApi,
            hosting: constants_2.ComponentNames.Function,
            functionNames: [inputs[enums_1.QuestionKey.functionName]],
            deploy: true,
            build: true,
            folder: inputs.folder || constants_2.PathConstants.apiWorkingDir,
            artifactFolder: inputs.folder || constants_2.PathConstants.apiWorkingDir,
        });
        addedComponents.push(constants_2.ComponentNames.TeamsApi);
        effects.push("config teams-api");
        // 2.1 check sso if not added
        const tabComponent = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.TeamsTab);
        if (!(tabComponent === null || tabComponent === void 0 ? void 0 : tabComponent.sso)) {
            const ssoComponent = typedi_1.default.get(constants_2.ComponentNames.SSO);
            const res = await ssoComponent.add(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        const biceps = [];
        // 3.1 bicep.init
        {
            const bicepComponent = typedi_1.default.get("bicep");
            const res = await bicepComponent.init(inputs.projectPath);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 3.2 azure-function.generateBicep
        {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                componentId: constants_2.ComponentNames.TeamsApi,
                hosting: inputs.hosting,
                scenario: constants_2.Scenarios.Api,
            });
            const functionComponent = typedi_1.default.get(constants_2.ComponentNames.Function);
            const res = await functionComponent.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: constants_2.ComponentNames.Function,
                scenario: constants_2.Scenarios.Api,
                provision: true,
            });
            addedComponents.push(constants_2.ComponentNames.Function);
        }
        const bicepRes = await utils_2.bicepUtils.persistBiceps(inputs.projectPath, utils_1.convertToAlphanumericOnly(projectSettings.appName), biceps);
        if (bicepRes.isErr())
            return bicepRes;
        // 4. generate config bicep
        {
            const res = await utils_2.generateConfigBiceps(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate config biceps");
        }
        // 5. local debug settings
        {
            const res = await debug_1.generateLocalDebugSettings(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate debug configs");
        }
        globalVars_1.globalVars.isVS = projectSettingsHelper_1.isVSProject(projectSettings);
        projectSettings.programmingLanguage || (projectSettings.programmingLanguage = inputs[question_1.CoreQuestionNames.ProgrammingLanguage]);
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Components]: JSON.stringify(addedComponents),
        });
        utils_2.addFeatureNotify(inputs, context.userInteraction, "Resource", [constants_1.AzureResourceFunction.id]);
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs) {
        const apiCode = typedi_1.default.get(constants_2.ComponentNames.ApiCode);
        const res = await apiCode.build(context, inputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: "BE",
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.AddFeature,
            telemetryComponentName: constants_2.ComponentNames.TeamsApi,
            question: (context, inputs) => {
                question_2.functionNameQuestion.validation = getFunctionNameQuestionValidation(context, inputs);
                return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(question_2.functionNameQuestion));
            },
            errorHandler: (error) => {
                if (error && !(error === null || error === void 0 ? void 0 : error.name)) {
                    error.name = "addApiError";
                }
                return error;
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsApi.prototype, "add", null);
TeamsApi = tslib_1.__decorate([
    typedi_1.Service(constants_2.ComponentNames.TeamsApi)
], TeamsApi);
exports.TeamsApi = TeamsApi;
const getFunctionNameQuestionValidation = (context, inputs) => ({
    validFunc: async (input, previousInputs) => {
        var _a;
        const workingPath = path.join(inputs.projectPath, constants_2.PathConstants.apiWorkingDir);
        const name = input;
        if (!name || !constants_2.RegularExpr.validFunctionNamePattern.test(name)) {
            return messages_1.ErrorMessage.invalidFunctionName;
        }
        if (inputs.stage === teamsfx_api_1.Stage.create) {
            return undefined;
        }
        const language = (_a = inputs[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : context.projectSetting.programmingLanguage;
        // If language is unknown, skip checking and let scaffold handle the error.
        if (language && (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
            return messages_1.ErrorMessage.functionAlreadyExists;
        }
    },
});
//# sourceMappingURL=api.js.map