// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiConnectorImpl = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const utils_1 = require("./utils");
const result_1 = require("./result");
const constants_1 = require("./constants");
const envHandler_1 = require("./envHandler");
const errors_1 = require("./errors");
const questions_1 = require("./questions");
const localizeUtils_1 = require("../../../common/localizeUtils");
const sampleHandler_1 = require("./sampleHandler");
const depsHandler_1 = require("./depsHandler");
const telemetry_1 = require("./telemetry");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
class ApiConnectorImpl {
    async scaffold(ctx, inputs) {
        var _a, _b;
        if (!inputs.projectPath) {
            throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.InvalidProjectError.name, errors_1.ErrorMessage.InvalidProjectError.message());
        }
        const projectPath = inputs.projectPath;
        const languageType = ctx.projectSetting.programmingLanguage;
        const config = this.getUserDataFromInputs(inputs);
        const telemetryProperties = this.getTelemetryProperties(config);
        telemetry_1.TelemetryUtils.init(ctx.telemetryReporter);
        telemetry_1.TelemetryUtils.sendEvent(telemetry_1.Telemetry.stage.scaffold + telemetry_1.Telemetry.startSuffix, undefined, telemetryProperties);
        // CLI checker
        const bot = projectSettingsHelperV3_1.hasBot(ctx.projectSetting);
        const hasFunc = projectSettingsHelperV3_1.hasApi(ctx.projectSetting);
        if (!bot && config.ComponentType.includes(constants_1.ComponentType.BOT)) {
            throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.componentNotExistError.name, errors_1.ErrorMessage.componentNotExistError.message(constants_1.ComponentType.BOT));
        }
        if (!hasFunc && config.ComponentType.includes(constants_1.ComponentType.API)) {
            throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.componentNotExistError.name, errors_1.ErrorMessage.componentNotExistError.message(constants_1.ComponentType.API));
        }
        // backup relative files.
        const backupFolderName = utils_1.generateTempFolder();
        await Promise.all(config.ComponentType.map(async (component) => {
            await this.backupExistingFiles(path.join(projectPath, component), backupFolderName);
        }));
        try {
            let filesChanged = [];
            await Promise.all(config.ComponentType.map(async (component) => {
                const changes = await this.scaffoldInComponent(projectPath, component, config, languageType);
                filesChanged = filesChanged.concat(changes);
            }));
            const msg = utils_1.Notification.getNotificationMsg(projectPath, config, languageType);
            const logMessage = localizeUtils_1.getLocalizedString("plugins.apiConnector.Log.CommandSuccess", filesChanged.reduce((previousValue, currentValue) => previousValue +
                `[${currentValue.changeType}] ${path.relative(inputs.projectPath, currentValue.filePath)}` +
                "\n", ""));
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(logMessage); // Print generated/updated files for users
            if (inputs.platform != teamsfx_api_1.Platform.CLI) {
                (_b = ctx.userInteraction) === null || _b === void 0 ? void 0 : _b.showMessage("info", msg, false, "OK", utils_1.Notification.READ_MORE()).then((result) => {
                    var _a;
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === utils_1.Notification.READ_MORE()) {
                        (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.openUrl(utils_1.Notification.READ_MORE_URL);
                    }
                });
            }
            else {
                ctx.userInteraction.showMessage("info", msg + ` ${utils_1.Notification.GetLinkNotification()}`, false);
            }
        }
        catch (err) {
            await Promise.all(config.ComponentType.map(async (component) => {
                await fs.copy(path.join(projectPath, component, backupFolderName), path.join(projectPath, component), { overwrite: true });
                await this.removeSampleFilesWhenRestore(projectPath, component, config.APIName, languageType);
            }));
            if (!(err instanceof teamsfx_api_1.SystemError) && !(err instanceof teamsfx_api_1.UserError)) {
                err = result_1.ResultFactory.SystemError(errors_1.ErrorMessage.generateApiConFilesError.name, errors_1.ErrorMessage.generateApiConFilesError.message(err.message));
            }
            utils_1.sendErrorTelemetry(err, telemetry_1.Telemetry.stage.scaffold);
            throw err;
        }
        finally {
            await Promise.all(config.ComponentType.map(async (component) => {
                await utils_1.removeFileIfExist(path.join(projectPath, component, backupFolderName));
            }));
        }
        telemetry_1.TelemetryUtils.sendEvent(telemetry_1.Telemetry.stage.scaffold, true, telemetryProperties);
        const result = config.ComponentType.map((item) => {
            const componentPath = path.join(projectPath, item);
            return path.join(utils_1.getSampleDirPath(componentPath), utils_1.getSampleFileName(config.APIName, languageType));
        });
        return { generatedFiles: result };
    }
    async scaffoldInComponent(projectPath, componentItem, config, languageType) {
        const updatedPackageFile = await this.addSDKDependency(projectPath, componentItem);
        const updatedEnvFile = await this.scaffoldEnvFileToComponent(projectPath, config, componentItem);
        const generatedSampleFile = await this.scaffoldSampleCodeToComponent(projectPath, config, componentItem, languageType);
        const fileChanges = [updatedEnvFile, generatedSampleFile];
        if (updatedPackageFile) {
            // if we didn't update package.json, the result will be undefined
            fileChanges.push(updatedPackageFile);
        }
        return fileChanges;
    }
    async backupExistingFiles(folderPath, backupFolder) {
        await fs.ensureDir(path.join(folderPath, backupFolder));
        await utils_1.copyFileIfExist(path.join(folderPath, constants_1.Constants.envFileName), path.join(folderPath, backupFolder, constants_1.Constants.envFileName));
        await utils_1.copyFileIfExist(path.join(folderPath, constants_1.Constants.pkgJsonFile), path.join(folderPath, backupFolder, constants_1.Constants.pkgJsonFile));
        await utils_1.copyFileIfExist(path.join(folderPath, constants_1.Constants.pkgLockFile), path.join(folderPath, backupFolder, constants_1.Constants.pkgLockFile));
    }
    async removeSampleFilesWhenRestore(projectPath, component, apiName, languageType) {
        const apiFileName = utils_1.getSampleFileName(apiName, languageType);
        const sampleDirPath = utils_1.getSampleDirPath(path.join(projectPath, component));
        const sampleFilePath = path.join(sampleDirPath, apiFileName);
        await utils_1.removeFileIfExist(sampleFilePath);
    }
    getAuthConfigFromInputs(inputs) {
        let config;
        const apiType = inputs[constants_1.Constants.questionKey.apiType];
        switch (apiType) {
            case constants_1.AuthType.BASIC:
                utils_1.checkInputEmpty(inputs, constants_1.Constants.questionKey.apiUserName);
                config = {
                    AuthType: constants_1.AuthType.BASIC,
                    UserName: inputs[constants_1.Constants.questionKey.apiUserName],
                };
                break;
            case constants_1.AuthType.AAD:
                const AADConfig = {
                    AuthType: constants_1.AuthType.AAD,
                };
                if (inputs[constants_1.Constants.questionKey.apiAppType] === questions_1.reuseAppOption().id) {
                    AADConfig.ReuseTeamsApp = true;
                }
                else {
                    AADConfig.ReuseTeamsApp = false;
                    utils_1.checkInputEmpty(inputs, constants_1.Constants.questionKey.apiAppTenentId, constants_1.Constants.questionKey.apiAppId);
                    AADConfig.TenantId = inputs[constants_1.Constants.questionKey.apiAppTenentId];
                    AADConfig.ClientId = inputs[constants_1.Constants.questionKey.apiAppId];
                }
                config = AADConfig;
                break;
            case constants_1.AuthType.APIKEY:
                const APIKeyConfig = {
                    AuthType: constants_1.AuthType.APIKEY,
                };
                if (inputs[constants_1.Constants.questionKey.apiAPIKeyLocation] === questions_1.requestHeaderOption().id) {
                    APIKeyConfig.Location = constants_1.KeyLocation.Header;
                }
                else {
                    APIKeyConfig.Location = constants_1.KeyLocation.QueryParams;
                }
                utils_1.checkInputEmpty(inputs, constants_1.Constants.questionKey.apiAPIKeyName);
                APIKeyConfig.Name = inputs[constants_1.Constants.questionKey.apiAPIKeyName];
                config = APIKeyConfig;
                break;
            case constants_1.AuthType.CUSTOM:
            case constants_1.AuthType.CERT:
                config = {
                    AuthType: apiType,
                };
                break;
            default:
                throw result_1.ResultFactory.SystemError(errors_1.ErrorMessage.ApiConnectorInputError.name, errors_1.ErrorMessage.ApiConnectorInputError.message(inputs[constants_1.Constants.questionKey.apiAppType]));
        }
        return config;
    }
    getUserDataFromInputs(inputs) {
        utils_1.checkInputEmpty(inputs, constants_1.Constants.questionKey.componentsSelect, constants_1.Constants.questionKey.apiName, constants_1.Constants.questionKey.endpoint);
        const authConfig = this.getAuthConfigFromInputs(inputs);
        const config = {
            ComponentType: inputs[constants_1.Constants.questionKey.componentsSelect],
            APIName: inputs[constants_1.Constants.questionKey.apiName],
            AuthConfig: authConfig,
            EndPoint: inputs[constants_1.Constants.questionKey.endpoint],
        };
        return config;
    }
    async scaffoldEnvFileToComponent(projectPath, config, component) {
        const envHander = new envHandler_1.EnvHandler(projectPath, component);
        envHander.updateEnvs(config);
        return await envHander.saveLocalEnvFile();
    }
    async scaffoldSampleCodeToComponent(projectPath, config, component, languageType) {
        const sampleHandler = new sampleHandler_1.SampleHandler(projectPath, languageType, component);
        return await sampleHandler.generateSampleCode(config);
    }
    async addSDKDependency(projectPath, component) {
        const depsHandler = new depsHandler_1.DepsHandler(projectPath, component);
        return await depsHandler.addPkgDeps();
    }
    async generateQuestion(ctx, inputs) {
        const whichComponent = new questions_1.ComponentsQuestion(ctx, inputs);
        const apiNameQuestion = new questions_1.ApiNameQuestion(ctx);
        const whichAuthType = this.buildAuthTypeQuestion(ctx, inputs);
        const question = new teamsfx_api_1.QTreeNode({
            type: "group",
        });
        question.addChild(new teamsfx_api_1.QTreeNode(questions_1.apiEndpointQuestion()));
        question.addChild(new teamsfx_api_1.QTreeNode(whichComponent.getQuestion()));
        question.addChild(new teamsfx_api_1.QTreeNode(apiNameQuestion.getQuestion()));
        question.addChild(whichAuthType);
        return teamsfx_api_1.ok(question);
    }
    buildAuthTypeQuestion(ctx, inputs) {
        const whichAuthType = new teamsfx_api_1.QTreeNode({
            name: constants_1.Constants.questionKey.apiType,
            type: "singleSelect",
            staticOptions: [
                questions_1.BasicAuthOption(),
                questions_1.CertAuthOption(),
                questions_1.AADAuthOption(),
                questions_1.APIKeyAuthOption(),
                questions_1.ImplementMyselfOption(),
            ],
            title: localizeUtils_1.getLocalizedString("plugins.apiConnector.whichAuthType.title"),
            placeholder: localizeUtils_1.getLocalizedString("plugins.apiConnector.whichAuthType.placeholder"), // Use the placeholder to display some description
        });
        whichAuthType.addChild(this.buildAADAuthQuestion(ctx, inputs));
        whichAuthType.addChild(this.buildBasicAuthQuestion());
        whichAuthType.addChild(this.buildAPIKeyAuthQuestion());
        return whichAuthType;
    }
    buildBasicAuthQuestion() {
        const node = new teamsfx_api_1.QTreeNode(questions_1.basicAuthUsernameQuestion());
        node.condition = { equals: questions_1.BasicAuthOption().id };
        return node;
    }
    buildAADAuthQuestion(ctx, inputs) {
        const aad = projectSettingsHelperV3_1.hasAAD(ctx.projectSetting);
        let node;
        if (aad || inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
            node = new teamsfx_api_1.QTreeNode({
                name: constants_1.Constants.questionKey.apiAppType,
                type: "singleSelect",
                staticOptions: [questions_1.reuseAppOption(), questions_1.anotherAppOption()],
                title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.appType.title"),
            });
            node.condition = { equals: questions_1.AADAuthOption().id };
            const tenentQuestionNode = new teamsfx_api_1.QTreeNode(questions_1.appTenantIdQuestion());
            tenentQuestionNode.condition = { equals: questions_1.anotherAppOption().id };
            tenentQuestionNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.appIdQuestion()));
            node.addChild(tenentQuestionNode);
        }
        else {
            node = new teamsfx_api_1.QTreeNode(questions_1.appTenantIdQuestion());
            node.condition = { equals: questions_1.AADAuthOption().id };
            node.addChild(new teamsfx_api_1.QTreeNode(questions_1.appIdQuestion()));
        }
        return node;
    }
    buildAPIKeyAuthQuestion() {
        const node = new teamsfx_api_1.QTreeNode({
            name: constants_1.Constants.questionKey.apiAPIKeyLocation,
            type: "singleSelect",
            staticOptions: [questions_1.requestHeaderOption(), questions_1.queryParamsOption()],
            title: localizeUtils_1.getLocalizedString("plugins.apiConnector.getQuestion.apiKeyLocation.title"),
        });
        node.condition = { equals: questions_1.APIKeyAuthOption().id };
        const keyNameQuestionNode = new teamsfx_api_1.QTreeNode(questions_1.buildAPIKeyNameQuestion());
        node.addChild(keyNameQuestionNode);
        return node;
    }
    getTelemetryProperties(config) {
        const properties = {
            [telemetry_1.Telemetry.properties.authType]: config.AuthConfig.AuthType.toString(),
            [telemetry_1.Telemetry.properties.componentType]: config.ComponentType.join(","),
        };
        switch (config.AuthConfig.AuthType) {
            case constants_1.AuthType.AAD:
                const aadAuthConfig = config.AuthConfig;
                properties[telemetry_1.Telemetry.properties.reuseTeamsApp] = aadAuthConfig.ReuseTeamsApp
                    ? telemetry_1.Telemetry.valueYes
                    : telemetry_1.Telemetry.valueNo;
                break;
            case constants_1.AuthType.APIKEY:
                const authConfig = config.AuthConfig;
                properties[telemetry_1.Telemetry.properties.keyLocation] = authConfig.Location;
                break;
            default:
                break;
        }
        return properties;
    }
}
exports.ApiConnectorImpl = ApiConnectorImpl;
//# sourceMappingURL=ApiConnectorImpl.js.map