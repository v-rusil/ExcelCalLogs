// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DepsHandler = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const constants_1 = require("./constants");
const result_1 = require("./result");
const errors_1 = require("./errors");
const telemetry_1 = require("./telemetry");
const folder_1 = require("../../../folder");
class DepsHandler {
    constructor(workspaceFolder, componentType) {
        this.projectRoot = workspaceFolder;
        this.componentType = componentType;
    }
    async addPkgDeps() {
        const depsConfig = await DepsHandler.getDepsConfig();
        return await this.updateLocalPkgDepsVersion(depsConfig);
    }
    static async getDepsConfig() {
        const configPath = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "apiconnector");
        const sdkConfigPath = path.join(configPath, constants_1.Constants.pkgJsonFile);
        const sdkContent = fs.readJsonSync(sdkConfigPath);
        return sdkContent.dependencies;
    }
    static async checkDepsVerSupport(projectPath, component) {
        const localPkgPath = path.join(projectPath, component, constants_1.Constants.pkgJsonFile);
        // fs.pathExist and fs.readJson in CLI question validation will cause unexpected behaviors
        if (!fs.pathExistsSync(localPkgPath)) {
            return false;
        }
        const pkgContent = fs.readJsonSync(localPkgPath);
        const depsConfig = await DepsHandler.getDepsConfig();
        for (const pkgItem in depsConfig) {
            if (!DepsHandler.sdkVersionCheck(pkgContent.dependencies, pkgItem, depsConfig[pkgItem], component)) {
                return false;
            }
        }
        return true;
    }
    async updateLocalPkgDepsVersion(pkgConfig) {
        const localPkgPath = path.join(this.projectRoot, this.componentType, constants_1.Constants.pkgJsonFile);
        if (!(await fs.pathExists(localPkgPath))) {
            throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.localPkgFileNotExistError.name, errors_1.ErrorMessage.localPkgFileNotExistError.message(this.componentType));
        }
        const pkgContent = await fs.readJson(localPkgPath);
        let needUpdate = false;
        for (const pkgItem in pkgConfig) {
            if (DepsHandler.sdkVersionCheck(pkgContent.dependencies, pkgItem, pkgConfig[pkgItem], this.componentType)) {
                pkgContent.dependencies[pkgItem] = pkgConfig[pkgItem];
                needUpdate = true;
            }
        }
        if (needUpdate) {
            await fs.writeFile(localPkgPath, JSON.stringify(pkgContent, null, 4));
            const telemetryProperties = {
                [telemetry_1.Telemetry.properties.componentType]: this.componentType,
            };
            telemetry_1.TelemetryUtils.sendEvent(telemetry_1.Telemetry.stage.updatePkg, undefined, telemetryProperties);
            return {
                changeType: result_1.FileChangeType.Update,
                filePath: localPkgPath,
            }; // return modified files
        }
        return undefined;
    }
    static sdkVersionCheck(deps, sdkName, sdkVersion, componentType) {
        // sdk alpha version
        if (DepsHandler.caretPrereleases(deps[sdkName], sdkVersion)) {
            return false;
        }
        // sdk not in dependencies.
        else if (!deps[sdkName]) {
            return true;
        }
        // local sdk version intersect with sdk version in config.
        else if (semver_1.default.intersects(deps[sdkName], sdkVersion)) {
            return false;
        }
        // local sdk version lager than sdk version in config.
        else if (semver_1.default.gte(semver_1.default.minVersion(deps[sdkName]), "1.0.0") &&
            semver_1.default.lt(semver_1.default.minVersion(deps[sdkName]), "3.0.0")) {
            return false;
        }
        else {
            throw result_1.ResultFactory.UserError(errors_1.ErrorMessage.sdkVersionImcompatibleError.name, errors_1.ErrorMessage.sdkVersionImcompatibleError.message(componentType, deps[sdkName], sdkVersion));
        }
    }
    static caretPrereleases(ver1, ver2) {
        if (!semver_1.default.prerelease(ver1) || !semver_1.default.prerelease(ver2)) {
            return false;
        }
        // semver.prerelease an prerelease version return alpha, beta or rc.
        // example: semver.prerelease(0.6.0-alpha.12345.0) return ["alpha", "12345", "0"]
        if (semver_1.default.prerelease(ver1)[0] != semver_1.default.prerelease(ver2)[0]) {
            return false;
        }
        if (semver_1.default.satisfies(semver_1.default.coerce(ver1).version, `^${semver_1.default.coerce(ver2).version}`)) {
            return true;
        }
        return false;
    }
}
exports.DepsHandler = DepsHandler;
//# sourceMappingURL=depsHandler.js.map