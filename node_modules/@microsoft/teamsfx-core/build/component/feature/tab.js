"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsTab = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const globalVars_1 = require("../../core/globalVars");
const question_1 = require("../../core/question");
const constants_1 = require("../constants");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const workflow_1 = require("../workflow");
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
const tabCode_1 = require("../code/tab/tabCode");
const utils_2 = require("../../common/utils");
const debug_1 = require("../debug");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const lib_1 = require("@feathersjs/hooks/lib");
const telemetry_1 = require("../../common/telemetry");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const constants_3 = require("../code/tab/constants");
let TeamsTab = class TeamsTab {
    constructor() {
        this.name = "teams-tab";
    }
    async add(context, inputs, actionContext) {
        const projectSettings = context.projectSetting;
        const effects = [];
        inputs[question_1.CoreQuestionNames.ProgrammingLanguage] =
            context.projectSetting.programmingLanguage ||
                inputs[question_1.CoreQuestionNames.ProgrammingLanguage] ||
                "javascript";
        inputs.hosting || (inputs.hosting = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === "csharp"
            ? constants_2.ComponentNames.AzureWebApp
            : constants_2.ComponentNames.AzureStorage);
        globalVars_1.globalVars.isVS = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === "csharp";
        projectSettings.programmingLanguage || (projectSettings.programmingLanguage = inputs[question_1.CoreQuestionNames.ProgrammingLanguage]);
        const addedComponents = [];
        // Add static tab to app-manifest if teams-tab already exists
        let tabConfig = workflow_1.getComponent(projectSettings, constants_2.ComponentNames.TeamsTab);
        if (tabConfig) {
            // app-manifest.addCapability
            {
                const capabilities = [{ name: "staticTab" }];
                const clonedInputs = lodash_1.cloneDeep(inputs);
                const manifestComponent = typedi_1.Container.get(constants_2.ComponentNames.AppManifest);
                const res = await manifestComponent.addCapability(clonedInputs, capabilities);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                effects.push("add tab capability in app manifest");
                utils_1.addFeatureNotify(inputs, context.userInteraction, "Capability", [inputs.features]);
                return teamsfx_api_1.ok(undefined);
            }
        }
        // 1. scaffold and config tab
        const clonedInputs = lodash_1.cloneDeep(inputs);
        clonedInputs.folder || (clonedInputs.folder = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === constants_2.ProgrammingLanguage.CSharp
            ? constants_2.PathConstants.dotnetWorkingDir
            : constants_2.PathConstants.tabWorkingDir);
        clonedInputs.language = inputs[question_1.CoreQuestionNames.ProgrammingLanguage];
        const tabCode = typedi_1.Container.get(constants_2.ComponentNames.TabCode);
        const res = await tabCode.generate(context, clonedInputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        effects.push("generate tab code");
        tabConfig = {
            name: constants_2.ComponentNames.TeamsTab,
            hosting: inputs.hosting,
            deploy: true,
            provision: true,
            build: true,
            folder: clonedInputs.folder,
        };
        projectSettings.components.push(tabConfig);
        addedComponents.push(tabConfig.name);
        effects.push(messages_1.Plans.generateSourceCodeAndConfig(constants_2.ComponentNames.TeamsTab));
        // 2. generate provision bicep
        // 2.0 bicep.init
        {
            const bicepComponent = typedi_1.Container.get("bicep");
            const res = await bicepComponent.init(inputs.projectPath);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        const biceps = [];
        // 2.1 hosting bicep
        const hostingConfig = workflow_1.getComponentByScenario(projectSettings, inputs.hosting, constants_2.Scenarios.Tab);
        if (!hostingConfig) {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                componentId: constants_2.ComponentNames.TeamsTab,
                scenario: constants_2.Scenarios.Tab,
            });
            const hostingComponent = typedi_1.Container.get(inputs.hosting);
            const res = await hostingComponent.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: inputs.hosting,
                scenario: constants_2.Scenarios.Tab,
                provision: true,
            });
            addedComponents.push(inputs.hosting);
            effects.push(messages_1.Plans.generateBicepAndConfig(inputs.hosting));
        }
        // 2.2 identity bicep
        if (!workflow_1.getComponent(projectSettings, constants_2.ComponentNames.Identity)) {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                componentId: "",
                scenario: "",
            });
            const identityComponent = typedi_1.Container.get(constants_2.ComponentNames.Identity);
            const res = await identityComponent.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: constants_2.ComponentNames.Identity,
                provision: true,
            });
            addedComponents.push(constants_2.ComponentNames.Identity);
            effects.push(messages_1.Plans.generateBicepAndConfig(constants_2.ComponentNames.Identity));
        }
        //persist bicep
        const bicepRes = await utils_1.bicepUtils.persistBiceps(inputs.projectPath, utils_2.convertToAlphanumericOnly(context.projectSetting.appName), biceps);
        if (bicepRes.isErr())
            return bicepRes;
        // 2.3 add sso
        const nonSsoIds = [constants_1.TabNonSsoItem().id, constants_1.DashboardOptionItem().id];
        if (!nonSsoIds.includes(inputs[constants_1.AzureSolutionQuestionNames.Features])) {
            const ssoComponent = typedi_1.Container.get("sso");
            const res = await ssoComponent.add(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 3. generate config bicep
        {
            const res = await utils_1.generateConfigBiceps(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate config biceps");
        }
        // 4. local debug settings
        {
            const res = await debug_1.generateLocalDebugSettings(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate debug configs");
        }
        // 5. app-manifest.addCapability
        {
            const capabilities = [{ name: "staticTab" }];
            // M365 app does not support configurationTab
            if (!context.projectSetting.isM365) {
                capabilities.push({ name: "configurableTab" });
            }
            const clonedInputs = Object.assign(Object.assign({}, lodash_1.cloneDeep(inputs)), { validDomain: `{{state.${constants_2.ComponentNames.TeamsTab}.domain}}` });
            const manifestComponent = typedi_1.Container.get(constants_2.ComponentNames.AppManifest);
            const res = await manifestComponent.addCapability(clonedInputs, capabilities);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("add tab capability in app manifest");
        }
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Components]: JSON.stringify(addedComponents),
        });
        await utils_1.scaffoldRootReadme(context.projectSetting, inputs.projectPath);
        utils_1.addFeatureNotify(inputs, context.userInteraction, "Capability", [inputs.features]);
        return teamsfx_api_1.ok(undefined);
    }
    async provision(context) {
        context.envInfo.state[constants_2.ComponentNames.TeamsTab] =
            context.envInfo.state[constants_2.ComponentNames.TeamsTab] || {};
        if (projectSettingsHelper_1.isVSProject(context.projectSetting)) {
            context.envInfo.state[constants_2.ComponentNames.TeamsTab][constants_2.StorageOutputs.indexPath.key] =
                constants_2.PathConstants.blazorTabIndexPath;
        }
        else {
            context.envInfo.state[constants_2.ComponentNames.TeamsTab][constants_2.StorageOutputs.indexPath.key] =
                constants_2.PathConstants.reactTabIndexPath;
        }
        return teamsfx_api_1.ok(undefined);
    }
    async configure(context, inputs) {
        const tabCode = new tabCode_1.TabCodeProvider();
        const res = await tabCode.configure(context, inputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs) {
        const tabCode = new tabCode_1.TabCodeProvider();
        const res = await tabCode.build(context, inputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.AddFeature,
            telemetryComponentName: constants_2.ComponentNames.TeamsTab,
            errorSource: constants_3.errorSource,
            errorHandler: (error) => {
                if (error && !(error === null || error === void 0 ? void 0 : error.name)) {
                    error.name = "addTabError";
                }
                return error;
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsTab.prototype, "add", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: constants_3.errorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsTab.prototype, "provision", null);
TeamsTab = tslib_1.__decorate([
    typedi_1.Service("teams-tab")
], TeamsTab);
exports.TeamsTab = TeamsTab;
//# sourceMappingURL=tab.js.map