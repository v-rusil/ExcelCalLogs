"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CICDImpl = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const result_1 = require("./result");
const factory_1 = require("./provider/factory");
const questions_1 = require("./questions");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const localizeUtils_1 = require("../../../common/localizeUtils");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const constants_1 = require("./constants");
class CICDImpl {
    constructor() {
        this.commonProperties = {};
    }
    async addCICDWorkflows(context, inputs, envName) {
        const envInfo = context.envInfo;
        telemetry_helper_1.telemetryHelper.sendStartEvent(context, envInfo, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS, this.commonProperties);
        try {
            // 1. Key inputs (envName, provider, template) x (hostingType, ).
            if (!inputs.projectPath) {
                throw new errors_1.NoProjectOpenedError();
            }
            const projectPath = inputs.projectPath;
            const providerName = inputs[questions_1.questionNames.Provider];
            const templateNames = inputs[questions_1.questionNames.Template];
            if (!envName || !providerName || templateNames.length === 0) {
                throw new errors_1.InternalError([
                    localizeUtils_1.getDefaultString("error.cicd.PreconditionNotMet"),
                    localizeUtils_1.getLocalizedString("error.cicd.PreconditionNotMet"),
                ]);
            }
            this.commonProperties = {
                env: envName,
                provider: providerName,
                template: templateNames.join(","),
            };
            // 2. Call factory to get provider instance.
            const providerInstance = factory_1.CICDProviderFactory.create(providerName);
            // 3. Call instance.scaffold(template, replacements: any).
            //  3.1 Call the initial scaffold.
            const progressBar = context.userInteraction.createProgressBar(localizeUtils_1.getLocalizedString("plugins.cicd.ProgressBar.scaffold.title"), templateNames.length);
            const created = [];
            const skipped = [];
            await progressBar.start(localizeUtils_1.getLocalizedString("plugins.cicd.ProgressBar.scaffold.detail", templateNames[0]));
            let scaffolded = await providerInstance.scaffold(projectPath, templateNames[0], envName, context);
            if (scaffolded.isOk() && !scaffolded.value) {
                created.push(questions_1.templateIdToLabel(templateNames[0]));
            }
            else {
                skipped.push(questions_1.templateIdToLabel(templateNames[0]));
            }
            //  3.2 Call the next scaffold.
            for (const templateName of templateNames.slice(1)) {
                await progressBar.next(localizeUtils_1.getLocalizedString("plugins.cicd.ProgressBar.scaffold.detail", templateName));
                scaffolded = await providerInstance.scaffold(projectPath, templateName, envName, context);
                if (scaffolded.isOk() && !scaffolded.value) {
                    created.push(questions_1.templateIdToLabel(templateName));
                }
                else {
                    skipped.push(questions_1.templateIdToLabel(templateName));
                }
            }
            await progressBar.end(true);
            // 4. Send notification messages.
            const messages = [];
            if (created.length > 0) {
                messages.push(localizeUtils_1.getLocalizedString("plugins.cicd.result.scaffold.created", created.join(", "), questions_1.providerIdToLabel(providerName), envName));
            }
            if (skipped.length > 0) {
                messages.push(localizeUtils_1.getLocalizedString("plugins.cicd.result.scaffold.skipped", skipped.join(", "), questions_1.providerIdToLabel(providerName), envName));
            }
            const message = messages.join(" ");
            context.userInteraction.showMessage("info", message, false);
            logger_1.Logger.info(message);
            const res = result_1.FxCICDPluginResultFactory.Success();
            telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS, res, this.commonProperties);
            return res;
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                const res = teamsfx_api_1.err(e);
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS, res, this.commonProperties);
                return res;
            }
            if (e instanceof errors_1.PluginError) {
                const result = e.errorType === errors_1.ErrorType.System
                    ? result_1.FxCICDPluginResultFactory.SystemError(e.name, [e.genDefaultMessage(), e.genMessage()], e.innerError)
                    : result_1.FxCICDPluginResultFactory.UserError(e.name, [e.genDefaultMessage(), e.genMessage()], e.showHelpLink, e.innerError);
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS, result, this.commonProperties);
                return result;
            }
            else {
                // Unrecognized Exception.
                const UnhandledErrorCode = "UnhandledError";
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS, result_1.FxCICDPluginResultFactory.SystemError(UnhandledErrorCode, [`Got an unhandled error: ${e.message}`, `Got an unhandled error: ${e.message}`], e.innerError), this.commonProperties);
                return result_1.FxCICDPluginResultFactory.SystemError(UnhandledErrorCode, e.message, e);
            }
        }
    }
}
exports.CICDImpl = CICDImpl;
//# sourceMappingURL=CICDImpl.js.map