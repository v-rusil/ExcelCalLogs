"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCicdQuestion = exports.CICD = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../core/error");
const environment_1 = require("../../../core/environment");
const errors_1 = require("./errors");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
const constants_1 = require("../../constants");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const questions_1 = require("./questions");
const CICDImpl_1 = require("./CICDImpl");
const existingTemplatesStat_1 = require("./existingTemplatesStat");
let CICD = class CICD {
    constructor() {
        this.name = constants_1.ComponentNames.CICD;
    }
    async add(context, inputs) {
        const cicdImpl = new CICDImpl_1.CICDImpl();
        const envName = inputs.env || inputs[questions_1.questionNames.Environment];
        const res = await cicdImpl.addCICDWorkflows(context, inputs, envName);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: async (context, inputs) => {
                return await addCicdQuestion(context, inputs);
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CICD.prototype, "add", null);
CICD = tslib_1.__decorate([
    typedi_1.Service(constants_1.ComponentNames.CICD)
], CICD);
exports.CICD = CICD;
async function addCicdQuestion(ctx, inputs) {
    // add CI CD workflows for minimal app is not supported.
    const isExistingApp = projectSettingsHelperV3_1.isMiniApp(ctx.projectSetting);
    if (inputs.platform !== teamsfx_api_1.Platform.CLI_HELP && isExistingApp) {
        throw new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.addCiCdFlow);
    }
    const cicdWorkflowQuestions = new teamsfx_api_1.QTreeNode({
        type: "group",
    });
    const whichProvider = {
        name: questions_1.questionNames.Provider,
        type: "singleSelect",
        staticOptions: [questions_1.githubOption, questions_1.azdoOption, questions_1.jenkinsOption],
        title: localizeUtils_1.getLocalizedString("plugins.cicd.whichProvider.title"),
        default: questions_1.githubOption.id,
    };
    const whichTemplate = {
        name: questions_1.questionNames.Template,
        type: "multiSelect",
        staticOptions: [questions_1.ciOption(), questions_1.cdOption(), questions_1.provisionOption(), questions_1.publishOption()],
        title: localizeUtils_1.getLocalizedString("plugins.cicd.whichTemplate.title"),
        default: [questions_1.ciOption().id],
    };
    // TODO: add support for VS/.Net Projects.
    if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
        if (!inputs.projectPath) {
            throw new errors_1.NoProjectOpenedError();
        }
        const envProfilesResult = await environment_1.environmentManager.listRemoteEnvConfigs(inputs.projectPath);
        if (envProfilesResult.isErr()) {
            throw new errors_1.InternalError([
                localizeUtils_1.getDefaultString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message),
                localizeUtils_1.getLocalizedString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message),
            ], envProfilesResult.error);
        }
        const existingInstance = existingTemplatesStat_1.ExistingTemplatesStat.getInstance(inputs.projectPath, envProfilesResult.value);
        // Mute this scan before there's initial scan on upper layers.
        // await existingInstance.scan();
        const whichEnvironment = {
            type: "singleSelect",
            name: questions_1.questionNames.Environment,
            title: localizeUtils_1.getLocalizedString("plugins.cicd.whichEnvironment.title"),
            staticOptions: [],
            dynamicOptions: async (inputs) => {
                // Remove the env items in which all combinations of templates are scaffolded/existing.
                return existingInstance.availableEnvOptions();
            },
            skipSingleOption: true,
        };
        whichProvider.dynamicOptions = async (inputs) => {
            const envName = inputs[questions_1.questionNames.Environment];
            return existingInstance.availableProviderOptions(envName);
        };
        whichTemplate.dynamicOptions = async (inputs) => {
            const envName = inputs[questions_1.questionNames.Environment];
            const provider = inputs[questions_1.questionNames.Provider];
            return existingInstance.availableTemplateOptions(envName, provider);
        };
        cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichEnvironment));
    }
    cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichProvider));
    cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichTemplate));
    return teamsfx_api_1.ok(cicdWorkflowQuestions);
}
exports.addCicdQuestion = addCicdQuestion;
//# sourceMappingURL=cicd.js.map