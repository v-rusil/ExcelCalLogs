"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConditionOfNotificationTriggerQuestion = exports.showNotificationTriggerCondition = exports.createHostTypeTriggerQuestion = exports.FunctionsOptionItems = exports.AppServiceOptionItemForVS = exports.AppServiceOptionItem = exports.FunctionsHttpTriggerOptionItem = exports.FunctionsHttpAndTimerTriggerOptionItem = exports.FunctionsTimerTriggerOptionItem = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const featureFlags_1 = require("../../../common/featureFlags");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../constants");
const constants_2 = require("../../constants");
const constants_3 = require("./constants");
var HostType;
(function (HostType) {
    HostType["AppService"] = "app-service";
    HostType["Functions"] = "azure-functions";
})(HostType || (HostType = {}));
// NOTE: id must be the sample as cliName to prevent parsing error for CLI default value.
exports.FunctionsTimerTriggerOptionItem = optionWithL10n({
    id: "timer-functions",
    hostType: HostType.Functions,
    triggers: [constants_3.NotificationTriggers.TIMER],
});
exports.FunctionsHttpAndTimerTriggerOptionItem = optionWithL10n({
    id: "http-and-timer-functions",
    hostType: HostType.Functions,
    triggers: [constants_3.NotificationTriggers.HTTP, constants_3.NotificationTriggers.TIMER],
});
exports.FunctionsHttpTriggerOptionItem = optionWithL10n({
    id: "http-functions",
    hostType: HostType.Functions,
    triggers: [constants_3.NotificationTriggers.HTTP],
});
exports.AppServiceOptionItem = optionWithL10n({
    id: "http-restify",
    hostType: HostType.AppService,
    // trigger of app service host is hard-coded to http, so no need to set here
});
// TODO: this option will not be shown in UI, leave messages empty.
exports.AppServiceOptionItemForVS = optionWithL10n({
    id: "http-webapi",
    hostType: HostType.AppService,
});
exports.FunctionsOptionItems = [
    exports.FunctionsHttpTriggerOptionItem,
    exports.FunctionsTimerTriggerOptionItem,
    exports.FunctionsHttpAndTimerTriggerOptionItem,
];
function optionWithL10n(option) {
    // e.g. expands to plugins.bot.triggers.functionsTimer.label
    const prefix = "plugins.bot.triggers";
    return Object.assign(Object.assign({}, option), { label: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.label`), cliName: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.cliName`), description: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.description`), detail: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.detail`) });
}
// The restrictions of this question:
//   - appService and function are mutually exclusive
//   - users must select at least one trigger.
function createHostTypeTriggerQuestion(platform, runtime) {
    const prefix = "plugins.bot.questionHostTypeTrigger";
    const appServiceOptionItem = runtime === constants_2.Runtime.dotnet ? exports.AppServiceOptionItemForVS : exports.AppServiceOptionItem;
    let staticOptions = [appServiceOptionItem, ...exports.FunctionsOptionItems];
    if (platform === teamsfx_api_1.Platform.CLI) {
        // The UI in CLI is different. It does not have description. So we need to merge that into label.
        staticOptions = staticOptions.map((option) => {
            // do not change the original option
            const cliOption = Object.assign({}, option);
            cliOption.label = `${option.label} (${option.description})`;
            return cliOption;
        });
    }
    return {
        name: constants_3.QuestionNames.BOT_HOST_TYPE_TRIGGER,
        title: localizeUtils_1.getLocalizedString(`${prefix}.title`),
        type: "singleSelect",
        staticOptions: staticOptions,
        default: appServiceOptionItem.id,
        placeholder: localizeUtils_1.getLocalizedString(`${prefix}.placeholder`),
    };
}
exports.createHostTypeTriggerQuestion = createHostTypeTriggerQuestion;
// Question model condition to determine whether to show "Select triggers" question after "Select capabilities".
// Return undefined for true, a string for false. The string itself it not used.
exports.showNotificationTriggerCondition = {
    validFunc: (input, inputs) => {
        if (!inputs) {
            return "Invalid inputs";
        }
        if (featureFlags_1.isPreviewFeaturesEnabled()) {
            const cap = inputs[constants_1.AzureSolutionQuestionNames.Capabilities];
            if (cap === constants_1.NotificationOptionItem().id) {
                return undefined;
            }
            // Single Select Option for "Add Feature"
            const feature = inputs[constants_1.AzureSolutionQuestionNames.Features];
            if (feature === constants_1.NotificationOptionItem().id) {
                return undefined;
            }
        }
        else {
            const cap = inputs[constants_1.AzureSolutionQuestionNames.Capabilities];
            if (Array.isArray(cap) && cap.includes(constants_1.NotificationOptionItem().id)) {
                return undefined;
            }
        }
        return "Notification is not selected";
    },
    // Workaround for CLI: it requires containsAny to be set, or it will crash.
    containsAny: [constants_1.NotificationOptionItem().id],
};
function getConditionOfNotificationTriggerQuestion(runtime) {
    return {
        validFunc: async (input, inputs) => {
            if ((inputs === null || inputs === void 0 ? void 0 : inputs["runtime"]) === runtime) {
                return undefined;
            }
            else {
                return `runtime is not ${runtime}`;
            }
        },
    };
}
exports.getConditionOfNotificationTriggerQuestion = getConditionOfNotificationTriggerQuestion;
//# sourceMappingURL=question.js.map