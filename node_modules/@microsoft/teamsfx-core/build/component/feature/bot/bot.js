"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsBot = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
require("reflect-metadata");
const typedi_1 = require("typedi");
const telemetry_1 = require("../../../common/telemetry");
const utils_1 = require("../../../common/utils");
const globalVars_1 = require("../../../core/globalVars");
const question_1 = require("../../../core/question");
const constants_1 = require("./constants");
const question_2 = require("./question");
const constants_2 = require("../../constants");
require("../../connection/azureWebAppConfig");
const constants_3 = require("../../constants");
const debug_1 = require("../../debug");
const messages_1 = require("../../messages");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
require("../../resource/azureAppService/azureWebApp");
const utils_2 = require("../../utils");
const workflow_1 = require("../../workflow");
let TeamsBot = class TeamsBot {
    constructor() {
        this.name = constants_3.ComponentNames.TeamsBot;
    }
    async add(context, inputs, actionContext) {
        var _a, _b;
        const projectSettings = context.projectSetting;
        const effects = [];
        const botCapability = featureToCapability.get(inputs[question_1.CoreQuestionNames.Features]);
        inputs.hosting = resolveHosting(inputs);
        inputs[question_1.CoreQuestionNames.ProgrammingLanguage] =
            context.projectSetting.programmingLanguage ||
                inputs[question_1.CoreQuestionNames.ProgrammingLanguage] ||
                "javascript";
        globalVars_1.globalVars.isVS = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === "csharp";
        const isM365 = context.projectSetting.isM365 === true;
        let botConfig = workflow_1.getComponent(projectSettings, constants_3.ComponentNames.TeamsBot);
        // bot can only add once
        if (botConfig) {
            if (!((_a = botConfig.capabilities) === null || _a === void 0 ? void 0 : _a.includes(botCapability))) {
                botConfig.capabilities.push(botCapability);
                const res = await this.addBotCapability(inputs, isM365);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
                effects.push("add bot capability in app manifest");
            }
            utils_2.addFeatureNotify(inputs, context.userInteraction, "Capability", [inputs.features]);
            return teamsfx_api_1.ok(undefined);
        }
        const addedComponents = [];
        // 1. scaffold bot and add bot config
        {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            const scenarios = (_b = featureToScenario.get(inputs[question_1.CoreQuestionNames.Features])) === null || _b === void 0 ? void 0 : _b(inputs[constants_1.QuestionNames.BOT_HOST_TYPE_TRIGGER]);
            const language = (inputs === null || inputs === void 0 ? void 0 : inputs[question_1.CoreQuestionNames.ProgrammingLanguage]) ||
                context.projectSetting.programmingLanguage ||
                constants_3.ProgrammingLanguage.JS;
            const folder = language === constants_3.ProgrammingLanguage.CSharp ? "." : constants_3.PathConstants.botWorkingDir;
            lodash_1.assign(clonedInputs, {
                folder: folder,
                scenarios: scenarios,
                language: language,
            });
            const botCode = typedi_1.Container.get(constants_3.ComponentNames.BotCode);
            const res = await botCode.generate(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate bot code");
            botConfig = {
                name: constants_3.ComponentNames.TeamsBot,
                hosting: inputs.hosting,
                provision: language === constants_3.ProgrammingLanguage.CSharp,
                deploy: true,
                capabilities: botCapability ? [botCapability] : [],
                build: true,
                folder: folder,
            };
            projectSettings.components.push(botConfig);
            addedComponents.push(botConfig.name);
            effects.push(messages_1.Plans.generateSourceCodeAndConfig(constants_3.ComponentNames.TeamsBot));
        }
        // 2. generate provision bicep
        // 2.0 bicep.init
        {
            const bicepComponent = typedi_1.Container.get("bicep");
            const res = await bicepComponent.init(inputs.projectPath);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        const biceps = [];
        // 2.1 bot-service bicep
        if (!workflow_1.getComponent(projectSettings, constants_3.ComponentNames.BotService)) {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                hosting: inputs.hosting,
                scenario: constants_3.Scenarios.Bot,
            });
            const botService = typedi_1.Container.get(constants_3.ComponentNames.BotService);
            const res = await botService.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: constants_3.ComponentNames.BotService,
                provision: true,
            });
            addedComponents.push(constants_3.ComponentNames.BotService);
            effects.push(messages_1.Plans.generateBicepAndConfig(constants_3.ComponentNames.BotService));
        }
        // 2.2 hosting bicep
        const hostingConfig = workflow_1.getComponentByScenario(projectSettings, inputs.hosting, constants_3.Scenarios.Bot);
        if (!hostingConfig) {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            lodash_1.assign(clonedInputs, {
                componentId: constants_3.ComponentNames.TeamsBot,
                scenario: constants_3.Scenarios.Bot,
            });
            const hostingComponent = typedi_1.Container.get(inputs.hosting);
            const res = await hostingComponent.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: inputs.hosting,
                scenario: constants_3.Scenarios.Bot,
            });
            addedComponents.push(inputs.hosting);
            effects.push(messages_1.Plans.generateBicepAndConfig(inputs.hosting));
        }
        // 2.3 identity bicep
        if (!workflow_1.getComponent(projectSettings, constants_3.ComponentNames.Identity)) {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            const identityComponent = typedi_1.Container.get(constants_3.ComponentNames.Identity);
            const res = await identityComponent.generateBicep(context, clonedInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            res.value.forEach((b) => biceps.push(b));
            projectSettings.components.push({
                name: constants_3.ComponentNames.Identity,
                provision: true,
            });
            addedComponents.push(constants_3.ComponentNames.Identity);
            effects.push(messages_1.Plans.generateBicepAndConfig(constants_3.ComponentNames.Identity));
        }
        //persist bicep
        const bicepRes = await utils_2.bicepUtils.persistBiceps(inputs.projectPath, utils_1.convertToAlphanumericOnly(context.projectSetting.appName), biceps);
        if (bicepRes.isErr())
            return bicepRes;
        // 3. generate config bicep
        {
            const res = await utils_2.generateConfigBiceps(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate config biceps");
        }
        // 4. local debug settings
        {
            const res = await debug_1.generateLocalDebugSettings(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate debug configs");
        }
        // 5. app-manifest.addCapability
        {
            const res = await this.addBotCapability(inputs, isM365);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("add bot capability in app manifest");
        }
        projectSettings.programmingLanguage || (projectSettings.programmingLanguage = inputs[question_1.CoreQuestionNames.ProgrammingLanguage]);
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Components]: JSON.stringify(addedComponents),
        });
        await utils_2.scaffoldRootReadme(context.projectSetting, inputs.projectPath);
        utils_2.addFeatureNotify(inputs, context.userInteraction, "Capability", [inputs.features]);
        return teamsfx_api_1.ok(undefined);
    }
    async configure(context, inputs) {
        const botCode = typedi_1.Container.get(constants_3.ComponentNames.BotCode);
        return await botCode.configure(context, inputs);
    }
    async build(context, inputs) {
        const botCode = typedi_1.Container.get(constants_3.ComponentNames.BotCode);
        const res = await botCode.build(context, inputs);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
    async addBotCapability(inputs, isM365 = false) {
        {
            const manifestCapability = {
                name: inputs[question_1.CoreQuestionNames.Features] === constants_2.MessageExtensionItem().id ||
                    inputs[question_1.CoreQuestionNames.Features] === constants_2.M365SearchAppOptionItem().id
                    ? "MessageExtension"
                    : "Bot",
            };
            const clonedInputs = Object.assign(Object.assign({}, lodash_1.cloneDeep(inputs)), { validDomain: `{{state.${constants_3.ComponentNames.TeamsBot}.domain}}` });
            const appManifest = typedi_1.Container.get(constants_3.ComponentNames.AppManifest);
            return await appManifest.addCapability(clonedInputs, [manifestCapability], isM365);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.AddFeature,
            telemetryComponentName: constants_3.ComponentNames.TeamsBot,
            errorSource: "BT",
            errorHandler: (error) => {
                if (error && !(error === null || error === void 0 ? void 0 : error.name)) {
                    error.name = "addBotError";
                }
                return error;
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsBot.prototype, "add", null);
TeamsBot = tslib_1.__decorate([
    typedi_1.Service(constants_3.ComponentNames.TeamsBot)
], TeamsBot);
exports.TeamsBot = TeamsBot;
/**
 *
 *   capability = Notification
 *     bot-host-type-trigger = http-restify
 *       group=bot, scenario=notification-restify, host=app-service
 *     bot-host-type-trigger = [http-functions, timer-functions]
 *       group=bot, host=function, scenario=notification-function-base + [notification-trigger-http, notification-trigger-timer]
 *   capability = command-bot:
 *     group=bot, host=app-service, scenario=command-and-response
 *   capability = workflow-bot:
 *     group=bot, host=app-service, scenario=workflow
 *   capability = Bot
 *     group=bot, host=app-service, scenario=default
 *   capability = MessagingExtension
 *     group=bot, host=app-service, scenario=default
 */
const featureToCapability = new Map([
    [constants_2.BotOptionItem().id, constants_1.BotCapabilities.BOT],
    [constants_2.MessageExtensionItem().id, constants_1.BotCapabilities.MESSAGE_EXTENSION],
    [constants_2.M365SearchAppOptionItem().id, constants_1.BotCapabilities.M365_SEARCH_APP],
    [constants_2.CommandAndResponseOptionItem().id, constants_1.BotCapabilities.COMMAND_AND_RESPONSE],
    [constants_2.NotificationOptionItem().id, constants_1.BotCapabilities.NOTIFICATION],
    [constants_2.WorkflowOptionItem().id, constants_1.BotCapabilities.WORKFLOW],
]);
const featureToScenario = new Map([
    [constants_2.BotOptionItem().id, () => [constants_1.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME]],
    [constants_2.NotificationOptionItem().id, (triggers) => resolveNotificationScenario(triggers)],
    [
        constants_2.CommandAndResponseOptionItem().id,
        () => [constants_1.TemplateProjectsScenarios.COMMAND_AND_RESPONSE_SCENARIO_NAME],
    ],
    [constants_2.WorkflowOptionItem().id, () => [constants_1.TemplateProjectsScenarios.WORKFLOW_SCENARIO_NAME]],
    [constants_2.MessageExtensionItem().id, () => [constants_1.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME]],
    [constants_2.M365SearchAppOptionItem().id, () => [constants_1.TemplateProjectsScenarios.M365_SCENARIO_NAME]],
]);
const triggersToScenarios = new Map([
    [question_2.AppServiceOptionItem.id, [constants_1.TemplateProjectsScenarios.NOTIFICATION_RESTIFY_SCENARIO_NAME]],
    [question_2.AppServiceOptionItemForVS.id, [constants_1.TemplateProjectsScenarios.NOTIFICATION_WEBAPI_SCENARIO_NAME]],
    [
        question_2.FunctionsHttpTriggerOptionItem.id,
        [
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_BASE_SCENARIO_NAME,
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_TRIGGER_HTTP_SCENARIO_NAME,
        ],
    ],
    [
        question_2.FunctionsTimerTriggerOptionItem.id,
        [
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_BASE_SCENARIO_NAME,
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_TRIGGER_TIMER_SCENARIO_NAME,
        ],
    ],
    [
        question_2.FunctionsHttpAndTimerTriggerOptionItem.id,
        [
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_BASE_SCENARIO_NAME,
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_TRIGGER_HTTP_SCENARIO_NAME,
            constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_TRIGGER_TIMER_SCENARIO_NAME,
        ],
    ],
]);
const resolveNotificationScenario = (triggers) => {
    if (typeof triggers !== "string") {
        return [];
    }
    return triggersToScenarios.get(triggers) || [];
};
const resolveHosting = (inputs) => {
    let hosting = "azure-web-app";
    const triggers = inputs[constants_1.QuestionNames.BOT_HOST_TYPE_TRIGGER];
    if ((triggers === null || triggers === void 0 ? void 0 : triggers.includes(question_2.FunctionsHttpTriggerOptionItem.id)) ||
        (triggers === null || triggers === void 0 ? void 0 : triggers.includes(question_2.FunctionsTimerTriggerOptionItem.id)) ||
        (triggers === null || triggers === void 0 ? void 0 : triggers.includes(question_2.FunctionsHttpAndTimerTriggerOptionItem.id))) {
        hosting = "azure-function";
    }
    return hosting;
};
//# sourceMappingURL=bot.js.map