"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApimFeature = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const projectSettingsHelperV3_1 = require("../../common/projectSettingsHelperV3");
const utils_1 = require("../../common/utils");
const constants_1 = require("../constants");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const answer_1 = require("../resource/apim/answer");
const config_1 = require("../resource/apim/config");
const constants_3 = require("../resource/apim/constants");
const factory_1 = require("../resource/apim/factory");
const utils_2 = require("../utils");
const workflow_1 = require("../workflow");
let ApimFeature = class ApimFeature {
    constructor() {
        this.name = constants_2.ComponentNames.APIMFeature;
    }
    async add(context, inputs) {
        const component = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.APIM);
        if (component)
            return teamsfx_api_1.ok(undefined);
        const addedResources = [];
        const effects = [];
        const hasFunc = projectSettingsHelperV3_1.hasApi(context.projectSetting);
        // 1. call teams-api.add if necessary
        if (!hasFunc) {
            const teamsApi = typedi_1.Container.get(constants_2.ComponentNames.TeamsApi);
            const res = await teamsApi.add(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("add teams-api");
            addedResources.push(constants_1.AzureResourceFunction.id);
        }
        // 2. scaffold
        {
            const codeRes = await this.generateCode(context, inputs);
            if (codeRes.isErr())
                return teamsfx_api_1.err(codeRes.error);
            effects.push("scaffold api doc");
        }
        // 3. config
        const apimConfig = {
            name: constants_2.ComponentNames.APIM,
            provision: true,
            deploy: true,
            connections: [],
        };
        context.projectSetting.components.push(apimConfig);
        effects.push(messages_1.Plans.addFeature("apim"));
        // 4. bicep.init
        {
            const bicepComponent = typedi_1.Container.get("bicep");
            const res = await bicepComponent.init(inputs.projectPath);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 5. apim.generateBicep
        {
            const apimResource = typedi_1.Container.get(constants_2.ComponentNames.APIM);
            const res = await apimResource.generateBicep(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            const bicepRes = await utils_2.bicepUtils.persistBiceps(inputs.projectPath, utils_1.convertToAlphanumericOnly(context.projectSetting.appName), res.value);
            if (bicepRes.isErr())
                return teamsfx_api_1.err(bicepRes.error);
        }
        // 6. generate config bicep
        {
            const res = await utils_2.generateConfigBiceps(context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            effects.push("generate config biceps");
        }
        effects.push("generate bicep");
        addedResources.push(constants_1.AzureResourceApim.id);
        utils_2.addFeatureNotify(inputs, context.userInteraction, "Resource", addedResources);
        return teamsfx_api_1.ok(undefined);
    }
    async generateCode(context, inputs, actionContext) {
        var _a;
        const apimConfig = new config_1.ApimPluginConfig({}, "");
        const answer = answer_1.buildAnswer(inputs);
        const scaffoldManager = await factory_1.Factory.buildScaffoldManager(context.telemetryReporter, context.logProvider);
        const appName = utils_1.convertToAlphanumericOnly(context.projectSetting.appName);
        if (answer.validate) {
            await answer.validate(constants_3.PluginLifeCycle.Scaffold, apimConfig, inputs.projectPath);
        }
        answer.save(constants_3.PluginLifeCycle.Scaffold, apimConfig);
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(constants_3.ProgressMessages[constants_3.ProgressStep.Scaffold].Scaffold));
        await scaffoldManager.scaffold(appName, inputs.projectPath);
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: "APIM",
            enableTelemetry: true,
            telemetryComponentName: "fx-resource-apim",
            telemetryEventName: "scaffold",
            enableProgressBar: true,
            progressTitle: constants_3.ProgressStep.Scaffold,
            progressSteps: Object.keys(constants_3.ProgressMessages[constants_3.ProgressStep.Scaffold]).length,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ApimFeature.prototype, "generateCode", null);
ApimFeature = tslib_1.__decorate([
    typedi_1.Service(constants_2.ComponentNames.APIMFeature)
], ApimFeature);
exports.ApimFeature = ApimFeature;
//# sourceMappingURL=apim.js.map