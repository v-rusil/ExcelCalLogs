"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipFolder = exports.getSampleRelativePath = exports.getSampleInfoFromName = exports.renderTemplateFileName = exports.renderTemplateFileData = exports.unzip = exports.fetchZipFromUrl = exports.fetchTemplateZipUrl = exports.fetchTagList = exports.templateVersion = void 0;
const tslib_1 = require("tslib");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const constant_1 = require("./constant");
const samples_1 = require("../../common/samples");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const os_1 = require("os");
const templates_config_json_1 = tslib_1.__importDefault(require("../../common/templates-config.json"));
const samples_config_v3_json_1 = tslib_1.__importDefault(require("../../common/samples-config-v3.json"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const preRelease = process.env.TEAMSFX_TEMPLATE_PRERELEASE || "";
const templateVersion = () => templates_config_json_1.default.version;
exports.templateVersion = templateVersion;
const templateTagPrefix = templates_config_json_1.default.tagPrefix;
const templateTagListURL = templates_config_json_1.default.tagListURL;
function selectTemplateTag(tags) {
    if (preRelease === "alpha") {
        return constant_1.templateAlphaVersion;
    }
    const versionPattern = preRelease ? `0.0.0-${preRelease}` : exports.templateVersion();
    // To avoid incompatible, alpha release does not download latest template.
    if (versionPattern === constant_1.templateAlphaVersion) {
        return undefined;
    }
    const versionList = tags.map((tag) => tag.replace(templateTagPrefix, ""));
    const selectedVersion = semver_1.default.maxSatisfying(versionList, versionPattern);
    return selectedVersion ? templateTagPrefix + selectedVersion : undefined;
}
async function sendRequestWithRetry(requestFn, tryLimits) {
    var _a;
    // !status means network error, see https://github.com/axios/axios/issues/383
    const canTry = (status) => !status || (status >= 500 && status < 600);
    let status;
    let error;
    for (let i = 0; i < tryLimits && canTry(status); i++) {
        try {
            const res = await requestFn();
            if (res.status === 200 || res.status === 201) {
                return res;
            }
            error = new Error(`HTTP Request failed: ${JSON.stringify(res)}`);
            status = res.status;
        }
        catch (e) {
            error = e;
            status = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status;
        }
    }
    error !== null && error !== void 0 ? error : (error = new Error(`RequestWithRetry got bad tryLimits: ${tryLimits}`));
    throw error;
}
async function sendRequestWithTimeout(requestFn, timeoutInMs, tryLimits = 1) {
    const source = axios_1.default.CancelToken.source();
    const timeout = setTimeout(() => {
        source.cancel();
    }, timeoutInMs);
    try {
        const res = await sendRequestWithRetry(() => requestFn(source.token), tryLimits);
        clearTimeout(timeout);
        return res;
    }
    catch (err) {
        if (axios_1.default.isCancel(err)) {
            throw new Error("Request timeout");
        }
        throw err;
    }
}
async function fetchTagList(url, tryLimits, timeoutInMs) {
    const res = await sendRequestWithTimeout(async (cancelToken) => {
        return await axios_1.default.get(url, {
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    return res.data;
}
exports.fetchTagList = fetchTagList;
async function fetchTemplateZipUrl(name, tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const tags = await fetchTagList(templateTagListURL, tryLimits, timeoutInMs);
    const selectedTag = selectTemplateTag(tags.replace(/\r/g, "").split("\n"));
    if (!selectedTag) {
        throw new Error(`Failed to find valid template for ${name}`);
    }
    return `${templates_config_json_1.default.templateDownloadBaseURL}/${selectedTag}/${name}.zip`;
}
exports.fetchTemplateZipUrl = fetchTemplateZipUrl;
async function fetchZipFromUrl(url, tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const res = await sendRequestWithTimeout(async (cancelToken) => {
        return await axios_1.default.get(url, {
            responseType: "arraybuffer",
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    const zip = new adm_zip_1.default(res.data);
    return zip;
}
exports.fetchZipFromUrl = fetchZipFromUrl;
/* The unzip used for scaffold which would drop the attr of the files and dirs. */
async function unzip(zip, dstPath, nameReplaceFn, dataReplaceFn, relativePath, filesInAppendMode = [".gitignore"]) {
    let entries = zip.getEntries().filter((entry) => !entry.isDirectory);
    if (relativePath) {
        entries = entries.filter((entry) => entry.entryName.startsWith(relativePath));
    }
    for (const entry of entries) {
        const rawEntryData = entry.getData();
        let entryName = nameReplaceFn
            ? nameReplaceFn(entry.entryName, rawEntryData)
            : entry.entryName;
        if (relativePath) {
            entryName = entryName.replace(relativePath, "");
        }
        const entryData = dataReplaceFn
            ? dataReplaceFn(entry.name, rawEntryData)
            : rawEntryData;
        const filePath = path_1.default.join(dstPath, entryName);
        const dirPath = path_1.default.dirname(filePath);
        await fs.ensureDir(dirPath);
        if (filesInAppendMode.includes(entryName) && (await fs.pathExists(filePath))) {
            await fs.appendFile(filePath, os_1.EOL);
            await fs.appendFile(filePath, entryData);
        }
        else {
            await fs.writeFile(filePath, entryData);
        }
    }
}
exports.unzip = unzip;
function renderTemplateFileData(fileName, fileData, variables) {
    //only mustache files with name ending with .tpl
    if (path_1.default.extname(fileName) === constant_1.templateFileExt) {
        return mustache_1.default.render(fileData.toString(), variables, {}, constant_1.placeholderDelimiters);
    }
    // Return Buffer instead of string if the file is not a template. Because `toString()` may break binary resources, like png files.
    return fileData;
}
exports.renderTemplateFileData = renderTemplateFileData;
function renderTemplateFileName(fileName, fileData, variables) {
    return mustache_1.default.render(fileName, variables, {}, constant_1.placeholderDelimiters).replace(constant_1.templateFileExt, "");
}
exports.renderTemplateFileName = renderTemplateFileName;
function getSampleInfoFromName(sampleName) {
    const sample = samples_1.sampleProvider.SampleCollection.samples.find((sample) => sample.id.toLowerCase() === sampleName.toLowerCase());
    if (!sample) {
        throw Error(`invalid sample name: '${sampleName}'`);
    }
    return sample;
}
exports.getSampleInfoFromName = getSampleInfoFromName;
function getSampleRelativePath(sampleName) {
    return `${samples_config_v3_json_1.default.baseFolderName}/${sampleName}/`;
}
exports.getSampleRelativePath = getSampleRelativePath;
function zipFolder(folderPath) {
    const zip = new adm_zip_1.default();
    zip.addLocalFolder(folderPath);
    return zip;
}
exports.zipFolder = zipFolder;
//# sourceMappingURL=utils.js.map