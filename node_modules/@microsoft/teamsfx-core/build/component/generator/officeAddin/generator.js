"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficeAddinGenerator = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = require("path");
const question_1 = require("./question");
const helperMethods_1 = require("./helperMethods");
const office_addin_manifest_1 = require("office-addin-manifest");
const projectsJsonData_1 = tslib_1.__importDefault(require("./config/projectsJsonData"));
const childProcess = tslib_1.__importStar(require("child_process"));
const util_1 = require("util");
const error_1 = require("../../../core/error");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const generator_1 = require("../generator");
const question_2 = require("../../../core/question");
const childProcessExec = util_1.promisify(childProcess.exec);
const componentName = "office-addin";
const telemetryEvent = "generate";
const templateName = "office-addin";
class OfficeAddinGenerator {
    static async generate(context, inputs, destinationPath) {
        const result = await OfficeAddinGenerator.doScaffolding(context, inputs, destinationPath);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        // If lang is undefined, it means the project is created from a folder.
        const lang = inputs[question_1.AddinLanguageQuestion.name];
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, templateName, lang ? (lang === "TypeScript" ? "ts" : "js") : undefined);
        if (templateRes.isErr())
            return teamsfx_api_1.err(templateRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    static async doScaffolding(context, inputs, destinationPath) {
        const template = question_1.getTemplate(inputs);
        const name = inputs[question_2.CoreQuestionNames.AppName];
        const addinRoot = destinationPath;
        const fromFolder = inputs[question_1.AddinProjectFolderQuestion.name];
        const language = inputs[question_1.AddinLanguageQuestion.name];
        const host = inputs[question_1.OfficeHostQuestion.name];
        const workingDir = process.cwd();
        process.chdir(addinRoot);
        try {
            if (!fromFolder) {
                const jsonData = new projectsJsonData_1.default();
                const projectRepoBranchInfo = jsonData.getProjectRepoAndBranch(template, language, true);
                // Copy project template files from project repository
                if (projectRepoBranchInfo.repo) {
                    await helperMethods_1.HelperMethods.downloadProjectTemplateZipFile(addinRoot, projectRepoBranchInfo.repo, projectRepoBranchInfo.branch);
                    // Call 'convert-to-single-host' npm script in generated project, passing in host parameter
                    const cmdLine = `npm run convert-to-single-host --if-present -- ${lodash_1.default.toLower(host)}`;
                    await childProcessExec(cmdLine);
                    // modify manifest guid and DisplayName
                    await office_addin_manifest_1.OfficeAddinManifest.modifyManifestFile(`${path_1.join(addinRoot, jsonData.getManifestPath(template))}`, "random", `${name}`);
                }
            }
            else {
                helperMethods_1.HelperMethods.copyAddinFiles(fromFolder, addinRoot);
                const manifestFile = inputs[question_1.AddinProjectManifestQuestion.name];
                inputs[question_1.OfficeHostQuestion.name] = await getHost(manifestFile);
                helperMethods_1.HelperMethods.updateManifest(destinationPath, manifestFile);
                // TODO: After able to sideload using shared manifest we can then delete manifest file in subfolder
                // => join(addinRoot, "manifest.json"); but figure out the actual path in the new location
            }
            process.chdir(workingDir);
            return teamsfx_api_1.ok(undefined);
        }
        catch (e) {
            process.chdir(workingDir);
            return teamsfx_api_1.err(error_1.CopyFileError(e));
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: componentName,
            telemetryEventName: telemetryEvent,
            errorSource: componentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], OfficeAddinGenerator, "generate", null);
exports.OfficeAddinGenerator = OfficeAddinGenerator;
async function getHost(addinManifestPath) {
    var _a, _b, _c;
    // Read add-in manifest file
    const addinManifest = await teamsfx_api_1.ManifestUtil.loadFromPath(addinManifestPath);
    let host = "Outlook";
    switch ((_c = (_b = (_a = addinManifest.extensions) === null || _a === void 0 ? void 0 : _a[0].requirements) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c[0]) {
        // case "document":
        //   host = "Word";
        case "mail":
            host = "Outlook";
        // case "notebook":
        //   host = "OneNote";
        // case "presentation":
        //   host = "PowerPoint";
        // case "project":
        //   host = "Project";
        // case "workbook":
        //   host = "Excel";
    }
    return host;
}
//# sourceMappingURL=generator.js.map