"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleDefaultOnActionError = exports.templateDefaultOnActionError = exports.Generator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const telemetry_1 = require("../../common/telemetry");
const utils_1 = require("../../common/utils");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const constant_1 = require("./constant");
const error_1 = require("./error");
const generatorAction_1 = require("./generatorAction");
const utils_2 = require("./utils");
class Generator {
    static getDefaultVariables(appName) {
        return {
            appName: appName,
            ProjectName: appName,
            SafeProjectName: utils_1.convertToAlphanumericOnly(appName),
        };
    }
    static async generateTemplate(ctx, destinationPath, scenario, language, actionContext) {
        var _a, _b;
        const replaceMap = (_a = ctx.templateVariables) !== null && _a !== void 0 ? _a : {};
        const generatorContext = {
            name: language !== null && language !== void 0 ? language : constant_1.commonTemplateName,
            relativePath: `${scenario}/`,
            destination: destinationPath,
            logProvider: ctx.logProvider,
            fileNameReplaceFn: (fileName, fileData) => utils_2.renderTemplateFileName(fileName, fileData, replaceMap),
            fileDataReplaceFn: (fileName, fileData) => utils_2.renderTemplateFileData(fileName, fileData, replaceMap),
            onActionError: templateDefaultOnActionError,
        };
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.TemplateName]: `${scenario}-${generatorContext.name}`,
        });
        await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_1.ProgressMessages.generateTemplate()));
        await this.generate(generatorContext, generatorAction_1.TemplateActionSeq);
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Fallback]: generatorContext.fallbackZipPath ? "true" : "false", // Track fallback cases.
        });
        return teamsfx_api_1.ok(undefined);
    }
    static async generateSample(ctx, destinationPath, sampleName, actionContext) {
        var _a, _b;
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.SampleName]: sampleName,
        });
        const sample = utils_2.getSampleInfoFromName(sampleName);
        // sample doesn't need replace function. Replacing projectId will be handled by core.
        const generatorContext = {
            name: sampleName,
            destination: destinationPath,
            logProvider: ctx.logProvider,
            zipUrl: sample.link,
            timeoutInMs: constant_1.sampleDefaultTimeoutInMs,
            relativePath: (_a = sample.relativePath) !== null && _a !== void 0 ? _a : utils_2.getSampleRelativePath(sampleName),
            onActionError: sampleDefaultOnActionError,
        };
        await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_1.ProgressMessages.generateSample()));
        await this.generate(generatorContext, generatorAction_1.SampleActionSeq);
        return teamsfx_api_1.ok(undefined);
    }
    static async generate(context, actions) {
        var _a, _b;
        for (const action of actions) {
            try {
                await ((_a = context.onActionStart) === null || _a === void 0 ? void 0 : _a.call(context, action, context));
                await action.run(context);
                await ((_b = context.onActionEnd) === null || _b === void 0 ? void 0 : _b.call(context, action, context));
            }
            catch (e) {
                if (!context.onActionError) {
                    throw e;
                }
                if (e instanceof Error)
                    await context.onActionError(action, context, e);
            }
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.generateTemplate,
            progressSteps: 1,
            componentName: constant_1.componentName,
            errorSource: constant_1.errorSource,
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.GenerateTemplate,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Generator, "generateTemplate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.generateSample,
            progressSteps: 1,
            componentName: constant_1.componentName,
            errorSource: constant_1.errorSource,
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.GenerateSample,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Generator, "generateSample", null);
exports.Generator = Generator;
async function templateDefaultOnActionError(action, context, error) {
    switch (action.name) {
        case generatorAction_1.GeneratorActionName.FetchTemplateUrlWithTag:
        case generatorAction_1.GeneratorActionName.FetchZipFromUrl:
            await context.logProvider.info(error.message);
            await context.logProvider.info(messages_1.LogMessages.getTemplateFromLocal);
            break;
        case generatorAction_1.GeneratorActionName.FetchTemplateZipFromLocal:
            await context.logProvider.error(error.message);
            throw new error_1.TemplateZipFallbackError().toFxError();
        case generatorAction_1.GeneratorActionName.Unzip:
            await context.logProvider.error(error.message);
            throw new error_1.UnzipError().toFxError();
        default:
            throw new Error(error.message);
    }
}
exports.templateDefaultOnActionError = templateDefaultOnActionError;
async function sampleDefaultOnActionError(action, context, error) {
    await context.logProvider.error(error.message);
    switch (action.name) {
        case generatorAction_1.GeneratorActionName.FetchZipFromUrl:
            throw new error_1.FetchZipFromUrlError(context.zipUrl).toFxError();
        case generatorAction_1.GeneratorActionName.Unzip:
            throw new error_1.UnzipError().toFxError();
        default:
            throw new Error(error.message);
    }
}
exports.sampleDefaultOnActionError = sampleDefaultOnActionError;
//# sourceMappingURL=generator.js.map