"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsForInit = exports.InitInfraProceedQuestion = exports.InitDebugProceedQuestion = exports.InitIsSPFxQuestion = exports.InitCapabilityQuestion = exports.InitEditorQuestion = exports.InitOptionNo = exports.InitOptionYes = exports.InitCapabilityBot = exports.InitCapabilityTab = exports.InitEditorVS = exports.InitEditorVSCode = exports.SelectEnvQuestion = exports.getUserEmailQuestion = exports.AskSubscriptionQuestion = exports.DeployPluginSelectQuestion = exports.addCapabilityQuestion = exports.createAddCloudResourceOptions = exports.createAddAzureResourceQuestion = exports.getPlatformRuntime = exports.getPluginCLIName = exports.getNotificationTriggerQuestionNode = exports.getQuestionsForAddFeatureSubCommand = exports.getActionNameByFeatureId = exports.FeatureIdToComponent = exports.FeatureId = exports.getQuestionsForAddResourceV3 = exports.getQuestionsForAddFeatureV3 = exports.checkWetherProvisionSucceeded = exports.getQuestionsForDeployV3 = exports.getQuestionsForProvisionV3 = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const tools_1 = require("../common/tools");
const constants_2 = require("./constants");
const migrate_1 = require("./migrate");
const workflow_1 = require("./workflow");
const constants_3 = require("./resource/appManifest/constants");
const question_1 = require("./feature/bot/question");
const error_1 = require("../core/error");
const question_2 = require("../core/question");
const utils_1 = require("./utils");
const featureFlags_1 = require("../common/featureFlags");
const questions_1 = require("./resource/azureSql/questions");
const ApiConnectorImpl_1 = require("./feature/apiconnector/ApiConnectorImpl");
const questions_2 = require("./resource/spfx/utils/questions");
const apim_1 = require("./resource/apim/apim");
const sso_1 = require("./feature/sso");
const cicd_1 = require("./feature/cicd/cicd");
const error_2 = require("./error");
const ManifestUtils_1 = require("./resource/appManifest/utils/ManifestUtils");
const spfx_1 = require("./feature/spfx");
const constants_4 = require("./resource/aadApp/constants");
const question_3 = require("./feature/api/question");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
async function getQuestionsForProvisionV3(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        const node = new teamsfx_api_1.QTreeNode({ type: "group" });
        node.addChild(new teamsfx_api_1.QTreeNode(exports.AskSubscriptionQuestion));
        node.addChild(questions_1.buildQuestionNode());
        return teamsfx_api_1.ok(node);
    }
    else {
        // const node = new QTreeNode({ type: "group" });
        // if (hasAzureResourceV3(context.projectSetting as ProjectSettingsV3)) {
        //   node.addChild(new QTreeNode(AskSubscriptionQuestion));
        // }
        // return ok(node);
        return teamsfx_api_1.ok(undefined);
    }
}
exports.getQuestionsForProvisionV3 = getQuestionsForProvisionV3;
async function getQuestionsForDeployV3(ctx, inputs, envInfo) {
    //VS project has no selection interaction, and will deploy all selectable components by default.
    if (projectSettingsHelper_1.isVSProject(ctx.projectSetting)) {
        return teamsfx_api_1.ok(undefined);
    }
    if (inputs.platform === teamsfx_api_1.Platform.VSCode && inputs[constants_4.Constants.INCLUDE_AAD_MANIFEST] === "yes") {
        return teamsfx_api_1.ok(undefined);
    }
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    const projectSetting = ctx.projectSetting;
    const deployableComponents = [
        constants_2.ComponentNames.TeamsTab,
        constants_2.ComponentNames.TeamsBot,
        constants_2.ComponentNames.TeamsApi,
        constants_2.ComponentNames.APIM,
        constants_2.ComponentNames.AppManifest,
    ];
    const componentDisplayNames = {
        [constants_2.ComponentNames.TeamsTab]: "NodeJS Tab frontend",
        [constants_2.ComponentNames.TeamsBot]: "Bot",
        [constants_2.ComponentNames.TeamsApi]: "Azure Function",
        [constants_2.ComponentNames.APIM]: "API Management",
        [constants_2.ComponentNames.AppManifest]: "App Studio",
        [constants_2.ComponentNames.AadApp]: "AAD",
    };
    if (teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
        deployableComponents.push(constants_2.ComponentNames.AadApp);
    }
    let selectableComponents;
    if (!isDynamicQuestion) {
        selectableComponents = deployableComponents;
    }
    else {
        const hasAzureResource = projectSettingsHelperV3_1.hasAzureResourceV3(projectSetting);
        const provisioned = checkWetherProvisionSucceeded(envInfo.state);
        if (hasAzureResource && !provisioned) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                source: "Solution",
                name: "CannotDeployBeforeProvision",
                message: localizeUtils_1.getDefaultString("core.deploy.FailedToDeployBeforeProvision"),
                displayMessage: localizeUtils_1.getLocalizedString("core.deploy.FailedToDeployBeforeProvision"),
                helpLink: constants_1.HelpLinks.WhyNeedProvision,
            }));
        }
        selectableComponents = projectSetting.components
            .filter((component) => component.deploy && deployableComponents.includes(component.name))
            .map((component) => component.name);
        if (teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
            selectableComponents.push(constants_2.ComponentNames.AppManifest);
        }
    }
    const options = selectableComponents.map((c) => {
        const pluginName = migrate_1.ComponentName2pluginName(c);
        const item = {
            id: pluginName,
            label: componentDisplayNames[c],
            cliName: getPluginCLIName(pluginName),
        };
        return item;
    });
    if (options.length === 0) {
        return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.deploy));
    }
    const selectQuestion = exports.DeployPluginSelectQuestion;
    selectQuestion.staticOptions = options;
    selectQuestion.default = options.map((i) => i.id);
    const node = new teamsfx_api_1.QTreeNode(selectQuestion);
    if (selectableComponents.includes(constants_2.ComponentNames.APIM)) {
        const resourceContext = ctx;
        resourceContext.envInfo = envInfo;
        resourceContext.tokenProvider = ctx.tokenProvider;
        const apimDeployNodeRes = await apim_1.getQuestionsForDeployAPIM(resourceContext, inputs);
        if (apimDeployNodeRes.isErr())
            return teamsfx_api_1.err(apimDeployNodeRes.error);
        if (apimDeployNodeRes.value) {
            const apimNode = apimDeployNodeRes.value;
            apimNode.condition = { contains: constants_2.BuiltInFeaturePluginNames.apim };
            node.addChild(apimNode);
        }
    }
    if (selectableComponents.includes(constants_2.ComponentNames.AadApp)) {
        const aadNode = new teamsfx_api_1.QTreeNode({
            name: constants_4.Constants.INCLUDE_AAD_MANIFEST,
            type: "singleSelect",
            staticOptions: ["yes", "no"],
            title: localizeUtils_1.getLocalizedString("core.aad.includeAadQuestionTitle"),
            default: "no",
        });
        node.addChild(aadNode);
        if (teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
            // this question only works on CLI.
            const aadManifestFilePathNode = new teamsfx_api_1.QTreeNode({
                name: constants_4.Constants.AAD_MANIFEST_FILE,
                type: "singleFile",
                title: localizeUtils_1.getLocalizedString("core.aad.aadManifestFilePath"),
                default: "",
            });
            node.addChild(aadManifestFilePathNode);
        }
    }
    if (selectableComponents.includes(constants_2.ComponentNames.AppManifest)) {
        const appManifestNode = new teamsfx_api_1.QTreeNode({
            name: constants_3.Constants.INCLUDE_APP_MANIFEST,
            type: "singleSelect",
            staticOptions: ["yes", "no"],
            title: localizeUtils_1.getLocalizedString("plugins.appstudio.whetherToDeployManifest"),
            default: "no",
        });
        node.addChild(appManifestNode);
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForDeployV3 = getQuestionsForDeployV3;
function checkWetherProvisionSucceeded(config) {
    return config[constants_2.GLOBAL_CONFIG] && config[constants_2.GLOBAL_CONFIG][constants_2.SOLUTION_PROVISION_SUCCEEDED];
}
exports.checkWetherProvisionSucceeded = checkWetherProvisionSucceeded;
async function getQuestionsForAddFeatureV3(ctx, inputs) {
    var _a, _b, _c, _d;
    // AB test for notification/command/workflow bot template naming
    const notificationOptionItem = constants_2.NotificationOptionItem();
    const commandAndResponseOptionItem = constants_2.CommandAndResponseOptionItem();
    const workflowOptionItem = constants_2.WorkflowOptionItem();
    if (inputs === null || inputs === void 0 ? void 0 : inputs.taskOrientedTemplateNaming) {
        notificationOptionItem.label = `$(hubot) ${localizeUtils_1.getLocalizedString("core.NotificationOption.label.abTest")}`;
        notificationOptionItem.detail = localizeUtils_1.getLocalizedString("core.NotificationOption.detail.abTest");
        commandAndResponseOptionItem.label = `$(hubot) ${localizeUtils_1.getLocalizedString("core.CommandAndResponseOption.label.abTest")}`;
        commandAndResponseOptionItem.detail = localizeUtils_1.getLocalizedString("core.CommandAndResponseOption.detail.abTest");
        workflowOptionItem.label = `$(hubot) ${localizeUtils_1.getLocalizedString("core.WorkflowOption.label.abTest")}`;
        workflowOptionItem.detail = localizeUtils_1.getLocalizedString("core.WorkflowOption.detail.abTest");
    }
    const question = {
        name: constants_2.AzureSolutionQuestionNames.Features,
        title: localizeUtils_1.getLocalizedString("core.addFeatureQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
    };
    const options = [];
    question.staticOptions = options;
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        options.push(notificationOptionItem);
        options.push(commandAndResponseOptionItem);
        options.push(workflowOptionItem);
        options.push(constants_2.BotNewUIOptionItem());
        options.push(constants_2.TabNewUIOptionItem(), constants_2.TabNonSsoItem());
        options.push(constants_2.MessageExtensionNewUIItem());
        options.push(constants_2.AzureResourceApimNewUI);
        options.push(constants_2.AzureResourceSQLNewUI);
        options.push(constants_2.AzureResourceFunctionNewUI);
        options.push(constants_2.AzureResourceKeyVaultNewUI);
        options.push(constants_2.SingleSignOnOptionItem);
        options.push(constants_2.ApiConnectionOptionItem);
        options.push(constants_2.CicdOptionItem);
        const addFeatureNode = new teamsfx_api_1.QTreeNode(question);
        const triggerNodeRes = await getNotificationTriggerQuestionNode(inputs);
        if (triggerNodeRes.isErr())
            return teamsfx_api_1.err(triggerNodeRes.error);
        if (triggerNodeRes.value) {
            addFeatureNode.addChild(triggerNodeRes.value);
        }
        const functionNameNode = new teamsfx_api_1.QTreeNode(question_3.functionNameQuestion);
        functionNameNode.condition = { equals: constants_2.AzureResourceFunctionNewUI.id };
        addFeatureNode.addChild(functionNameNode);
        return teamsfx_api_1.ok(addFeatureNode);
    }
    // check capability options
    const azureHost = projectSettingsHelperV3_1.hasAzureResourceV3(ctx.projectSetting);
    if (azureHost) {
        const manifestRes = await ManifestUtils_1.manifestUtils.readAppManifest(inputs.projectPath);
        if (manifestRes.isErr())
            return teamsfx_api_1.err(manifestRes.error);
        const manifest = manifestRes.value;
        const canAddTab = !manifest.staticTabs || manifest.staticTabs.length < constants_3.STATIC_TABS_MAX_ITEMS;
        const botExceedLimit = !manifest.bots || manifest.bots.length > 0;
        const meExceedLimit = !manifest.composeExtensions || manifest.composeExtensions.length > 0;
        const projectSettingsV3 = ctx.projectSetting;
        const teamsBot = workflow_1.getComponent(ctx.projectSetting, constants_2.ComponentNames.TeamsBot);
        const alreadyHasNewBot = ((_a = teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.capabilities) === null || _a === void 0 ? void 0 : _a.includes("notification")) ||
            ((_b = teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.capabilities) === null || _b === void 0 ? void 0 : _b.includes("command-response")) ||
            ((_c = teamsBot === null || teamsBot === void 0 ? void 0 : teamsBot.capabilities) === null || _c === void 0 ? void 0 : _c.includes("workflow"));
        if (!botExceedLimit && !meExceedLimit) {
            options.push(notificationOptionItem);
            options.push(commandAndResponseOptionItem);
            options.push(workflowOptionItem);
        }
        if (canAddTab) {
            if (!projectSettingsHelperV3_1.hasTab(projectSettingsV3)) {
                options.push(constants_2.TabNewUIOptionItem(), constants_2.TabNonSsoItem());
            }
            else {
                options.push(projectSettingsHelperV3_1.hasAAD(projectSettingsV3) ? constants_2.TabNewUIOptionItem() : constants_2.TabNonSsoItem());
            }
        }
        if (!botExceedLimit) {
            options.push(constants_2.BotNewUIOptionItem());
        }
        if (!meExceedLimit && !alreadyHasNewBot) {
            options.push(constants_2.MessageExtensionNewUIItem());
        }
        // function can always be added
        options.push(constants_2.AzureResourceFunctionNewUI);
        // check cloud resource options
        if (!projectSettingsHelperV3_1.hasAPIM(projectSettingsV3)) {
            options.push(constants_2.AzureResourceApimNewUI);
        }
        options.push(constants_2.AzureResourceSQLNewUI);
        if (!projectSettingsHelperV3_1.hasKeyVault(projectSettingsV3)) {
            options.push(constants_2.AzureResourceKeyVaultNewUI);
        }
        if (sso_1.canAddSso(ctx.projectSetting) === true) {
            options.push(constants_2.SingleSignOnOptionItem);
        }
        if (projectSettingsHelperV3_1.hasBot(projectSettingsV3) || projectSettingsHelperV3_1.hasApi(projectSettingsV3)) {
            options.push(constants_2.ApiConnectionOptionItem);
        }
    }
    else if (featureFlags_1.isSPFxMultiTabEnabled() &&
        ((_d = ctx.projectSetting.solutionSettings) === null || _d === void 0 ? void 0 : _d.hostType) === constants_2.HostTypeOptionSPFx().id) {
        options.push(constants_2.TabSPFxNewUIItem());
    }
    const isCicdAddable = await tools_1.canAddCICDWorkflows(inputs, ctx);
    if (isCicdAddable) {
        options.push(constants_2.CicdOptionItem);
    }
    const addFeatureNode = new teamsfx_api_1.QTreeNode(question);
    const functionNameNode = new teamsfx_api_1.QTreeNode(question_3.functionNameQuestion);
    functionNameNode.condition = { equals: constants_2.AzureResourceFunctionNewUI.id };
    addFeatureNode.addChild(functionNameNode);
    const triggerNodeRes = await getNotificationTriggerQuestionNode(inputs);
    if (triggerNodeRes.isErr())
        return teamsfx_api_1.err(triggerNodeRes.error);
    if (triggerNodeRes.value) {
        addFeatureNode.addChild(triggerNodeRes.value);
    }
    const addSPFxNodeRes = await spfx_1.getAddSPFxQuestionNode(inputs.projectPath);
    if (addSPFxNodeRes.isErr())
        return teamsfx_api_1.err(addSPFxNodeRes.error);
    if (addSPFxNodeRes.value) {
        addFeatureNode.addChild(addSPFxNodeRes.value);
    }
    if (!ctx.projectSetting.programmingLanguage) {
        // Language
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestion);
        programmingLanguage.condition = {
            enum: [
                notificationOptionItem.id,
                commandAndResponseOptionItem.id,
                workflowOptionItem.id,
                constants_2.TabNewUIOptionItem().id,
                constants_2.TabNonSsoItem().id,
                constants_2.BotNewUIOptionItem().id,
                constants_2.MessageExtensionItem().id,
                constants_2.SingleSignOnOptionItem.id, // adding sso means adding sample codes
            ],
        };
        addFeatureNode.addChild(programmingLanguage);
    }
    const SelectedFeature = inputs[constants_2.AzureSolutionQuestionNames.Features];
    if (SelectedFeature && !options.map((op) => op.id).includes(SelectedFeature)) {
        return teamsfx_api_1.err(new error_2.InvalidFeature());
    }
    return teamsfx_api_1.ok(addFeatureNode);
}
exports.getQuestionsForAddFeatureV3 = getQuestionsForAddFeatureV3;
async function getQuestionsForAddResourceV3(ctx, inputs) {
    const question = {
        name: constants_2.AzureSolutionQuestionNames.AddResources,
        title: localizeUtils_1.getLocalizedString("core.addFeatureQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
    };
    const options = [];
    question.staticOptions = options;
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        options.push(constants_2.AzureResourceApimNewUI);
        options.push(constants_2.AzureResourceSQLNewUI);
        options.push(constants_2.AzureResourceFunctionNewUI);
        options.push(constants_2.AzureResourceKeyVaultNewUI);
        const addResourceNode = new teamsfx_api_1.QTreeNode(question);
        const functionNameNode = new teamsfx_api_1.QTreeNode(question_3.functionNameQuestion);
        functionNameNode.condition = { equals: constants_2.AzureResourceFunctionNewUI.id };
        addResourceNode.addChild(functionNameNode);
        return teamsfx_api_1.ok(addResourceNode);
    }
    const projectSettingsV3 = ctx.projectSetting;
    if (!projectSettingsHelperV3_1.hasAPIM(projectSettingsV3)) {
        options.push(constants_2.AzureResourceApimNewUI);
    }
    options.push(constants_2.AzureResourceSQLNewUI);
    if (!projectSettingsHelperV3_1.hasKeyVault(projectSettingsV3)) {
        options.push(constants_2.AzureResourceKeyVaultNewUI);
    }
    // function can always be added
    options.push(constants_2.AzureResourceFunctionNewUI);
    const addResourceNode = new teamsfx_api_1.QTreeNode(question);
    const functionNameNode = new teamsfx_api_1.QTreeNode(question_3.functionNameQuestion);
    functionNameNode.condition = { equals: constants_2.AzureResourceFunctionNewUI.id };
    addResourceNode.addChild(functionNameNode);
    if (!ctx.projectSetting.programmingLanguage) {
        // Language
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestion);
        programmingLanguage.condition = {
            enum: [
                constants_2.NotificationOptionItem().id,
                constants_2.CommandAndResponseOptionItem().id,
                constants_2.WorkflowOptionItem().id,
                constants_2.TabNewUIOptionItem().id,
                constants_2.TabNonSsoItem().id,
                constants_2.BotNewUIOptionItem().id,
                constants_2.MessageExtensionItem().id,
                constants_2.SingleSignOnOptionItem.id, // adding sso means adding sample codes
            ],
        };
        addResourceNode.addChild(programmingLanguage);
    }
    return teamsfx_api_1.ok(addResourceNode);
}
exports.getQuestionsForAddResourceV3 = getQuestionsForAddResourceV3;
var FeatureId;
(function (FeatureId) {
    FeatureId["Tab"] = "Tab";
    FeatureId["TabNonSso"] = "TabNonSso";
    FeatureId["TabSPFx"] = "TabSPFx";
    FeatureId["Notification"] = "Notification";
    FeatureId["CommandAndResponse"] = "command-bot";
    FeatureId["Workflow"] = "workflow-bot";
    FeatureId["Bot"] = "Bot";
    FeatureId["MessagingExtension"] = "MessagingExtension";
    FeatureId["function"] = "function";
    FeatureId["apim"] = "apim";
    FeatureId["sql"] = "sql";
    FeatureId["keyvault"] = "keyvault";
    FeatureId["sso"] = "sso";
    FeatureId["ApiConnector"] = "api-connection";
    FeatureId["cicd"] = "cicd";
    FeatureId["M365SearchApp"] = "M365SearchApp";
    FeatureId["M365SsoLaunchPage"] = "M365SsoLaunchPage";
})(FeatureId = exports.FeatureId || (exports.FeatureId = {}));
exports.FeatureIdToComponent = {
    [FeatureId.Tab]: constants_2.ComponentNames.TeamsTab,
    [FeatureId.TabNonSso]: constants_2.ComponentNames.TeamsTab,
    [FeatureId.TabSPFx]: constants_2.ComponentNames.SPFxTab,
    [FeatureId.M365SsoLaunchPage]: constants_2.ComponentNames.TeamsTab,
    [FeatureId.Notification]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.CommandAndResponse]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.Workflow]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.Bot]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.M365SearchApp]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.MessagingExtension]: constants_2.ComponentNames.TeamsBot,
    [FeatureId.function]: constants_2.ComponentNames.TeamsApi,
    [FeatureId.apim]: constants_2.ComponentNames.APIMFeature,
    [FeatureId.sql]: constants_2.ComponentNames.AzureSQL,
    [FeatureId.keyvault]: constants_2.ComponentNames.KeyVault,
    [FeatureId.sso]: constants_2.ComponentNames.SSO,
    [FeatureId.ApiConnector]: constants_2.ComponentNames.ApiConnector,
    [FeatureId.cicd]: constants_2.ComponentNames.CICD,
};
function getActionNameByFeatureId(featureId) {
    const component = exports.FeatureIdToComponent[featureId];
    if (component) {
        return `${component}.add`;
    }
}
exports.getActionNameByFeatureId = getActionNameByFeatureId;
async function getQuestionsForAddFeatureSubCommand(featureId, inputs) {
    if (constants_2.BotFeatureIds().includes(featureId)) {
        return await getNotificationTriggerQuestionNode(inputs);
    }
    else if (constants_2.TabFeatureIds().includes(featureId)) {
    }
    else if (featureId === constants_2.TabSPFxNewUIItem().id) {
        return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(questions_2.webpartNameQuestion));
    }
    else if (featureId === constants_2.AzureResourceSQLNewUI.id) {
    }
    else if (featureId === constants_2.AzureResourceFunctionNewUI.id ||
        featureId === constants_2.AzureResourceApimNewUI.id) {
        question_3.functionNameQuestion.validation = undefined;
        return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(question_3.functionNameQuestion));
    }
    else if (featureId === constants_2.AzureResourceKeyVaultNewUI.id) {
    }
    else if (featureId === constants_2.CicdOptionItem.id) {
        return await cicd_1.addCicdQuestion(utils_1.createContextV3(), inputs);
    }
    else if (featureId === constants_2.ApiConnectionOptionItem.id) {
        const apiConnectorImpl = new ApiConnectorImpl_1.ApiConnectorImpl();
        return apiConnectorImpl.generateQuestion(utils_1.createContextV3(), inputs);
    }
    else if (featureId === constants_2.SingleSignOnOptionItem.id) {
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForAddFeatureSubCommand = getQuestionsForAddFeatureSubCommand;
async function getNotificationTriggerQuestionNode(inputs) {
    const res = new teamsfx_api_1.QTreeNode({
        type: "group",
    });
    if (featureFlags_1.isCLIDotNetEnabled()) {
        Object.values(constants_2.Runtime).forEach((runtime) => {
            const node = new teamsfx_api_1.QTreeNode(question_1.createHostTypeTriggerQuestion(inputs.platform, runtime));
            node.condition = question_1.getConditionOfNotificationTriggerQuestion(runtime);
            res.addChild(node);
        });
    }
    else {
        const runtime = getPlatformRuntime(inputs.platform);
        const node = new teamsfx_api_1.QTreeNode(question_1.createHostTypeTriggerQuestion(inputs.platform, runtime));
        res.addChild(node);
    }
    res.condition = question_1.showNotificationTriggerCondition;
    return teamsfx_api_1.ok(res);
}
exports.getNotificationTriggerQuestionNode = getNotificationTriggerQuestionNode;
function getPluginCLIName(name) {
    const pluginPrefix = "fx-resource-";
    if (name === constants_1.ResourcePlugins.Aad) {
        return "aad-manifest";
    }
    else if (name === constants_1.ResourcePlugins.AppStudio) {
        return "manifest";
    }
    else {
        return name.replace(pluginPrefix, "");
    }
}
exports.getPluginCLIName = getPluginCLIName;
const PlatformRuntimeMap = new Map([
    [teamsfx_api_1.Platform.VS, constants_2.Runtime.dotnet],
    [teamsfx_api_1.Platform.VSCode, constants_2.Runtime.nodejs],
    [teamsfx_api_1.Platform.CLI, constants_2.Runtime.nodejs],
    [teamsfx_api_1.Platform.CLI_HELP, constants_2.Runtime.nodejs],
]);
function getKeyNotFoundInMapErrorMsg(key) {
    return `The key ${key} is not found in map.`;
}
function getPlatformRuntime(platform) {
    const runtime = PlatformRuntimeMap.get(platform);
    if (runtime) {
        return runtime;
    }
    throw new Error(getKeyNotFoundInMapErrorMsg(platform));
}
exports.getPlatformRuntime = getPlatformRuntime;
function createAddAzureResourceQuestion(alreadyHaveFunction, alreadyHaveSQL, alreadyHaveAPIM, alreadyHaveKeyVault) {
    const options = [constants_2.AzureResourceFunction, constants_2.AzureResourceSQL];
    if (!alreadyHaveAPIM)
        options.push(constants_2.AzureResourceApim);
    if (!alreadyHaveKeyVault)
        options.push(constants_2.AzureResourceKeyVault);
    return {
        name: constants_2.AzureSolutionQuestionNames.AddResources,
        title: "Cloud resources",
        type: "multiSelect",
        staticOptions: options,
        default: [],
        onDidChangeSelection: async function (currentSelectedIds, previousSelectedIds) {
            const hasSQL = currentSelectedIds.has(constants_2.AzureResourceSQL.id);
            const hasAPIM = currentSelectedIds.has(constants_2.AzureResourceApim.id);
            if ((hasSQL || hasAPIM) && !alreadyHaveFunction) {
                currentSelectedIds.add(constants_2.AzureResourceFunction.id);
            }
            return currentSelectedIds;
        },
    };
}
exports.createAddAzureResourceQuestion = createAddAzureResourceQuestion;
function createAddCloudResourceOptions(alreadyHaveAPIM, alreadyHaveKeyVault) {
    const options = [constants_2.AzureResourceFunctionNewUI];
    if (!alreadyHaveAPIM)
        options.push(constants_2.AzureResourceApimNewUI);
    options.push(constants_2.AzureResourceSQLNewUI);
    if (!alreadyHaveKeyVault)
        options.push(constants_2.AzureResourceKeyVaultNewUI);
    return options;
}
exports.createAddCloudResourceOptions = createAddCloudResourceOptions;
function addCapabilityQuestion(alreadyHaveTab, alreadyHaveBot) {
    const options = [];
    if (!alreadyHaveTab)
        options.push(constants_2.TabOptionItem());
    if (!alreadyHaveBot) {
        options.push(constants_2.BotOptionItem());
        options.push(constants_2.MessageExtensionItem());
        options.push(constants_2.NotificationOptionItem());
        options.push(constants_2.CommandAndResponseOptionItem());
    }
    return {
        name: constants_2.AzureSolutionQuestionNames.Capabilities,
        title: featureFlags_1.isBotNotificationEnabled()
            ? localizeUtils_1.getLocalizedString("core.addCapabilityQuestion.titleNew")
            : localizeUtils_1.getLocalizedString("core.addCapabilityQuestion.title"),
        type: "multiSelect",
        staticOptions: options,
        default: [],
    };
}
exports.addCapabilityQuestion = addCapabilityQuestion;
exports.DeployPluginSelectQuestion = {
    name: constants_2.AzureSolutionQuestionNames.PluginSelectionDeploy,
    title: `Select resources`,
    type: "multiSelect",
    skipSingleOption: true,
    staticOptions: [],
    default: [],
};
exports.AskSubscriptionQuestion = {
    name: constants_2.AzureSolutionQuestionNames.AskSub,
    type: "func",
    func: async (inputs) => {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    },
};
function getUserEmailQuestion(currentUserEmail) {
    let defaultUserEmail = "";
    if (currentUserEmail && currentUserEmail.indexOf("@") > 0) {
        defaultUserEmail = "[UserName]@" + currentUserEmail.split("@")[1];
    }
    return {
        name: "email",
        type: "text",
        title: localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.title"),
        default: defaultUserEmail,
        validation: {
            validFunc: (input, previousInputs) => {
                if (!input || input.trim() === "") {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation1");
                }
                input = input.trim();
                if (input === defaultUserEmail) {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation2");
                }
                const re = /\S+@\S+\.\S+/;
                if (!re.test(input)) {
                    return localizeUtils_1.getLocalizedString("core.getUserEmailQuestion.validation3");
                }
                return undefined;
            },
        },
    };
}
exports.getUserEmailQuestion = getUserEmailQuestion;
function SelectEnvQuestion() {
    return {
        type: "singleSelect",
        name: "env",
        title: localizeUtils_1.getLocalizedString("core.QuestionSelectTargetEnvironment.title"),
        staticOptions: [],
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.SelectEnvQuestion = SelectEnvQuestion;
function InitEditorVSCode() {
    return {
        id: "vsc",
        label: localizeUtils_1.getLocalizedString("core.InitEditorVsc"),
        description: localizeUtils_1.getLocalizedString("core.InitEditorVscDesc"),
    };
}
exports.InitEditorVSCode = InitEditorVSCode;
function InitEditorVS() {
    return {
        id: "vs",
        label: localizeUtils_1.getLocalizedString("core.InitEditorVs"),
        description: localizeUtils_1.getLocalizedString("core.InitEditorVsDesc"),
    };
}
exports.InitEditorVS = InitEditorVS;
function InitCapabilityTab() {
    return {
        id: "tab",
        label: "Tab",
        description: localizeUtils_1.getLocalizedString("core.InitCapabilityTab"),
    };
}
exports.InitCapabilityTab = InitCapabilityTab;
function InitCapabilityBot() {
    return {
        id: "bot",
        label: "Bot",
        description: localizeUtils_1.getLocalizedString("core.InitCapabilityBot"),
    };
}
exports.InitCapabilityBot = InitCapabilityBot;
function InitOptionYes() {
    return {
        id: "true",
        label: localizeUtils_1.getLocalizedString("core.InitOptionYes"),
    };
}
exports.InitOptionYes = InitOptionYes;
function InitOptionNo() {
    return {
        id: "false",
        label: localizeUtils_1.getLocalizedString("core.InitOptionNo"),
    };
}
exports.InitOptionNo = InitOptionNo;
function InitEditorQuestion() {
    return {
        type: "singleSelect",
        name: "editor",
        title: localizeUtils_1.getLocalizedString("core.InitEditorTitle"),
        staticOptions: [InitEditorVSCode(), InitEditorVS()],
    };
}
exports.InitEditorQuestion = InitEditorQuestion;
function InitCapabilityQuestion() {
    return {
        type: "singleSelect",
        name: "capability",
        title: localizeUtils_1.getLocalizedString("core.InitCapabilityTitle"),
        staticOptions: [InitCapabilityTab(), InitCapabilityBot()],
    };
}
exports.InitCapabilityQuestion = InitCapabilityQuestion;
function InitIsSPFxQuestion() {
    return {
        type: "singleSelect",
        name: "spfx",
        title: localizeUtils_1.getLocalizedString("core.InitIsSPFxTitle"),
        staticOptions: [InitOptionNo(), InitOptionYes()],
    };
}
exports.InitIsSPFxQuestion = InitIsSPFxQuestion;
function InitDebugProceedQuestion() {
    return {
        type: "singleSelect",
        name: "proceed",
        title: async (inputs) => {
            let fileList;
            if (inputs["editor"] === InitEditorVSCode().id) {
                const exists = inputs.projectPath
                    ? await fs_extra_1.default.pathExists(path_1.default.join(inputs.projectPath, ".vscode"))
                    : false;
                const dotVscodeFolderName = exists ? ".vscode-teamsfx" : ".vscode";
                fileList = `  ${dotVscodeFolderName}/\n    - launch.json\n    - settings.json\n    - tasks.json\n  env/\n    - .env.local\n  - teamsapp.local.yml\n  - teamsapp.yml\n`;
            }
            else {
                fileList = "  env/\n    - .env.local\n  - teamsapp.yml/\n  - teamsapp.local.yml\n";
            }
            return localizeUtils_1.getLocalizedString("core.InitGenerateConfirm", fileList);
        },
        staticOptions: [InitOptionYes(), InitOptionNo()],
        default: InitOptionYes().id,
    };
}
exports.InitDebugProceedQuestion = InitDebugProceedQuestion;
function InitInfraProceedQuestion() {
    return {
        type: "singleSelect",
        name: "proceed",
        title: (inputs) => {
            const fileList = inputs["spfx"] === InitOptionYes().id
                ? "  env/\n    - .env.dev\n  - teamsapp.yml\n"
                : `  infra/\n${inputs["capability"] === InitCapabilityBot().id
                    ? "    botRegistration/\n      - azurebot.bicep\n      - readme.md\n"
                    : ""}    - azure.bicep\n    - azure.parameters.json\n  env/\n    - .env.dev\n  - teamsapp.yml\n`;
            return localizeUtils_1.getLocalizedString("core.InitGenerateConfirm", fileList);
        },
        staticOptions: [InitOptionYes(), InitOptionNo()],
        default: InitOptionYes().id,
    };
}
exports.InitInfraProceedQuestion = InitInfraProceedQuestion;
function getQuestionsForInit(type, inputs) {
    const group = new teamsfx_api_1.QTreeNode({ type: "group" });
    group.addChild(new teamsfx_api_1.QTreeNode(InitEditorQuestion()));
    const capabilityNode = new teamsfx_api_1.QTreeNode(InitCapabilityQuestion());
    group.addChild(capabilityNode);
    const SPFxNode = new teamsfx_api_1.QTreeNode(InitIsSPFxQuestion());
    SPFxNode.condition = {
        validFunc: (input, inputs) => {
            if ((inputs === null || inputs === void 0 ? void 0 : inputs.editor) === InitEditorVSCode().id && (inputs === null || inputs === void 0 ? void 0 : inputs.capability) === InitCapabilityTab().id)
                return undefined;
            return "Not supported";
        },
    };
    capabilityNode.addChild(SPFxNode);
    if (inputs.platform !== teamsfx_api_1.Platform.CLI_HELP) {
        group.addChild(new teamsfx_api_1.QTreeNode(type === "debug" ? InitDebugProceedQuestion() : InitInfraProceedQuestion()));
    }
    return teamsfx_api_1.ok(group);
}
exports.getQuestionsForInit = getQuestionsForInit;
//# sourceMappingURL=question.js.map