"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgrokChecker = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const helpLink_1 = require("../constant/helpLink");
const depsError_1 = require("../depsError");
const progressIndicator_1 = require("../util/progressIndicator");
const cpUtils_1 = require("../util/cpUtils");
const system_1 = require("../util/system");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const message_1 = require("../constant/message");
const ngrokName = "ngrok";
const installPackageVersion = "4.3.3";
const supportedPackageVersions = [">=3.4.0"];
const supportedBinVersions = ["2.3"];
const displayNgrokName = `${ngrokName}@${installPackageVersion}`;
const timeout = 5 * 60 * 1000;
class NgrokChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async command() {
        return "ngrok";
    }
    async getDepsInfo(isInstalled, error) {
        return Promise.resolve({
            name: ngrokName,
            type: depsChecker_1.DepsType.Ngrok,
            isInstalled: isInstalled,
            command: await this.command(),
            details: {
                isLinuxSupported: true,
                installVersion: installPackageVersion,
                binFolders: [this.getNgrokBinFolder()],
                supportedVersions: supportedPackageVersions,
            },
            error: error,
        });
    }
    async getInstallationInfo() {
        let isVersionSupported = false, hasSentinel = false;
        try {
            const ngrokVersion = await this.queryNgrokBinVersion();
            isVersionSupported =
                ngrokVersion !== undefined && supportedBinVersions.includes(ngrokVersion);
            hasSentinel = await fs.pathExists(this.getSentinelPath());
        }
        catch (error) {
            // do nothing
            return await this.getDepsInfo(false);
        }
        return await this.getDepsInfo(isVersionSupported && hasSentinel);
    }
    async install() {
        if (!(await this.hasNPM())) {
            this.handleNpmNotFound();
        }
        await this.cleanup();
        await this.installNgrok();
        if (!(await this.validate())) {
            await this.handleInstallNgrokFailed();
        }
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.ngrokInstallCompleted);
        await this._logger.info(message_1.Messages.finishInstallNgrok().replace("@NameVersion", displayNgrokName));
    }
    getNgrokBinFolder() {
        return path.join(this.getDefaultInstallPath(), "node_modules", "ngrok", "bin");
    }
    async resolve() {
        try {
            let installationInfo = await this.getInstallationInfo();
            if (!installationInfo.isInstalled) {
                // TODO: show output in extension
                // this._adapter.showOutputChannel();
                await this.install();
                installationInfo = await this.getInstallationInfo();
                this._logger.cleanup();
            }
            return installationInfo;
        }
        catch (error) {
            await this._logger.printDetailLog();
            this._logger.cleanup();
            await this._logger.error(`Failed to install 'ngrok', error = '${error}'`);
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.getDepsInfo(false, error);
            }
            return await this.getDepsInfo(false, new depsError_1.DepsCheckerError(error.message, helpLink_1.ngrokInstallHelpLink));
        }
    }
    async handleInstallNgrokFailed() {
        await this.cleanup();
        this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.ngrokInstallError, telemetry_1.TelemtryMessages.failedToInstallNgrok, message_1.Messages.failToValidateNgrok().replace("@NameVersion", displayNgrokName));
        throw new depsError_1.DepsCheckerError(message_1.Messages.failToInstallNgrok().split("@NameVersion").join(displayNgrokName), helpLink_1.ngrokInstallHelpLink);
    }
    async validate() {
        let isVersionSupported = false;
        let hasSentinel = false;
        try {
            const binVersion = await this.queryNgrokBinVersion();
            isVersionSupported = binVersion !== undefined && supportedBinVersions.includes(binVersion);
            hasSentinel = await fs.pathExists(this.getSentinelPath());
        }
        catch (err) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.ngrokValidationError, telemetry_1.TelemtryMessages.failedToValidateNgrok, err);
        }
        if (!isVersionSupported || !hasSentinel) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.ngrokValidationError, {
                "ngrok-v": String(isVersionSupported),
                sentinel: String(hasSentinel),
            });
        }
        return isVersionSupported && hasSentinel;
    }
    handleNpmNotFound() {
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
        throw new depsError_1.DepsCheckerError(message_1.Messages.needInstallNgrok().replace("@NameVersion", displayNgrokName), helpLink_1.ngrokInstallHelpLink);
    }
    getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "ngrok");
    }
    getSentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "ngrok-sentinel");
    }
    async queryNgrokBinVersion() {
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, {
            shell: true,
            env: { PATH: this.getNgrokBinFolder() },
        }, ngrokName, "version");
        const regex = /ngrok version (?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gim;
        const match = regex.exec(output);
        if (!match || !match.groups) {
            return undefined;
        }
        return `${match.groups.major_version}.${match.groups.minor_version}`;
    }
    async hasNPM() {
        try {
            const npmVersion = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "npm", "--version");
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmAlreadyInstalled, {
                "npm-version": npmVersion,
            });
            return true;
        }
        catch (error) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
            return false;
        }
    }
    async cleanup() {
        try {
            await fs.emptyDir(this.getDefaultInstallPath());
            await fs.remove(this.getSentinelPath());
        }
        catch (err) {
            await this._logger.debug(`Failed to clean up path: ${this.getDefaultInstallPath()}, error: ${err}`);
        }
    }
    async installNgrok() {
        await this._telemetry.sendEventWithDuration(telemetry_1.DepsCheckerEvent.ngrokInstallScriptCompleted, async () => {
            await progressIndicator_1.runWithProgressIndicator(async () => await this.doInstallNgrok(), this._logger);
        });
    }
    static extractNpmInstallLog(exitCode, log) {
        const nodePattern = /npm\s+info\s+using\s+node@(.*)/;
        const nodeResult = log.match(nodePattern);
        const nodeVersion = nodeResult ? nodeResult[1].trim() : undefined;
        const npmPattern = /npm\s+info\s+using\s+npm@(.*)/;
        const npmResult = log.match(npmPattern);
        const npmVersion = npmResult ? npmResult[1].trim() : undefined;
        // Save all error log and lines that contain "ngrok"
        const errorPattern = /(npm\s+ERR+.*)|(.*ngrok.*)/gi;
        const preventEmailRedactedRegex = /[^\s]*@[^\s]*/;
        const errorResults = log.match(errorPattern);
        const errorMessage = errorResults === null || errorResults === void 0 ? void 0 : errorResults.map((value) => {
            // redact strings that contain "@" to prevent telemetry reporter from redacting the whole property
            return value.trim().replace(preventEmailRedactedRegex, "<redacted: email>");
        });
        const properties = {};
        properties[telemetry_1.TelemetryProperties.NgrokNpmInstallExitCode] = `${exitCode}`;
        properties[telemetry_1.TelemetryProperties.NgrokNpmInstallNodeVersion] = `${nodeVersion}`;
        properties[telemetry_1.TelemetryProperties.NgrokNpmInstallNpmVersion] = `${npmVersion}`;
        properties[telemetry_1.TelemetryProperties.NgrokNpmInstallLog] = `${errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.join("\n")}`;
        return properties;
    }
    async doInstallNgrok() {
        await this._logger.info(message_1.Messages.startInstallNgrok().replace("@NameVersion", displayNgrokName));
        try {
            const npmCommand = this.getExecCommand("npm");
            const result = await cpUtils_1.cpUtils.tryExecuteCommand(undefined, this._logger, { timeout: timeout, shell: false }, npmCommand, "install", 
            // not use -f, to avoid npm@6 bug: exit code = 0, even if install fail
            `${ngrokName}@${installPackageVersion}`, "--prefix", `${this.getDefaultInstallPath()}`, "--no-audit", "--loglevel", // this will make npm output log to stderr
            "verbose");
            const log = result.cmdOutputIncludingStderr;
            const properties = NgrokChecker.extractNpmInstallLog(result.code, log);
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.ngrokNpmLog, properties);
            if (result.code !== 0) {
                const errorMessage = `Failed to run command: "${npmCommand} ${result.formattedArgs}", code: "${result.code}",
                              output: "${result.cmdOutput}", error: "${result.cmdOutputIncludingStderr}"`;
                throw new Error(errorMessage);
            }
            await fs.ensureFile(this.getSentinelPath());
        }
        catch (error) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.ngrokInstallScriptError, telemetry_1.TelemtryMessages.failedToInstallNgrok, error);
        }
    }
    getExecCommand(command) {
        return system_1.isWindows() ? `${command}.cmd` : command;
    }
}
exports.NgrokChecker = NgrokChecker;
//# sourceMappingURL=ngrokChecker.js.map