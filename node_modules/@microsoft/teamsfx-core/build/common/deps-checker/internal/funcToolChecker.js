"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFuncVersionSupport = exports.mapToFuncToolsVersion = exports.FuncToolChecker = exports.FuncMajorVersion = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const helpLink_1 = require("../constant/helpLink");
const progressIndicator_1 = require("../util/progressIndicator");
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const system_1 = require("../util/system");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const message_1 = require("../constant/message");
const nodeChecker_1 = require("./nodeChecker");
var FuncMajorVersion;
(function (FuncMajorVersion) {
    FuncMajorVersion["v1"] = "1";
    FuncMajorVersion["v2"] = "2";
    FuncMajorVersion["v3"] = "3";
    FuncMajorVersion["v4"] = "4";
})(FuncMajorVersion = exports.FuncMajorVersion || (exports.FuncMajorVersion = {}));
const FuncNodeVersionWhiteList = {
    // func-core-tools version
    "3": {
        "10": true,
        "12": true,
        "14": true,
    },
    "4": {
        "14": true,
        "16": true,
        "18": true,
    },
};
const RecommendedNodeVersion = "16";
const MinNode18FuncVersion = {
    majorVersion: FuncMajorVersion.v4,
    minorVersion: 0,
    patchVersion: 4670,
};
const funcPackageName = "azure-functions-core-tools";
const funcToolName = "Azure Functions Core Tools";
const installVersion = FuncMajorVersion.v4;
const supportedVersions = [FuncMajorVersion.v4];
const displayFuncName = `${funcToolName} (v${FuncMajorVersion.v4})`;
const timeout = 5 * 60 * 1000;
class FuncToolChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async getDepsInfo(isPortableFuncInstalled, isGlobalFuncInstalled, error) {
        return Promise.resolve({
            name: funcToolName,
            type: depsChecker_1.DepsType.FuncCoreTools,
            isInstalled: isPortableFuncInstalled || isGlobalFuncInstalled,
            command: await this.command(isPortableFuncInstalled, isGlobalFuncInstalled),
            details: {
                isLinuxSupported: false,
                installVersion: installVersion,
                supportedVersions: supportedVersions,
                binFolders: isPortableFuncInstalled ? this.getPortableFuncBinFolders() : undefined,
            },
            error: error,
        });
    }
    async resolve() {
        let installationInfo;
        try {
            const nodeVersion = await this.getNodeVersion();
            installationInfo = await this.getInstallationInfo({ nodeVersion: nodeVersion });
            if (!installationInfo.isInstalled) {
                await this.install(nodeVersion);
                installationInfo = await this.getInstallationInfo({ nodeVersion: nodeVersion });
            }
            if (!installationInfo.error && installationInfo.portableFunc.isInstalled) {
                const portableFuncNodeError = await this.checkPortableFuncAndNode(installationInfo.portableFunc, nodeVersion);
                if (portableFuncNodeError) {
                    installationInfo.isInstalled = false;
                    installationInfo.error = portableFuncNodeError;
                }
            }
            if (!installationInfo.error) {
                const globalFuncNodeError = await this.checkGlobalFuncAndNode(installationInfo.globalFunc, nodeVersion);
                if (globalFuncNodeError) {
                    installationInfo.error = globalFuncNodeError;
                    if (!installationInfo.portableFunc.isInstalled &&
                        installationInfo.globalFunc.isInstalled) {
                        installationInfo.isInstalled = false;
                    }
                }
            }
        }
        catch (error) {
            await this._logger.printDetailLog();
            await this._logger.error(`${error.message}, error = '${error}'`);
            if (error instanceof depsError_1.DepsCheckerError) {
                return await this.getDepsInfo(false, false, error);
            }
            return await this.getDepsInfo(false, false, new depsError_1.DepsCheckerError(error.message, helpLink_1.defaultHelpLink));
        }
        finally {
            this._logger.cleanup();
        }
        return installationInfo;
    }
    async getInstallationInfo(installOptions) {
        var _a, _b;
        const nodeVersion = (_a = installOptions === null || installOptions === void 0 ? void 0 : installOptions.nodeVersion) !== null && _a !== void 0 ? _a : (await this.getNodeVersion());
        const globalFunc = await this.checkGlobalFuncVersion(nodeVersion);
        const isGlobalFuncInstalled = globalFunc.isInstalled;
        const portableFunc = await this.checkPortableFuncVersion(nodeVersion);
        const isPortableFuncInstalled = portableFunc.isInstalled;
        if (isGlobalFuncInstalled) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcAlreadyInstalled, {
                "global-func-version": (_b = globalFunc.funcVersion) !== null && _b !== void 0 ? _b : "",
            });
            if (!isPortableFuncInstalled) {
                await this.cleanup();
            }
        }
        if (isPortableFuncInstalled) {
            // avoid missing this event after first installation 60 days
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcInstallCompleted);
        }
        const depsInfo = await this.getDepsInfo(isPortableFuncInstalled, isGlobalFuncInstalled);
        return Object.assign(depsInfo, { globalFunc: globalFunc, portableFunc: portableFunc });
    }
    async getNodeVersion() {
        var _a;
        const nodeVersion = (_a = (await nodeChecker_1.NodeChecker.getInstalledNodeVersion())) === null || _a === void 0 ? void 0 : _a.majorVersion;
        if (!nodeVersion) {
            throw new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound()
                .split("@NodeVersion")
                .join(supportedVersions[supportedVersions.length - 1]), helpLink_1.nodeNotFoundHelpLink);
        }
        return nodeVersion;
    }
    async checkPortableFuncAndNode(portableFunc, nodeVersion) {
        var _a;
        if (portableFunc.funcVersion) {
            if (!((_a = FuncNodeVersionWhiteList[portableFunc.funcVersion.toString()]) === null || _a === void 0 ? void 0 : _a[nodeVersion])) {
                return new depsError_1.PortableFuncNodeNotMatchedError(message_1.Messages.portableFuncNodeNotMatched()
                    .split("@FuncVersion")
                    .join(`v${portableFunc.funcVersion}`)
                    .split("@NodeVersion")
                    .join(`v${nodeVersion}`)
                    .split("@Link")
                    .join(helpLink_1.nodeInstallationLink)
                    .split("@RecommendedVersion")
                    .join(`v${RecommendedNodeVersion}`), helpLink_1.functionDepsVersionsLink);
            }
        }
        return undefined;
    }
    async checkGlobalFuncAndNode(globalFunc, nodeVersion) {
        var _a;
        if (globalFunc.funcVersion) {
            if (!((_a = FuncNodeVersionWhiteList[globalFunc.funcVersion.toString()]) === null || _a === void 0 ? void 0 : _a[nodeVersion])) {
                return new depsError_1.GlobalFuncNodeNotMatchedError(message_1.Messages.globalFuncNodeNotMatched()
                    .split("@FuncVersion")
                    .join(`v${globalFunc.funcVersion.toString()}`)
                    .split("@NodeVersion")
                    .join(`v${nodeVersion}`)
                    .split("@link")
                    .join(helpLink_1.functionDepsVersionsLink), helpLink_1.functionDepsVersionsLink);
            }
        }
        return undefined;
    }
    async checkPortableFuncVersion(nodeVersion) {
        let isVersionSupported = false, hasSentinel = false;
        let portableFuncVersion = null;
        try {
            portableFuncVersion = await this.queryFuncVersion(FuncToolChecker.getPortableFuncExecPath());
            isVersionSupported = isFuncVersionSupport(portableFuncVersion, nodeVersion);
            // to avoid "func -v" and "func new" work well, but "func start" fail.
            hasSentinel = await fs.pathExists(FuncToolChecker.getSentinelPath());
            if (system_1.isWindows() && isVersionSupported && hasSentinel) {
                await this.cleanupPortablePs1();
            }
        }
        catch (error) {
            // do nothing
            return {
                isInstalled: false,
                funcVersion: portableFuncVersion !== null ? portableFuncVersion.majorVersion : null,
            };
        }
        return {
            isInstalled: isVersionSupported && hasSentinel,
            funcVersion: portableFuncVersion !== null ? portableFuncVersion.majorVersion : null,
        };
    }
    async checkGlobalFuncVersion(nodeVersion) {
        const globalFuncVersion = await this.queryGlobalFuncVersion();
        return {
            isInstalled: isFuncVersionSupport(globalFuncVersion, nodeVersion),
            funcVersion: globalFuncVersion !== null ? globalFuncVersion.majorVersion : null,
        };
    }
    async install(nodeVersion) {
        if (system_1.isLinux()) {
            throw new depsError_1.LinuxNotSupportedError(message_1.Messages.linuxDepsNotFound().split("@SupportedPackages").join(displayFuncName), helpLink_1.defaultHelpLink);
        }
        if (!(await this.hasNPM())) {
            this.handleNpmNotFound();
        }
        await this.cleanup();
        await this.installFunc();
        if (!(await this.validate(nodeVersion))) {
            await this.handleInstallFuncFailed();
        }
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcInstallCompleted);
        await this._logger.info(message_1.Messages.finishInstallFunctionCoreTool().replace("@NameVersion", displayFuncName));
    }
    async handleInstallFuncFailed() {
        await this.cleanup();
        this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcInstallError, telemetry_1.TelemtryMessages.failedToInstallFunc, message_1.Messages.failToValidateFuncCoreTool().replace("@NameVersion", displayFuncName));
        throw new depsError_1.DepsCheckerError(message_1.Messages.failToInstallFuncCoreTool().split("@NameVersion").join(displayFuncName), helpLink_1.defaultHelpLink);
    }
    async validate(nodeVersion) {
        let isVersionSupported = false;
        let hasSentinel = false;
        try {
            const portableFunc = await this.queryFuncVersion(FuncToolChecker.getPortableFuncExecPath());
            isVersionSupported = isFuncVersionSupport(portableFunc, nodeVersion);
            // to avoid "func -v" and "func new" work well, but "func start" fail.
            hasSentinel = await fs.pathExists(FuncToolChecker.getSentinelPath());
        }
        catch (err) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcValidationError, telemetry_1.TelemtryMessages.failedToValidateFunc, err);
        }
        if (!isVersionSupported || !hasSentinel) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.funcValidationError, {
                "func-v": String(isVersionSupported),
                sentinel: String(hasSentinel),
            });
        }
        return isVersionSupported && hasSentinel;
    }
    handleNpmNotFound() {
        this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
        throw new depsError_1.DepsCheckerError(message_1.Messages.needInstallFuncCoreTool().replace("@NameVersion", displayFuncName), helpLink_1.defaultHelpLink);
    }
    static getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "func");
    }
    static getSentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "func-sentinel");
    }
    static getPortableFuncExecPath() {
        return path.join(FuncToolChecker.getDefaultInstallPath(), "node_modules", "azure-functions-core-tools", "lib", "main.js");
    }
    async command(isPortableFuncInstalled, isGlobalFuncInstalled) {
        if (isPortableFuncInstalled) {
            return `node "${FuncToolChecker.getPortableFuncExecPath()}"`;
        }
        if (isGlobalFuncInstalled) {
            return "func";
        }
        return "npx azure-functions-core-tools@3";
    }
    getPortableFuncBinFolders() {
        return [
            FuncToolChecker.getDefaultInstallPath(),
            path.join(FuncToolChecker.getDefaultInstallPath(), "node_modules", ".bin"),
        ];
    }
    async queryFuncVersion(path) {
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "node", `"${path}"`, "--version");
        return mapToFuncToolsVersion(output);
    }
    async queryGlobalFuncVersion() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, 
            // same as backend start, avoid powershell execution policy issue.
            { shell: system_1.isWindows() ? "cmd.exe" : true }, "func", "--version");
            return mapToFuncToolsVersion(output);
        }
        catch (error) {
            return null;
        }
    }
    async hasNPM() {
        try {
            const npmVersion = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "npm", "--version");
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmAlreadyInstalled, {
                "npm-version": npmVersion,
            });
            return true;
        }
        catch (error) {
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.npmNotFound);
            return false;
        }
    }
    async cleanup() {
        try {
            await fs.emptyDir(FuncToolChecker.getDefaultInstallPath());
            await fs.remove(FuncToolChecker.getSentinelPath());
        }
        catch (err) {
            await this._logger.debug(`Failed to clean up path: ${FuncToolChecker.getDefaultInstallPath()}, error: ${err}`);
        }
    }
    async cleanupPortablePs1() {
        // delete func.ps1 from portable function
        for (const funcFolder of this.getPortableFuncBinFolders()) {
            const funcPath = path.join(funcFolder, "func.ps1");
            if (await fs.pathExists(funcPath)) {
                await this._logger.debug(`deleting func.ps1 from ${funcPath}`);
                await fs.remove(funcPath);
            }
        }
    }
    async installFunc() {
        await this._telemetry.sendEventWithDuration(telemetry_1.DepsCheckerEvent.funcInstallScriptCompleted, async () => {
            await progressIndicator_1.runWithProgressIndicator(async () => await this.doInstallPortableFunc(FuncMajorVersion.v4), this._logger);
        });
    }
    async doInstallPortableFunc(version) {
        await this._logger.info(message_1.Messages.startInstallFunctionCoreTool().replace("@NameVersion", displayFuncName));
        try {
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { timeout: timeout, shell: false }, this.getExecCommand("npm"), "install", 
            // not use -f, to avoid npm@6 bug: exit code = 0, even if install fail
            `${funcPackageName}@${version}`, "--prefix", `${FuncToolChecker.getDefaultInstallPath()}`, "--no-audit");
            await fs.ensureFile(FuncToolChecker.getSentinelPath());
            if (system_1.isWindows()) {
                // delete func.ps1 if exists to workaround the powershell execution policy issue:
                // https://github.com/npm/cli/issues/470
                const funcPSScript = await this.getFuncPSScriptPath();
                if (await fs.pathExists(funcPSScript)) {
                    await this._logger.debug(`deleting func.ps1 from ${funcPSScript}`);
                    await fs.remove(funcPSScript);
                }
                await this.cleanupPortablePs1();
            }
        }
        catch (error) {
            this._telemetry.sendSystemErrorEvent(telemetry_1.DepsCheckerEvent.funcInstallScriptError, telemetry_1.TelemtryMessages.failedToInstallFunc, error);
        }
    }
    getExecCommand(command) {
        return system_1.isWindows() ? `${command}.cmd` : command;
    }
    async getFuncPSScriptPath() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, {
                shell: "cmd.exe",
            }, "where", "func");
            const funcPath = output.split(/\r?\n/)[0];
            const funcFolder = path.dirname(funcPath);
            return path.join(funcFolder, "func.ps1");
        }
        catch (_a) {
            // ignore error and regard func.ps1 as not found.
            return "";
        }
    }
}
exports.FuncToolChecker = FuncToolChecker;
function mapToFuncToolsVersion(output) {
    var _a, _b, _c, _d, _e;
    const regex = /(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        return null;
    }
    const majorVersionFunc = (majorVersion) => {
        switch (majorVersion) {
            case FuncMajorVersion.v1:
                return FuncMajorVersion.v1;
            case FuncMajorVersion.v2:
                return FuncMajorVersion.v2;
            case FuncMajorVersion.v3:
                return FuncMajorVersion.v3;
            case FuncMajorVersion.v4:
                return FuncMajorVersion.v4;
            default:
                return null;
        }
    };
    const majorVersion = majorVersionFunc((_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version);
    const minorVersion = Number.parseInt((_c = (_b = match.groups) === null || _b === void 0 ? void 0 : _b.minor_version) !== null && _c !== void 0 ? _c : "");
    const patchVersion = Number.parseInt((_e = (_d = match.groups) === null || _d === void 0 ? void 0 : _d.patch_version) !== null && _e !== void 0 ? _e : "");
    if (majorVersion == null || !Number.isInteger(minorVersion) || !Number.isInteger(patchVersion)) {
        return null;
    }
    return {
        majorVersion: majorVersion,
        minorVersion: minorVersion,
        patchVersion: patchVersion,
    };
}
exports.mapToFuncToolsVersion = mapToFuncToolsVersion;
function isFuncVersionSupport(funcVersion, nodeVersion) {
    if (Number.parseInt(nodeVersion) >= 18) {
        return (funcVersion !== null &&
            funcVersion.majorVersion == MinNode18FuncVersion.majorVersion &&
            (funcVersion.minorVersion > MinNode18FuncVersion.minorVersion ||
                (funcVersion.minorVersion === MinNode18FuncVersion.minorVersion &&
                    funcVersion.patchVersion >= MinNode18FuncVersion.patchVersion)));
    }
    else {
        return funcVersion !== null && supportedVersions.includes(funcVersion.majorVersion);
    }
}
exports.isFuncVersionSupport = isFuncVersionSupport;
//# sourceMappingURL=funcToolChecker.js.map