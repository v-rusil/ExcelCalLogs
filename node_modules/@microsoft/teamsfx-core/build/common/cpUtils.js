"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryExecuteCommand = exports.executeCommand = void 0;
const tslib_1 = require("tslib");
const cp = tslib_1.__importStar(require("child_process"));
const os = tslib_1.__importStar(require("os"));
async function executeCommand(command, args, logger, options, workingDirectory) {
    const result = await tryExecuteCommand(command, args, logger, options, workingDirectory);
    if (result.code !== 0) {
        const errorMessage = `Failed to execute ${command} with arguments: ${JSON.stringify(args)}. stdout: ${result.stdout}, stderr: ${result.stderr}, code: ${result.code}`;
        await (logger === null || logger === void 0 ? void 0 : logger.debug(errorMessage));
        throw new Error(errorMessage);
    }
    else {
        await (logger === null || logger === void 0 ? void 0 : logger.debug(`Finished execute ${command} with arguments: ${JSON.stringify(args)}.`));
    }
    return result.stdout;
}
exports.executeCommand = executeCommand;
async function tryExecuteCommand(command, args, logger, additionalOptions, workingDirectory) {
    return await new Promise((resolve, reject) => {
        var _a, _b;
        let stdout = "";
        let stderr = "";
        const options = {
            cwd: workingDirectory || os.tmpdir(),
            shell: true,
        };
        Object.assign(options, additionalOptions);
        const childProc = cp.spawn(command, args, options);
        let timer;
        if (options.timeout && options.timeout > 0) {
            // timeout only exists for exec not spawn
            timer = setTimeout(() => {
                childProc.kill();
                logger === null || logger === void 0 ? void 0 : logger.debug(`Stop command execution due to timeout, command: ${command}, arguments: ${JSON.stringify(args)}, options: '${JSON.stringify(options)}'`);
                reject(new Error(`Execute ${command} with arguments ${JSON.stringify(args)} timeout, ${options.timeout} ms`));
            }, options.timeout);
        }
        logger === null || logger === void 0 ? void 0 : logger.debug(`Executing ${command}, arguments = ${JSON.stringify(args)}, options = '${JSON.stringify(options)}'`);
        (_a = childProc.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
            stdout = stdout.concat(data.toString());
        });
        (_b = childProc.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (data) => {
            stderr = stderr.concat(data.toString());
        });
        childProc.on("error", (error) => {
            logger === null || logger === void 0 ? void 0 : logger.debug(`Failed to execute ${command} with arguments: ${JSON.stringify(args)}. stderr: ${stderr}, error: ${error}`);
            if (timer) {
                clearTimeout(timer);
            }
            reject(error);
        });
        childProc.on("close", (code) => {
            logger === null || logger === void 0 ? void 0 : logger.debug("Command finished.");
            if (timer) {
                clearTimeout(timer);
            }
            resolve({
                code,
                stdout: stdout,
                stderr: stderr,
            });
        });
    });
}
exports.tryExecuteCommand = tryExecuteCommand;
//# sourceMappingURL=cpUtils.js.map