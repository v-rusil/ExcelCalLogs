"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllowedAppIds = exports.redactObject = exports.IsSimpleAuthEnabled = exports.getHashedEnv = exports.isVideoFilterProject = exports.isSPFxProject = exports.getUuid = exports.waitSeconds = exports.parseFromResourceId = exports.getSubscriptionIdFromResourceId = exports.getResourceGroupNameFromResourceId = exports.getSiteNameFromResourceId = exports.getStorageAccountNameFromResourceId = exports.getAppDirectory = exports.compileHandlebarsTemplateString = exports.generateBicepFromFile = exports.getAppSPFxVersion = exports.isGeneratorCheckerEnabled = exports.isYoCheckerEnabled = exports.canAddCICDWorkflows = exports.canAddApiConnection = exports.canAddSso = exports.isAADEnabled = exports.isVideoFilterEnabled = exports.isMigrationV3Enabled = exports.isV3Enabled = exports.isApiConnectEnabled = exports.isM365AppEnabled = exports.isDeployManifestEnabled = exports.isAadManifestEnabled = exports.isExistingTabAppEnabled = exports.isBicepEnvCheckerEnabled = exports.getResourceGroupInPortal = exports.askSubscription = exports.isCheckAccountError = exports.isUserCancelError = exports.deepCopy = exports.serializeDict = exports.replaceTemplateWithUserData = exports.convertDotenvToEmbeddedJson = exports.separateSecretData = exports.dataNeedEncryption = exports.AzurePortalUrl = exports.CryptoDataMatchers = exports.objectToConfigMap = exports.objectToMap = exports.mapToJson = exports.ensureUniqueFolder = exports.npmInstall = exports.Executor = void 0;
exports.getFixedCommonProjectSettings = exports.ConvertTokenToJson = exports.setRegion = exports.getSPFxToken = exports.getSPFxTenant = exports.AzureScopes = exports.SPFxScopes = exports.GraphReadUserScopes = exports.GraphScopes = exports.AuthSvcScopes = exports.AppStudioScopes = exports.getPropertyByPath = exports.undefinedName = exports.createV2Context = exports.getSideloadingStatus = exports.getAllowedAppMaps = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const child_process_1 = require("child_process");
const fs = tslib_1.__importStar(require("fs-extra"));
const Handlebars = tslib_1.__importStar(require("handlebars"));
const util_1 = require("util");
const uuid = tslib_1.__importStar(require("uuid"));
const constants_1 = require("./constants");
const crypto = tslib_1.__importStar(require("crypto"));
const error_1 = require("../core/error");
const constants_2 = require("../component/constants");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const constants_3 = require("../component/constants");
const globalVars_1 = require("../core/globalVars");
const crypto_1 = require("../core/crypto");
const localizeUtils_1 = require("./localizeUtils");
const featureFlags_1 = require("./featureFlags");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const constants_4 = require("./local/constants");
const projectSettingsHelper_1 = require("./projectSettingsHelper");
const existingTemplatesStat_1 = require("../component/feature/cicd/existingTemplatesStat");
const environment_1 = require("../core/environment");
const errors_1 = require("../component/feature/cicd/errors");
const utils_1 = require("./utils");
const path = tslib_1.__importStar(require("path"));
const projectSettingsHelperV3_1 = require("./projectSettingsHelperV3");
const constants_5 = require("../component/resource/appManifest/constants");
const ManifestUtils_1 = require("../component/resource/appManifest/utils/ManifestUtils");
const authSvcClient_1 = require("../component/resource/appManifest/authSvcClient");
const appStudioClient_1 = require("../component/resource/appManifest/appStudioClient");
const appStudioClient_2 = require("../component/resource/botService/appStudio/appStudioClient");
const projectSettingsLoader_1 = require("../core/middleware/projectSettingsLoader");
const yaml_1 = require("yaml");
Handlebars.registerHelper("contains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) > -1 ? this : "";
});
Handlebars.registerHelper("notContains", (value, array) => {
    array = array instanceof Array ? array : [array];
    return array.indexOf(value) == -1 ? this : "";
});
Handlebars.registerHelper("equals", (value, target) => {
    return value === target ? this : "";
});
exports.Executor = {
    async execCommandAsync(command, options) {
        const execAsync = util_1.promisify(child_process_1.exec);
        return await execAsync(command, options);
    },
};
async function npmInstall(path) {
    await exports.Executor.execCommandAsync("npm install", {
        cwd: path,
    });
}
exports.npmInstall = npmInstall;
async function ensureUniqueFolder(folderPath) {
    let folderId = 1;
    let testFolder = folderPath;
    let pathExists = await fs.pathExists(testFolder);
    while (pathExists) {
        testFolder = `${folderPath}${folderId}`;
        folderId++;
        pathExists = await fs.pathExists(testFolder);
    }
    return testFolder;
}
exports.ensureUniqueFolder = ensureUniqueFolder;
/**
 * Convert a `Map` to a Json recursively.
 * @param {Map} map to convert.
 * @returns {Json} converted Json.
 */
function mapToJson(map) {
    if (!map)
        return {};
    const out = {};
    for (const entry of map.entries()) {
        if (entry[1] instanceof Map) {
            out[entry[0]] = mapToJson(entry[1]);
        }
        else {
            out[entry[0]] = entry[1];
        }
    }
    return out;
}
exports.mapToJson = mapToJson;
/**
 * Convert an `Object` to a Map recursively
 * @param {Json} Json to convert.
 * @returns {Map} converted Json.
 */
function objectToMap(o) {
    const m = new Map();
    for (const entry of Object.entries(o)) {
        if (entry[1] instanceof Array) {
            m.set(entry[0], entry[1]);
        }
        else if (entry[1] instanceof Object) {
            m.set(entry[0], objectToConfigMap(entry[1]));
        }
        else {
            m.set(entry[0], entry[1]);
        }
    }
    return m;
}
exports.objectToMap = objectToMap;
/**
 * @param {Json} Json to convert.
 * @returns {Map} converted Json.
 */
function objectToConfigMap(o) {
    const m = new teamsfx_api_1.ConfigMap();
    if (o) {
        for (const entry of Object.entries(o)) {
            {
                m.set(entry[0], entry[1]);
            }
        }
    }
    return m;
}
exports.objectToConfigMap = objectToConfigMap;
const SecretDataMatchers = [
    "fx-resource-aad-app-for-teams.clientSecret",
    "fx-resource-simple-auth.filePath",
    "fx-resource-simple-auth.environmentVariableParams",
    "fx-resource-local-debug.*",
    "fx-resource-bot.botPassword",
    "fx-resource-apim.apimClientAADClientSecret",
    "fx-resource-azure-sql.adminPassword",
];
exports.CryptoDataMatchers = new Set([
    "fx-resource-aad-app-for-teams.clientSecret",
    "fx-resource-aad-app-for-teams.local_clientSecret",
    "fx-resource-simple-auth.environmentVariableParams",
    "fx-resource-bot.botPassword",
    "fx-resource-bot.localBotPassword",
    "fx-resource-apim.apimClientAADClientSecret",
    "fx-resource-azure-sql.adminPassword",
]);
exports.AzurePortalUrl = "https://portal.azure.com";
/**
 * Only data related to secrets need encryption.
 * @param key - the key name of data in user data file
 * @returns whether it needs encryption
 */
function dataNeedEncryption(key) {
    return exports.CryptoDataMatchers.has(key);
}
exports.dataNeedEncryption = dataNeedEncryption;
function separateSecretData(configJson) {
    const res = {};
    for (const matcher of SecretDataMatchers) {
        const splits = matcher.split(".");
        const resourceId = splits[0];
        const item = splits[1];
        const resourceConfig = configJson[resourceId];
        if (!resourceConfig)
            continue;
        if ("*" !== item) {
            const configValue = resourceConfig[item];
            if (configValue) {
                const keyName = `${resourceId}.${item}`;
                res[keyName] = configValue;
                resourceConfig[item] = `{{${keyName}}}`;
            }
        }
        else {
            for (const itemName of Object.keys(resourceConfig)) {
                const configValue = resourceConfig[itemName];
                if (configValue !== undefined) {
                    const keyName = `${resourceId}.${itemName}`;
                    res[keyName] = configValue;
                    resourceConfig[itemName] = `{{${keyName}}}`;
                }
            }
        }
    }
    return res;
}
exports.separateSecretData = separateSecretData;
function convertDotenvToEmbeddedJson(dict) {
    const result = {};
    for (const key of Object.keys(dict)) {
        const array = key.split(".");
        let obj = result;
        for (let i = 0; i < array.length - 1; ++i) {
            const subKey = array[i];
            let subObj = obj[subKey];
            if (!subObj) {
                subObj = {};
                obj[subKey] = subObj;
            }
            obj = subObj;
        }
        obj[array[array.length - 1]] = dict[key];
    }
    return result;
}
exports.convertDotenvToEmbeddedJson = convertDotenvToEmbeddedJson;
function replaceTemplateWithUserData(template, userData) {
    const view = convertDotenvToEmbeddedJson(userData);
    mustache_1.default.escape = (t) => {
        if (!t) {
            return t;
        }
        const str = JSON.stringify(t);
        return str.substr(1, str.length - 2);
        // return t;
    };
    const result = mustache_1.default.render(template, view);
    return result;
}
exports.replaceTemplateWithUserData = replaceTemplateWithUserData;
function serializeDict(dict) {
    const array = [];
    for (const key of Object.keys(dict)) {
        const value = dict[key];
        array.push(`${key}=${value}`);
    }
    return array.join("\n");
}
exports.serializeDict = serializeDict;
const deepCopy = (target) => {
    if (target === null) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach((v) => {
            cp.push(v);
        });
        return cp.map((n) => exports.deepCopy(n));
    }
    if (typeof target === "object" && target !== {}) {
        const cp = Object.assign({}, target);
        Object.keys(cp).forEach((k) => {
            cp[k] = exports.deepCopy(cp[k]);
        });
        return cp;
    }
    return target;
};
exports.deepCopy = deepCopy;
function isUserCancelError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === "User Cancel" || errorName === "CancelProvision" || errorName === "UserCancel");
}
exports.isUserCancelError = isUserCancelError;
function isCheckAccountError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === constants_2.SolutionError.TeamsAppTenantIdNotRight ||
        errorName === constants_2.SolutionError.SubscriptionNotFound);
}
exports.isCheckAccountError = isCheckAccountError;
async function askSubscription(azureAccountProvider, ui, activeSubscriptionId) {
    const subscriptions = await azureAccountProvider.listSubscriptions();
    if (subscriptions.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError("Core", "NoSubscriptionFound", localizeUtils_1.getDefaultString("error.NoSubscriptionFound"), localizeUtils_1.getLocalizedString("error.NoSubscriptionFound")));
    }
    let resultSub = subscriptions.find((sub) => sub.subscriptionId === activeSubscriptionId);
    if (activeSubscriptionId === undefined || resultSub === undefined) {
        let selectedSub = undefined;
        if (subscriptions.length === 1) {
            selectedSub = subscriptions[0];
        }
        else {
            const options = subscriptions.map((sub) => {
                return {
                    id: sub.subscriptionId,
                    label: sub.subscriptionName,
                    data: sub.tenantId,
                };
            });
            const askRes = await ui.selectOption({
                name: "subscription",
                title: "Select a subscription",
                options: options,
                returnObject: true,
            });
            if (askRes.isErr())
                return teamsfx_api_1.err(askRes.error);
            const subItem = askRes.value.result;
            selectedSub = {
                subscriptionId: subItem.id,
                subscriptionName: subItem.label,
                tenantId: subItem.data,
            };
        }
        if (selectedSub === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Core", "NoSubscriptionFound", localizeUtils_1.getDefaultString("error.NoSubscriptionFound"), localizeUtils_1.getLocalizedString("error.NoSubscriptionFound")));
        }
        resultSub = selectedSub;
    }
    return teamsfx_api_1.ok(resultSub);
}
exports.askSubscription = askSubscription;
function getResourceGroupInPortal(subscriptionId, tenantId, resourceGroupName) {
    if (subscriptionId && tenantId && resourceGroupName) {
        return `${exports.AzurePortalUrl}/#@${tenantId}/resource/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}`;
    }
    else {
        return undefined;
    }
}
exports.getResourceGroupInPortal = getResourceGroupInPortal;
// TODO: move other feature flags to featureFlags.ts to prevent import loop
function isBicepEnvCheckerEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.BicepEnvCheckerEnable, true);
}
exports.isBicepEnvCheckerEnabled = isBicepEnvCheckerEnabled;
function isExistingTabAppEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.ExistingTabApp, false);
}
exports.isExistingTabAppEnabled = isExistingTabAppEnabled;
function isAadManifestEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.AadManifest, false);
}
exports.isAadManifestEnabled = isAadManifestEnabled;
function isDeployManifestEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.DeployManifest, false);
}
exports.isDeployManifestEnabled = isDeployManifestEnabled;
function isM365AppEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.M365App, false);
}
exports.isM365AppEnabled = isM365AppEnabled;
function isApiConnectEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.ApiConnect, false);
}
exports.isApiConnectEnabled = isApiConnectEnabled;
function isV3Enabled() {
    return process.env.TEAMSFX_V3 ? process.env.TEAMSFX_V3 === "true" : false;
}
exports.isV3Enabled = isV3Enabled;
function isMigrationV3Enabled() {
    return process.env.TEAMSFX_V3_MIGRATION ? process.env.TEAMSFX_V3_MIGRATION === "true" : false;
}
exports.isMigrationV3Enabled = isMigrationV3Enabled;
function isVideoFilterEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.VideoFilter, false);
}
exports.isVideoFilterEnabled = isVideoFilterEnabled;
// This method is for deciding whether AAD should be activated.
// Currently AAD plugin will always be activated when scaffold.
// This part will be updated when we support adding aad separately.
function isAADEnabled(solutionSettings) {
    var _a;
    if (!solutionSettings) {
        return false;
    }
    if (isAadManifestEnabled()) {
        return (solutionSettings.hostType === constants_3.HostTypeOptionAzure().id &&
            (solutionSettings.capabilities.includes(constants_3.TabSsoItem().id) ||
                solutionSettings.capabilities.includes(constants_3.BotSsoItem().id)));
    }
    else {
        return (solutionSettings.hostType === constants_3.HostTypeOptionAzure().id &&
            // For scaffold, activeResourecPlugins is undefined
            (!solutionSettings.activeResourcePlugins ||
                ((_a = solutionSettings.activeResourcePlugins) === null || _a === void 0 ? void 0 : _a.includes(constants_1.ResourcePlugins.Aad))));
    }
}
exports.isAADEnabled = isAADEnabled;
// TODO: handle VS scenario
function canAddSso(projectSettings, returnError = false) {
    var _a, _b;
    // Can not add sso if feature flag is not enabled
    if (!isAadManifestEnabled()) {
        return returnError
            ? teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NeedEnableFeatureFlag, localizeUtils_1.getLocalizedString("core.addSso.needEnableFeatureFlag")))
            : false;
    }
    const solutionSettings = projectSettings.solutionSettings;
    if (projectSettingsHelper_1.isExistingTabApp(projectSettings) &&
        !(solutionSettings && solutionSettings.capabilities.includes(constants_3.TabSsoItem().id))) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    if (!(solutionSettings.hostType === constants_3.HostTypeOptionAzure().id)) {
        return returnError
            ? teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.AddSsoNotSupported, localizeUtils_1.getLocalizedString("core.addSso.onlySupportAzure")))
            : false;
    }
    // Will throw error if only Messaging Extension is selected
    if (solutionSettings.capabilities.length === 1 &&
        solutionSettings.capabilities[0] === constants_3.MessageExtensionItem().id) {
        return returnError
            ? teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.AddSsoNotSupported, localizeUtils_1.getLocalizedString("core.addSso.onlyMeNotSupport")))
            : false;
    }
    // Will throw error if bot host type is Azure Function
    if (solutionSettings.capabilities.includes(constants_3.BotOptionItem().id) &&
        !(solutionSettings.capabilities.includes(constants_3.TabOptionItem().id) &&
            !solutionSettings.capabilities.includes(constants_3.TabSsoItem().id))) {
        const botHostType = (_b = (_a = projectSettings.pluginSettings) === null || _a === void 0 ? void 0 : _a[constants_1.ResourcePlugins.Bot]) === null || _b === void 0 ? void 0 : _b[constants_4.BotHostTypeName];
        if (botHostType === constants_4.BotHostTypes.AzureFunctions) {
            return returnError
                ? teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.AddSsoNotSupported, localizeUtils_1.getLocalizedString("core.addSso.functionNotSupport")))
                : false;
        }
    }
    // Check whether SSO is enabled
    const activeResourcePlugins = solutionSettings.activeResourcePlugins;
    const containTabSsoItem = solutionSettings.capabilities.includes(constants_3.TabSsoItem().id);
    const containTab = solutionSettings.capabilities.includes(constants_3.TabOptionItem().id);
    const containBotSsoItem = solutionSettings.capabilities.includes(constants_3.BotSsoItem().id);
    const containBot = solutionSettings.capabilities.includes(constants_3.BotOptionItem().id);
    const containAadPlugin = activeResourcePlugins.includes(constants_2.PluginNames.AAD);
    if (((containTabSsoItem && !containBot) ||
        (containBot && containBotSsoItem && !containTab) ||
        (containTabSsoItem && containBot && containBotSsoItem)) &&
        containAadPlugin) {
        return returnError
            ? teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.SsoEnabled, localizeUtils_1.getLocalizedString("core.addSso.ssoEnabled")))
            : false;
    }
    else if (((containBotSsoItem && !containBot) ||
        (containTabSsoItem || containBotSsoItem) !== containAadPlugin) &&
        returnError) {
        // Throw error if the project is invalid
        // Will not stop showing add sso
        const e = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.InvalidSsoProject, localizeUtils_1.getLocalizedString("core.addSso.invalidSsoProject"));
        return teamsfx_api_1.err(e);
    }
    return returnError ? teamsfx_api_1.ok(teamsfx_api_1.Void) : true;
}
exports.canAddSso = canAddSso;
function canAddApiConnection(solutionSettings) {
    const activePlugins = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins;
    if (!activePlugins) {
        return false;
    }
    return (activePlugins.includes(constants_1.ResourcePlugins.Bot) || activePlugins.includes(constants_1.ResourcePlugins.Function));
}
exports.canAddApiConnection = canAddApiConnection;
// Conditions required to be met:
// 1. Not (All templates were existing env x provider x templates)
// 2. Not minimal app
async function canAddCICDWorkflows(inputs, ctx) {
    var _a;
    // Not include `Add CICD Workflows` in minimal app case.
    const isExistingApp = ((_a = ctx.projectSetting.solutionSettings) === null || _a === void 0 ? void 0 : _a.hostType) === constants_3.HostTypeOptionAzure().id &&
        projectSettingsHelperV3_1.isMiniApp(ctx.projectSetting);
    if (isExistingApp) {
        return false;
    }
    if (!inputs.projectPath) {
        throw new errors_1.NoProjectOpenedError();
    }
    const envProfilesResult = await environment_1.environmentManager.listRemoteEnvConfigs(inputs.projectPath);
    if (envProfilesResult.isErr()) {
        throw new teamsfx_api_1.SystemError("Core", "ListMultiEnvError", localizeUtils_1.getDefaultString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message), localizeUtils_1.getLocalizedString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message));
    }
    const existingInstance = existingTemplatesStat_1.ExistingTemplatesStat.getInstance(inputs.projectPath, envProfilesResult.value);
    await existingInstance.scan();
    // If at least one env are not all-existing, return true.
    for (const envName of envProfilesResult.value) {
        if (existingInstance.notExisting(envName)) {
            return true;
        }
    }
    return false;
}
exports.canAddCICDWorkflows = canAddCICDWorkflows;
function isYoCheckerEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.YoCheckerEnable, true);
}
exports.isYoCheckerEnabled = isYoCheckerEnabled;
function isGeneratorCheckerEnabled() {
    return featureFlags_1.isFeatureFlagEnabled(constants_1.FeatureFlagName.GeneratorCheckerEnable, true);
}
exports.isGeneratorCheckerEnabled = isGeneratorCheckerEnabled;
async function getAppSPFxVersion(root) {
    var _a;
    let projectSPFxVersion = undefined;
    const yoInfoPath = path.join(root, "SPFx", ".yo-rc.json");
    if (await fs.pathExists(yoInfoPath)) {
        const yoInfo = await fs.readJson(yoInfoPath);
        projectSPFxVersion = (_a = yoInfo["@microsoft/generator-sharepoint"]) === null || _a === void 0 ? void 0 : _a.version;
    }
    if (!projectSPFxVersion || projectSPFxVersion === "") {
        const packagePath = path.join(root, "SPFx", "package.json");
        if (await fs.pathExists(packagePath)) {
            const packageInfo = await fs.readJson(packagePath);
            projectSPFxVersion = packageInfo.dependencies["@microsoft/sp-webpart-base"];
        }
    }
    return projectSPFxVersion;
}
exports.getAppSPFxVersion = getAppSPFxVersion;
async function generateBicepFromFile(templateFilePath, context) {
    try {
        const templateString = await fs.readFile(templateFilePath, constants_1.ConstantString.UTF8Encoding);
        const updatedBicepFile = compileHandlebarsTemplateString(templateString, context);
        return updatedBicepFile;
    }
    catch (error) {
        throw new teamsfx_api_1.SystemError("Core", "BicepGenerationError", localizeUtils_1.getDefaultString("error.BicepGenerationError", templateFilePath, error.message), localizeUtils_1.getLocalizedString("error.BicepGenerationError", templateFilePath, error.message));
    }
}
exports.generateBicepFromFile = generateBicepFromFile;
function compileHandlebarsTemplateString(templateString, context) {
    const template = Handlebars.compile(templateString);
    return template(context);
}
exports.compileHandlebarsTemplateString = compileHandlebarsTemplateString;
async function getAppDirectory(projectRoot) {
    const REMOTE_MANIFEST = "manifest.source.json";
    const appDirNewLocForMultiEnv = path.resolve(await utils_1.getProjectTemplatesFolderPath(projectRoot), teamsfx_api_1.AppPackageFolderName);
    const appDirNewLoc = path.join(projectRoot, teamsfx_api_1.AppPackageFolderName);
    const appDirOldLoc = path.join(projectRoot, `.${teamsfx_api_1.ConfigFolderName}`);
    if (await fs.pathExists(appDirNewLocForMultiEnv)) {
        return appDirNewLocForMultiEnv;
    }
    else if (await fs.pathExists(path.join(appDirNewLoc, REMOTE_MANIFEST))) {
        return appDirNewLoc;
    }
    else {
        return appDirOldLoc;
    }
}
exports.getAppDirectory = getAppDirectory;
function getStorageAccountNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/providers\/Microsoft.Storage\/storageAccounts\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("storage accounts name", resourceId);
    }
    return result;
}
exports.getStorageAccountNameFromResourceId = getStorageAccountNameFromResourceId;
function getSiteNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/providers\/Microsoft.Web\/sites\/([^\/]*)/i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("site name", resourceId);
    }
    return result;
}
exports.getSiteNameFromResourceId = getSiteNameFromResourceId;
function getResourceGroupNameFromResourceId(resourceId) {
    const result = parseFromResourceId(/\/resourceGroups\/([^\/]*)\//i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("resource group name", resourceId);
    }
    return result;
}
exports.getResourceGroupNameFromResourceId = getResourceGroupNameFromResourceId;
function getSubscriptionIdFromResourceId(resourceId) {
    const result = parseFromResourceId(/\/subscriptions\/([^\/]*)\//i, resourceId);
    if (!result) {
        throw error_1.FailedToParseResourceIdError("subscription id", resourceId);
    }
    return result;
}
exports.getSubscriptionIdFromResourceId = getSubscriptionIdFromResourceId;
function parseFromResourceId(pattern, resourceId) {
    const result = resourceId.match(pattern);
    return result ? result[1].trim() : "";
}
exports.parseFromResourceId = parseFromResourceId;
async function waitSeconds(second) {
    return new Promise((resolve) => setTimeout(resolve, second * 1000));
}
exports.waitSeconds = waitSeconds;
function getUuid() {
    return uuid.v4();
}
exports.getUuid = getUuid;
function isSPFxProject(projectSettings) {
    const solutionSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings;
    if (solutionSettings) {
        const selectedPlugins = solutionSettings.activeResourcePlugins;
        return selectedPlugins && selectedPlugins.indexOf("fx-resource-spfx") !== -1;
    }
    return false;
}
exports.isSPFxProject = isSPFxProject;
async function isVideoFilterProject(projectPath) {
    var _a;
    let manifestResult;
    try {
        manifestResult = await ManifestUtils_1.manifestUtils.readAppManifest(projectPath);
    }
    catch (e) {
        return teamsfx_api_1.err(teamsfx_api_1.assembleError(e));
    }
    if (manifestResult.isErr()) {
        return teamsfx_api_1.err(manifestResult.error);
    }
    const manifest = manifestResult.value;
    return teamsfx_api_1.ok(((_a = manifest.meetingExtensionDefinition) === null || _a === void 0 ? void 0 : _a.videoFiltersConfigurationUrl) !== undefined);
}
exports.isVideoFilterProject = isVideoFilterProject;
function getHashedEnv(envName) {
    return crypto.createHash("sha256").update(envName).digest("hex");
}
exports.getHashedEnv = getHashedEnv;
function IsSimpleAuthEnabled(projectSettings) {
    var _a;
    const solutionSettings = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings;
    return (_a = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins) === null || _a === void 0 ? void 0 : _a.includes(constants_1.ResourcePlugins.SimpleAuth);
}
exports.IsSimpleAuthEnabled = IsSimpleAuthEnabled;
function isBasicJsonSchema(jsonSchema) {
    if (!jsonSchema || typeof jsonSchema !== "object") {
        return false;
    }
    return typeof jsonSchema["type"] === "string";
}
function _redactObject(obj, jsonSchema, maxRecursionDepth = 8, depth = 0) {
    if (depth >= maxRecursionDepth) {
        // prevent stack overflow if anything bad happens
        return null;
    }
    if (!obj || !isBasicJsonSchema(jsonSchema)) {
        return null;
    }
    if (!(jsonSchema.type === "object" &&
        jsonSchema.properties &&
        typeof jsonSchema.properties === "object")) {
        // non-object types including unsupported types
        return null;
    }
    const newObj = {};
    const objAny = obj;
    for (const key in jsonSchema.properties) {
        if (key in objAny && objAny[key] !== undefined) {
            const filteredObj = _redactObject(objAny[key], jsonSchema.properties[key], maxRecursionDepth, depth + 1);
            newObj[key] = filteredObj;
        }
    }
    return newObj;
}
/** Redact user content in "obj";
 *
 * DFS "obj" and "jsonSchema" together to redact the following things:
 * - properties that is not defined in jsonSchema
 * - the value of properties that is defined in jsonSchema, but the keys will remain
 *
 * Example:
 * Input:
 * ```
 *  obj = {
 *    "name": "some name",
 *    "user defined property": {
 *      "key1": "value1"
 *    }
 *  }
 *  jsonSchema = {
 *    "type": "object",
 *    "properties": {
 *      "name": { "type": "string" }
 *    }
 *  }
 * ```
 * Output:
 * ```
 *  {"name": null}
 * ```
 **/
function redactObject(obj, jsonSchema, maxRecursionDepth = 8) {
    return _redactObject(obj, jsonSchema, maxRecursionDepth, 0);
}
exports.redactObject = redactObject;
function getAllowedAppIds() {
    return [
        constants_1.TeamsClientId.MobileDesktop,
        constants_1.TeamsClientId.Web,
        constants_1.OfficeClientId.Desktop,
        constants_1.OfficeClientId.Web1,
        constants_1.OfficeClientId.Web2,
        constants_1.OutlookClientId.Desktop,
        constants_1.OutlookClientId.Web1,
        constants_1.OutlookClientId.Web2,
    ];
}
exports.getAllowedAppIds = getAllowedAppIds;
function getAllowedAppMaps() {
    return {
        [constants_1.TeamsClientId.MobileDesktop]: localizeUtils_1.getLocalizedString("core.common.TeamsMobileDesktopClientName"),
        [constants_1.TeamsClientId.Web]: localizeUtils_1.getLocalizedString("core.common.TeamsWebClientName"),
        [constants_1.OfficeClientId.Desktop]: localizeUtils_1.getLocalizedString("core.common.OfficeDesktopClientName"),
        [constants_1.OfficeClientId.Web1]: localizeUtils_1.getLocalizedString("core.common.OfficeWebClientName1"),
        [constants_1.OfficeClientId.Web2]: localizeUtils_1.getLocalizedString("core.common.OfficeWebClientName2"),
        [constants_1.OutlookClientId.Desktop]: localizeUtils_1.getLocalizedString("core.common.OutlookDesktopClientName"),
        [constants_1.OutlookClientId.Web1]: localizeUtils_1.getLocalizedString("core.common.OutlookWebClientName1"),
        [constants_1.OutlookClientId.Web2]: localizeUtils_1.getLocalizedString("core.common.OutlookWebClientName2"),
    };
}
exports.getAllowedAppMaps = getAllowedAppMaps;
async function getSideloadingStatus(token) {
    return appStudioClient_1.AppStudioClient.getSideloadingStatus(token);
}
exports.getSideloadingStatus = getSideloadingStatus;
function createV2Context(projectSettings) {
    const context = {
        userInteraction: globalVars_1.TOOLS.ui,
        logProvider: globalVars_1.TOOLS.logProvider,
        telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
        cryptoProvider: new crypto_1.LocalCrypto(projectSettings.projectId),
        permissionRequestProvider: globalVars_1.TOOLS.permissionRequest,
        projectSetting: projectSettings,
    };
    return context;
}
exports.createV2Context = createV2Context;
function undefinedName(objs, names) {
    for (let i = 0; i < objs.length; ++i) {
        if (objs[i] === undefined) {
            return names[i];
        }
    }
    return undefined;
}
exports.undefinedName = undefinedName;
function getPropertyByPath(obj, path, defaultValue) {
    return lodash_1.default.get(obj, path, defaultValue);
}
exports.getPropertyByPath = getPropertyByPath;
exports.AppStudioScopes = [`${constants_5.getAppStudioEndpoint()}/AppDefinitions.ReadWrite`];
exports.AuthSvcScopes = ["https://api.spaces.skype.com/Region.ReadWrite"];
exports.GraphScopes = ["Application.ReadWrite.All", "TeamsAppInstallation.ReadForUser"];
exports.GraphReadUserScopes = ["https://graph.microsoft.com/User.ReadBasic.All"];
const SPFxScopes = (tenant) => [`${tenant}/Sites.FullControl.All`];
exports.SPFxScopes = SPFxScopes;
exports.AzureScopes = ["https://management.core.windows.net/user_impersonation"];
async function getSPFxTenant(graphToken) {
    const GRAPH_TENANT_ENDPT = "https://graph.microsoft.com/v1.0/sites/root?$select=webUrl";
    if (graphToken.length > 0) {
        const response = await axios_1.default.get(GRAPH_TENANT_ENDPT, {
            headers: { Authorization: `Bearer ${graphToken}` },
        });
        return response.data.webUrl;
    }
    return "";
}
exports.getSPFxTenant = getSPFxTenant;
async function getSPFxToken(m365TokenProvider) {
    const graphTokenRes = await m365TokenProvider.getAccessToken({
        scopes: exports.GraphReadUserScopes,
    });
    let spoToken = undefined;
    if (graphTokenRes && graphTokenRes.isOk()) {
        const tenant = await getSPFxTenant(graphTokenRes.value);
        const spfxTokenRes = await m365TokenProvider.getAccessToken({
            scopes: exports.SPFxScopes(tenant),
        });
        spoToken = spfxTokenRes.isOk() ? spfxTokenRes.value : undefined;
    }
    return spoToken;
}
exports.getSPFxToken = getSPFxToken;
/**
 * Get and set regin for App Studio client
 * @param m365TokenProvider
 */
async function setRegion(authSvcToken) {
    const region = await authSvcClient_1.AuthSvcClient.getRegion(authSvcToken);
    if (region) {
        appStudioClient_1.AppStudioClient.setRegion(region);
        appStudioClient_2.AppStudioClient.setRegion(region);
    }
}
exports.setRegion = setRegion;
function ConvertTokenToJson(token) {
    const array = token.split(".");
    const buff = Buffer.from(array[1], "base64");
    return JSON.parse(buff.toString("utf8"));
}
exports.ConvertTokenToJson = ConvertTokenToJson;
function getFixedCommonProjectSettings(rootPath) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!rootPath) {
        return undefined;
    }
    try {
        if (isV3Enabled()) {
            const settingsPath = projectSettingsLoader_1.getProjectSettingPathV3(rootPath);
            if (!settingsPath || !fs.pathExistsSync(settingsPath)) {
                return undefined;
            }
            const settingsContent = fs.readFileSync(settingsPath, "utf-8");
            const settings = yaml_1.parse(settingsContent);
            return {
                projectId: (_a = settings === null || settings === void 0 ? void 0 : settings.projectId) !== null && _a !== void 0 ? _a : undefined,
            };
        }
        else {
            const projectSettingsPath = path.join(rootPath, `.${teamsfx_api_1.ConfigFolderName}`, teamsfx_api_1.InputConfigsFolderName, teamsfx_api_1.ProjectSettingsFileName);
            if (!projectSettingsPath || !fs.pathExistsSync(projectSettingsPath)) {
                return undefined;
            }
            const projectSettings = fs.readJsonSync(projectSettingsPath);
            return {
                projectId: (_b = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.projectId) !== null && _b !== void 0 ? _b : undefined,
                isFromSample: (_c = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.isFromSample) !== null && _c !== void 0 ? _c : undefined,
                programmingLanguage: (_d = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.programmingLanguage) !== null && _d !== void 0 ? _d : undefined,
                hostType: (_f = (_e = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.solutionSettings) === null || _e === void 0 ? void 0 : _e.hostType) !== null && _f !== void 0 ? _f : undefined,
                isM365: (_g = projectSettings === null || projectSettings === void 0 ? void 0 : projectSettings.isM365) !== null && _g !== void 0 ? _g : false,
            };
        }
    }
    catch (_h) {
        return undefined;
    }
}
exports.getFixedCommonProjectSettings = getFixedCommonProjectSettings;
//# sourceMappingURL=tools.js.map