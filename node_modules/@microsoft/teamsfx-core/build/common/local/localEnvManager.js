// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalEnvManager = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const commentJson = tslib_1.__importStar(require("comment-json"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const localStateHelper = tslib_1.__importStar(require("./localStateHelper"));
const localSettingsProvider_1 = require("../localSettingsProvider");
const npmLogHelper_1 = require("./npmLogHelper");
const portChecker_1 = require("./portChecker");
const tools_1 = require("../tools");
const crypto_1 = require("../../core/crypto");
const error_1 = require("../../core/error");
const depsChecker_1 = require("../deps-checker/depsChecker");
const projectSettingsHelper_1 = require("./projectSettingsHelper");
const localCertificateManager_1 = require("./localCertificateManager");
const depsManager_1 = require("../deps-checker/depsManager");
const localStateProvider_1 = require("../localStateProvider");
const localizeUtils_1 = require("../localizeUtils");
const projectSettingsLoader_1 = require("../../core/middleware/projectSettingsLoader");
const migrate_1 = require("../../component/migrate");
const ngrok_1 = require("../../component/debug/util/ngrok");
const localEnvProvider_1 = require("../../component/debugHandler/localEnvProvider");
class LocalEnvManager {
    constructor(logger, telemetry, ui) {
        this.logger = logger;
        this.telemetry = telemetry;
        this.ui = ui;
    }
    async getActiveDependencies(projectSettings) {
        const depsTypes = [];
        const isSPFx = projectSettingsHelper_1.ProjectSettingsHelper.isSpfx(projectSettings);
        const includeFrontend = projectSettingsHelper_1.ProjectSettingsHelper.includeFrontend(projectSettings);
        const includeSimpleAuth = projectSettingsHelper_1.ProjectSettingsHelper.includeSimpleAuth(projectSettings);
        const includeBackend = projectSettingsHelper_1.ProjectSettingsHelper.includeBackend(projectSettings);
        const includeBot = projectSettingsHelper_1.ProjectSettingsHelper.includeBot(projectSettings);
        const includeFuncHostedBot = projectSettingsHelper_1.ProjectSettingsHelper.includeFuncHostedBot(projectSettings);
        // NodeJS
        if (isSPFx) {
            depsTypes.push(depsChecker_1.DepsType.SpfxNode);
        }
        else {
            depsTypes.push(depsChecker_1.DepsType.AzureNode);
        }
        // Dotnet
        if ((includeFrontend && includeSimpleAuth) || includeBackend) {
            depsTypes.push(depsChecker_1.DepsType.Dotnet);
        }
        // Function core tool
        if (includeBackend || includeFuncHostedBot) {
            depsTypes.push(depsChecker_1.DepsType.FuncCoreTools);
        }
        // Ngrok
        if (includeBot) {
            depsTypes.push(depsChecker_1.DepsType.Ngrok);
        }
        return depsManager_1.DepsManager.sortBySequence(depsTypes);
    }
    async getLocalDebugEnvs(projectPath, projectSettings, localSettings, envInfo) {
        return await localStateHelper.convertToLocalEnvs(projectPath, projectSettings, envInfo, this.logger);
    }
    async getNpmInstallLogInfo() {
        return await npmLogHelper_1.getNpmInstallLogInfo();
    }
    async getPortsFromProject(projectPath, projectSettings) {
        return await portChecker_1.getPortsFromProject(projectPath, projectSettings, false);
    }
    async getPortsInUse(ports) {
        return await portChecker_1.getPortsInUse(ports, this.logger);
    }
    async getNgrokTunnelFromApi(webServiceUrl) {
        return await ngrok_1.getNgrokTunnelFromApi(webServiceUrl);
    }
    async getLocalSettings(projectPath, cryptoOption) {
        const localSettingsProvider = new localSettingsProvider_1.LocalSettingsProvider(projectPath);
        const crypto = cryptoOption === undefined ? undefined : new crypto_1.LocalCrypto(cryptoOption.projectId);
        return await this.retry(async () => {
            return await localSettingsProvider.loadV2(crypto);
        });
    }
    async getLocalEnvInfo(projectPath, cryptoOption) {
        const localStateProvider = new localStateProvider_1.LocalStateProvider(projectPath);
        const crypto = new crypto_1.LocalCrypto(cryptoOption.projectId);
        return await this.retry(async () => {
            const envInfo = await localStateProvider.loadV2(crypto);
            if (envInfo) {
                // for v3, this envInfo is exported to outside of fx-core, we need to revert it into old pattern
                envInfo.state = migrate_1.convertEnvStateV3ToV2(envInfo.state);
            }
            return envInfo;
        });
    }
    async getProjectSettings(projectPath) {
        return await this.retry(async () => {
            const projectSettingsPath = projectSettingsLoader_1.getProjectSettingsPath(projectPath);
            if (!(await fs.pathExists(projectSettingsPath))) {
                throw new teamsfx_api_1.UserError(error_1.CoreSource, "FileNotFoundError", localizeUtils_1.getDefaultString("error.FileNotFoundError", projectSettingsPath), localizeUtils_1.getLocalizedString("error.FileNotFoundError", projectSettingsPath));
            }
            try {
                const res = await projectSettingsLoader_1.loadProjectSettingsByProjectPath(projectPath, true);
                if (res.isErr()) {
                    throw res.error;
                }
                return res.value;
            }
            catch (error) {
                throw error_1.ReadFileError(error);
            }
        });
    }
    async resolveLocalCertificate(workspacePath, trustDevCert, localEnvProvider) {
        // Do not print any log in LocalCertificateManager, use the error message returned instead.
        const certManager = new localCertificateManager_1.LocalCertificateManager(this.ui);
        const res = await certManager.setupCertificate(trustDevCert);
        if (trustDevCert && localEnvProvider) {
            const isVideoFilter = await tools_1.isVideoFilterProject(workspacePath);
            if (isVideoFilter.isOk() && isVideoFilter.value) {
                const videoFilterEnvs = await localEnvProvider.loadVideoFilterLocalEnvs();
                videoFilterEnvs.template[localEnvProvider_1.LocalEnvKeys.videoFilterApp.template.SslCrtFile] = res.certPath;
                videoFilterEnvs.template[localEnvProvider_1.LocalEnvKeys.videoFilterApp.template.SslKeyFile] = res.keyPath;
                await localEnvProvider.saveVideoFilterLocalEnvs(videoFilterEnvs);
            }
            else {
                const frontendEnvs = await localEnvProvider.loadFrontendLocalEnvs();
                frontendEnvs.template[localEnvProvider_1.LocalEnvKeys.frontend.template.SslCrtFile] = res.certPath;
                frontendEnvs.template[localEnvProvider_1.LocalEnvKeys.frontend.template.SslKeyFile] = res.keyPath;
                await localEnvProvider.saveFrontendLocalEnvs(frontendEnvs);
            }
        }
        return res;
    }
    async getTaskJson(projectPath) {
        try {
            const taskFilePath = path.resolve(projectPath, ".vscode", "tasks.json");
            const content = await fs.readFile(taskFilePath, "utf-8");
            return commentJson.parse(content);
        }
        catch (_a) {
            return undefined;
        }
    }
    // Retry logic when reading project config files in case of read-write conflict
    async retry(func) {
        let n = 0;
        let error = undefined;
        while (n <= 2) {
            if (n !== 0) {
                await tools_1.waitSeconds(n);
            }
            try {
                return await func(n);
            }
            catch (e) {
                error = e;
                ++n;
            }
        }
        throw error;
    }
}
exports.LocalEnvManager = LocalEnvManager;
//# sourceMappingURL=localEnvManager.js.map