"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderTemplateContent = exports.unzip = exports.fetchZipFromUrl = exports.fetchTemplateUrl = exports.fetchTemplateTagList = exports.sendRequestWithTimeout = exports.sendRequestWithRetry = exports.templateFileExt = exports.tagListUrl = void 0;
const tslib_1 = require("tslib");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const os_1 = require("os");
const templates_config_json_1 = tslib_1.__importDefault(require("../templates-config.json"));
const templates_1 = require("./templates");
exports.tagListUrl = templates_config_json_1.default.tagListURL;
exports.templateFileExt = ".tpl";
async function sendRequestWithRetry(requestFn, tryLimits) {
    var _a;
    // !status means network error, see https://github.com/axios/axios/issues/383
    const canTry = (status) => !status || (status >= 500 && status < 600);
    let status;
    let error;
    for (let i = 0; i < tryLimits && canTry(status); i++) {
        try {
            const res = await requestFn();
            if (res.status === 200 || res.status === 201) {
                return res;
            }
            error = new Error(`HTTP Request failed: ${JSON.stringify(res)}`);
            status = res.status;
        }
        catch (e) {
            error = e;
            status = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status;
        }
    }
    error !== null && error !== void 0 ? error : (error = new Error(`RequestWithRetry got bad tryLimits: ${tryLimits}`));
    throw error;
}
exports.sendRequestWithRetry = sendRequestWithRetry;
async function sendRequestWithTimeout(requestFn, timeoutInMs, tryLimits = 1) {
    const source = axios_1.default.CancelToken.source();
    const timeout = setTimeout(() => {
        source.cancel();
    }, timeoutInMs);
    try {
        const res = await sendRequestWithRetry(() => requestFn(source.token), tryLimits);
        clearTimeout(timeout);
        return res;
    }
    catch (err) {
        if (axios_1.default.isCancel(err)) {
            throw new Error("Request timeout");
        }
        throw err;
    }
}
exports.sendRequestWithTimeout = sendRequestWithTimeout;
async function fetchTemplateTagList(url, tryLimits, timeoutInMs) {
    const res = await sendRequestWithTimeout(async (cancelToken) => {
        return await axios_1.default.get(url, {
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    return res.data;
}
exports.fetchTemplateTagList = fetchTemplateTagList;
async function fetchTemplateUrl(group, language, scenario, tryLimits, timeoutInMs) {
    const tags = await fetchTemplateTagList(exports.tagListUrl, tryLimits, timeoutInMs);
    const selectedTag = templates_1.selectTag(tags.replace(/\r/g, "").split("\n"));
    if (!selectedTag) {
        throw new Error(`Failed to find valid template for ${group}+${language}+${scenario}`);
    }
    return templates_1.templateURL(selectedTag, `${group}.${language}.${scenario}`);
}
exports.fetchTemplateUrl = fetchTemplateUrl;
async function fetchZipFromUrl(url, tryLimits, timeoutInMs) {
    const res = await sendRequestWithTimeout(async (cancelToken) => {
        return await axios_1.default.get(url, {
            responseType: "arraybuffer",
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    const zip = new adm_zip_1.default(res.data);
    return zip;
}
exports.fetchZipFromUrl = fetchZipFromUrl;
/* The unzip used for scaffold which would drop the attr of the files and dirs. */
async function unzip(zip, dstPath, nameReplaceFn, dataReplaceFn, filesInAppendMode = [".gitignore"]) {
    const entries = zip.getEntries().filter((entry) => !entry.isDirectory);
    for (const entry of entries) {
        const rawEntryData = entry.getData();
        const entryName = nameReplaceFn
            ? nameReplaceFn(entry.entryName, rawEntryData)
            : entry.entryName;
        const entryData = dataReplaceFn
            ? dataReplaceFn(entry.name, rawEntryData)
            : rawEntryData;
        const filePath = path_1.default.join(dstPath, entryName);
        const dirPath = path_1.default.dirname(filePath);
        await fs_extra_1.default.ensureDir(dirPath);
        if (filesInAppendMode.includes(entryName) && (await fs_extra_1.default.pathExists(filePath))) {
            await fs_extra_1.default.appendFile(filePath, os_1.EOL);
            await fs_extra_1.default.appendFile(filePath, entryData);
        }
        else {
            await fs_extra_1.default.writeFile(filePath, entryData);
        }
    }
}
exports.unzip = unzip;
function renderTemplateContent(filePath, data, variables) {
    if (path_1.default.extname(filePath) === exports.templateFileExt) {
        return mustache_1.default.render(data.toString(), variables);
    }
    // Return Buffer instead of string if the file is not a template. Because `toString()` may break binary resources, like png files.
    return data;
}
exports.renderTemplateContent = renderTemplateContent;
//# sourceMappingURL=templatesUtils.js.map