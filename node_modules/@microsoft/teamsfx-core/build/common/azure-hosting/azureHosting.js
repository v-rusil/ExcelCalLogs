"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureHosting = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const constants_1 = require("../constants");
const folder_1 = require("../../folder");
const messages_1 = require("./messages");
const utils_1 = require("./utils");
const tools_1 = require("../tools");
class AzureHosting {
    constructor() {
        this.reference = undefined;
    }
    getBicepTemplateFolder() {
        return path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "resource", "hosting", "bicep", this.hostType);
    }
    async generateBicep(bicepContext) {
        var _a, _b;
        // * The order matters.
        // * 0: Provision Orchestration, 1: Provision Module, 2: Configuration Orchestration, 3: Configuration Module
        const bicepFiles = [constants_1.Bicep.ProvisionFileName, `${this.hostType}Provision.template.bicep`];
        if (this.configurable) {
            bicepFiles.push(constants_1.Bicep.ConfigFileName);
            bicepFiles.push(`${this.hostType}Configuration.template.bicep`);
        }
        const context = utils_1.getHandlebarContext(bicepContext, this.hostType);
        const bicepTemplateDir = this.getBicepTemplateFolder();
        const modules = await Promise.all(bicepFiles.map(async (filename) => await tools_1.generateBicepFromFile(path_1.default.join(bicepTemplateDir, filename), context)));
        // parameters should be undefined if parameter file does not exist
        let parameters;
        const parameterFilePath = path_1.default.join(bicepTemplateDir, constants_1.Bicep.ParameterFileName);
        if (await fs.pathExists(parameterFilePath)) {
            parameters = await fs.readJson(parameterFilePath);
        }
        (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.call(_a, messages_1.Messages.generateBicep(this.hostType));
        return {
            Provision: {
                Orchestration: modules[0],
                Modules: { [context.moduleName]: modules[1] },
            },
            Configuration: this.configurable
                ? {
                    Orchestration: modules[2],
                    Modules: {
                        [context.moduleName]: modules[3],
                    },
                }
                : undefined,
            Reference: this.reference,
            Parameters: parameters,
        };
    }
    async updateBicep(bicepContext) {
        var _a, _b, _c, _d;
        // * The order matters.
        // * 0: Configuration Orchestration, 1: Configuration Module
        if (!this.configurable) {
            (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, messages_1.Messages.updateBicep(this.hostType));
            return {};
        }
        const bicepFile = `${this.hostType}Configuration.template.bicep`;
        const context = utils_1.getHandlebarContext(bicepContext, this.hostType);
        const bicepTemplateDir = this.getBicepTemplateFolder();
        const module = await tools_1.generateBicepFromFile(path_1.default.join(bicepTemplateDir, bicepFile), context);
        (_d = (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.call(_c, messages_1.Messages.updateBicep(this.hostType));
        return {
            Configuration: {
                Modules: { [context.moduleName]: module },
            },
            Reference: this.reference,
        };
    }
    async configure(ctx) {
        return teamsfx_api_1.Void;
    }
    /**
     * deploy to Azure
     * @param resourceId Azure resource id
     * @param tokenProvider token environment
     * @param buffer zip file stream buffer
     */
    async deploy(resourceId, tokenProvider, buffer) {
        return teamsfx_api_1.Void;
    }
    setLogger(logger) {
        this.logger = logger;
    }
}
exports.AzureHosting = AzureHosting;
//# sourceMappingURL=azureHosting.js.map