"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.azureWebSiteDeploy = exports.mergeTemplates = exports.capitalizeFirstLetter = exports.getHandlebarContext = void 0;
const tslib_1 = require("tslib");
const appService = tslib_1.__importStar(require("@azure/arm-appservice"));
const js_base64_1 = require("js-base64");
const azureOps_1 = require("./azureOps");
const hostingConstant_1 = require("./hostingConstant");
const hostingError_1 = require("./hostingError");
const tools_1 = require("../tools");
const messages_1 = require("./messages");
function getHandlebarContext(bicepContext, serviceType) {
    var _a, _b;
    const moduleName = (_b = (_a = bicepContext.moduleNames) === null || _a === void 0 ? void 0 : _a[serviceType]) !== null && _b !== void 0 ? _b : serviceType;
    return {
        plugins: bicepContext.plugins,
        configs: bicepContext.configs,
        moduleName: moduleName,
        moduleNameCapitalized: capitalizeFirstLetter(moduleName),
        moduleAlias: bicepContext.moduleAlias,
        pluginId: bicepContext.pluginId,
    };
}
exports.getHandlebarContext = getHandlebarContext;
function capitalizeFirstLetter([first, ...rest]) {
    return [first === null || first === void 0 ? void 0 : first.toUpperCase(), ...rest].join("");
}
exports.capitalizeFirstLetter = capitalizeFirstLetter;
function mergeTemplates(templates) {
    const existsProvision = templates.some((it) => it.Provision);
    const existsParameters = templates.some((it) => it.Parameters);
    return {
        Provision: existsProvision
            ? {
                Orchestration: templates.map((template) => { var _a; return (_a = template.Provision) === null || _a === void 0 ? void 0 : _a.Orchestration; }).join(""),
                Modules: templates
                    .map((template) => { var _a; return (_a = template.Provision) === null || _a === void 0 ? void 0 : _a.Modules; })
                    .reduce((result, current) => Object.assign(result, current), {}),
            }
            : undefined,
        Configuration: {
            Orchestration: templates.map((template) => { var _a; return (_a = template.Configuration) === null || _a === void 0 ? void 0 : _a.Orchestration; }).join(""),
            Modules: templates
                .map((template) => { var _a; return (_a = template.Configuration) === null || _a === void 0 ? void 0 : _a.Modules; })
                .reduce((result, current) => Object.assign(result, current), {}),
        },
        Parameters: existsParameters
            ? Object.assign({}, ...templates.map((template) => template.Parameters))
            : undefined,
        Reference: Object.assign({}, ...templates.map((template) => template.Reference)),
    };
}
exports.mergeTemplates = mergeTemplates;
async function getAzureAccountCredential(tokenProvider) {
    const credential = await tokenProvider.azureAccountProvider.getIdentityCredentialAsync();
    if (!credential) {
        throw new hostingError_1.PreconditionError(hostingConstant_1.AzureOpsConstant.FAIL_TO_GET_AZURE_CREDENTIALS(), [
            hostingConstant_1.AzureOpsConstant.TRY_LOGIN_AZURE(),
        ]);
    }
    return credential;
}
async function fetchWebSiteManagementClient(subscriptionId, tokenProvider) {
    return new appService.WebSiteManagementClient(await getAzureAccountCredential(tokenProvider), subscriptionId);
}
async function getAzureDeployConfig(subscriptionId, rgName, siteName, tokenProvider) {
    var _a, _b;
    // get publish credentials
    const webSiteMgmtClient = await fetchWebSiteManagementClient(subscriptionId, tokenProvider);
    const listResponse = await azureOps_1.AzureOperations.listPublishingCredentials(webSiteMgmtClient, rgName, siteName);
    const publishingUserName = (_a = listResponse.publishingUserName) !== null && _a !== void 0 ? _a : "";
    const publishingPassword = (_b = listResponse.publishingPassword) !== null && _b !== void 0 ? _b : "";
    const encryptedCredentials = js_base64_1.Base64.encode(`${publishingUserName}:${publishingPassword}`);
    return [
        {
            headers: {
                "Content-Type": "application/octet-stream",
                "Cache-Control": "no-cache",
                Authorization: `Basic ${encryptedCredentials}`,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            timeout: hostingConstant_1.AzureOperationCommonConstants.deployTimeoutInMs,
        },
        webSiteMgmtClient,
    ];
}
async function azureWebSiteDeploy(resourceId, tokenProvider, buffer, logger, progress) {
    var _a;
    const subscriptionId = tools_1.getSubscriptionIdFromResourceId(resourceId);
    const rgName = tools_1.getResourceGroupNameFromResourceId(resourceId);
    const siteName = tools_1.getSiteNameFromResourceId(resourceId);
    const [config, client] = await getAzureDeployConfig(subscriptionId, rgName, siteName, tokenProvider);
    const zipDeployEndpoint = getZipDeployEndpoint(siteName);
    await (progress === null || progress === void 0 ? void 0 : progress.next(messages_1.Messages.zipDeploy));
    const statusUrl = await azureOps_1.AzureOperations.zipDeployPackage(zipDeployEndpoint, buffer, config);
    await azureOps_1.AzureOperations.checkDeployStatus(statusUrl, config);
    (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, messages_1.Messages.deploy(zipDeployEndpoint, buffer.byteLength));
    return client;
}
exports.azureWebSiteDeploy = azureWebSiteDeploy;
function getZipDeployEndpoint(siteName) {
    return `https://${siteName}.scm.azurewebsites.net/api/zipdeploy?isAsync=true`;
}
//# sourceMappingURL=utils.js.map