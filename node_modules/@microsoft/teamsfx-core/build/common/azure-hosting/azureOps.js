"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHttpCodeAccepted = exports.isHttpCodeOkOrCreated = exports.AzureOperations = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const hostingError_1 = require("./hostingError");
const hostingConstant_1 = require("./hostingConstant");
const tools_1 = require("../tools");
const messages_1 = require("./messages");
/**
 * operate int azure
 */
class AzureOperations {
    static async listPublishingCredentials(webSiteMgmtClient, resourceGroup, siteName) {
        let listResponse;
        try {
            listResponse = await webSiteMgmtClient.webApps.beginListPublishingCredentialsAndWait(resourceGroup, siteName);
        }
        catch (e) {
            throw new hostingError_1.ListPublishingCredentialsError(e);
        }
        if (!listResponse) {
            throw new hostingError_1.ListPublishingCredentialsError();
        }
        return listResponse;
    }
    static async zipDeployPackage(zipDeployEndpoint, zipBuffer, config, logger) {
        var _a;
        let res;
        try {
            res = await AzureOperations.axiosInstance.post(zipDeployEndpoint, zipBuffer, config);
        }
        catch (e) {
            throw new hostingError_1.ZipDeployError(e);
        }
        if (!res || !isHttpCodeAccepted(res === null || res === void 0 ? void 0 : res.status)) {
            if (res === null || res === void 0 ? void 0 : res.status) {
                (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, messages_1.Messages.deployFailed(res.status));
            }
            throw new hostingError_1.ZipDeployError();
        }
        return res.headers.location;
    }
    static async checkDeployStatus(location, config, logger) {
        var _a;
        let res;
        for (let i = 0; i < hostingConstant_1.DeployStatusConstant.RETRY_TIMES; ++i) {
            try {
                res = await AzureOperations.axiosInstance.get(location, config);
            }
            catch (e) {
                throw new hostingError_1.DeployStatusError(e);
            }
            if (res) {
                if (isHttpCodeAccepted(res === null || res === void 0 ? void 0 : res.status)) {
                    await tools_1.waitSeconds(hostingConstant_1.DeployStatusConstant.BACKOFF_TIME_S);
                }
                else if (isHttpCodeOkOrCreated(res === null || res === void 0 ? void 0 : res.status)) {
                    return;
                }
                else {
                    if (res.status) {
                        (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, messages_1.Messages.deployFailed(res.status));
                    }
                    throw new hostingError_1.DeployStatusError();
                }
            }
        }
        throw new hostingError_1.DeployTimeoutError();
    }
    static async restartWebApp(webSiteMgmtClient, resourceGroup, siteName, logger) {
        var _a;
        (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, messages_1.Messages.restartFunction(siteName));
        try {
            await webSiteMgmtClient.webApps.restart(resourceGroup, siteName);
        }
        catch (e) {
            throw new hostingError_1.RestartWebAppError(e);
        }
    }
}
exports.AzureOperations = AzureOperations;
AzureOperations.axiosInstance = axios_1.default.create();
function isHttpCodeOkOrCreated(code) {
    return code !== undefined && [200, 201].includes(code);
}
exports.isHttpCodeOkOrCreated = isHttpCodeOkOrCreated;
function isHttpCodeAccepted(code) {
    return code === 202;
}
exports.isHttpCodeAccepted = isHttpCodeAccepted;
//# sourceMappingURL=azureOps.js.map