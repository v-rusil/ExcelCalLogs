// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.unacquireWithTeams = exports.updateM365Account = exports.registerWithTeams = void 0;
const tslib_1 = require("tslib");
const childProcess = require("child_process");
const fs = require("fs");
const path = require("path");
function registerWithTeams(zipPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (zipPath.endsWith(".zip") && fs.existsSync(zipPath)) {
                const sideloadCommand = `npx @microsoft/teamsfx-cli m365 sideloading --file-path ${zipPath}`;
                console.log(`running: ${sideloadCommand}`);
                childProcess.exec(sideloadCommand, (error, stdout, stderr) => {
                    let titleIdMatch = stdout.match(/TitleId:\s*(.*)/);
                    let titleId = titleIdMatch !== null ? titleIdMatch[1] : "??";
                    if (error || stderr.match('"error"')) {
                        console.log(`\n${stdout}\n--Error sideloading!--\nError: ${error}\nSTDERR:\n${stderr}`);
                        reject(error);
                    }
                    else {
                        console.log(`\n${stdout}\nSuccessfully registered package! (${titleId})\n STDERR: ${stderr}\n`);
                        forceCacheUpdate();
                        resolve(titleId);
                    }
                });
            }
            else {
                reject(new Error(`The file '${zipPath}' is not valid`));
            }
        });
    });
}
exports.registerWithTeams = registerWithTeams;
function updateM365Account(operation) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const loginCommand = `npx @microsoft/teamsfx-cli account ${operation} m365`;
            console.log(`running: ${loginCommand}`);
            childProcess.exec(loginCommand, (error, stdout, stderr) => {
                if (error || (stderr.length > 0 && /Debugger attached\./.test(stderr) == false)) {
                    console.log(`Error logging in:\n STDOUT: ${stdout}\n ERROR: ${error}\n STDERR: ${stderr}`);
                    reject(error);
                }
                else {
                    console.log(`Successfully logged in/out.\n`);
                    resolve();
                }
            });
        });
    });
}
exports.updateM365Account = updateM365Account;
function unacquireWithTeams(titleId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const unacquireCommand = `npx @microsoft/teamsfx-cli m365 unacquire --title-id ${titleId}`;
            console.log(`running: ${unacquireCommand}`);
            childProcess.exec(unacquireCommand, (error, stdout, stderr) => {
                if (error || stderr.match('"error"')) {
                    console.log(`\n${stdout}\n--Error unacquireing!--\n${error}\n STDERR: ${stderr}`);
                    reject(error);
                }
                else {
                    console.log(`\n${stdout}\nSuccessfully unacquired title!\n STDERR: ${stderr}\n`);
                    forceCacheUpdate();
                    resolve();
                }
            });
        });
    });
}
exports.unacquireWithTeams = unacquireWithTeams;
function forceCacheUpdate() {
    // TODO: find HubAppFileCache on Mac and do the same targeted delete
    if (process.platform === "win32") {
        const cachePath = path.join(process.env.LOCALAPPDATA, "Microsoft\\Outlook\\HubAppFileCache");
        if (fs.existsSync(cachePath)) {
            // Get list of folders with hashed names
            const subFolders = fs.readdirSync(cachePath, { withFileTypes: true }).filter((entry) => {
                return entry.isDirectory();
            });
            // Delete any found file that prevents TAOS service calls
            subFolders.forEach((folder) => {
                const targetFiles = [
                    path.resolve(cachePath, folder.name, "TaosSource\\CacheProperties"),
                    path.resolve(cachePath, folder.name, "TaosSource\\PersistedCacheSynced"),
                    path.resolve(cachePath, folder.name, "TaosSource\\u8qUM7HfoAFQ6YiuZO0RVQ=="),
                    path.resolve(cachePath, folder.name, "TaosSource\\ZplQ1yfT07QnEV2xMoi+GQ=="),
                ];
                targetFiles.forEach((file) => {
                    if (fs.existsSync(file)) {
                        console.log(`Deleting File: ${file}`);
                        fs.unlinkSync(file);
                    }
                });
            });
        }
    }
}
//# sourceMappingURL=publish.js.map